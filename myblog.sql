-- MySQL dump 10.13  Distrib 8.0.11, for Win64 (x86_64)
--
-- Host: 118.89.247.210    Database: myblog
-- ------------------------------------------------------
-- Server version	8.0.15

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
 SET NAMES utf8mb4 ;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `bk_blog`
--

DROP TABLE IF EXISTS `bk_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `contentHtml` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `contentMarkDown` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDateTime` datetime NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `commentCount` int(11) DEFAULT NULL,
  `viewCount` int(11) unsigned NOT NULL DEFAULT '0',
  `tagId` int(11) DEFAULT '0',
  `imageId` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`,`title`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_blog`
--

LOCK TABLES `bk_blog` WRITE;
/*!40000 ALTER TABLE `bk_blog` DISABLE KEYS */;
INSERT INTO `bk_blog` VALUES (1,'springmvc配置静态资源','<p>跟着传智的视频在做那个淘淘商城的项目，做到第二天，发现自己以前学习的SSM框架还有一些东西没有完全弄懂，很多东西只是会用，但是完全不知道为什么而用，通过这个项目练手，也是对SSM框架的一种补充。</p>\n<p>今天就来说一说如何在一个SSM框架中配置访问静态资源的问题。</p>\n<p>首先，必须要有一个SSM环境呗，这里我就以淘淘商城为例子。</p>\n<p>贴一下web.xml的配置：</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns=\"http://java.sun.com/xml/ns/javaee\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n    version=\"2.5\"&gt;\n    &lt;display-name&gt;taotao-manager-web&lt;/display-name&gt;\n    &lt;welcome-file-list&gt;\n        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\n    &lt;/welcome-file-list&gt;\n    &lt;!-- 配置dispatcherservlet --&gt;\n    &lt;!-- url拦截形式 --&gt;\n    &lt;!-- 加载springmvc --&gt;\n    &lt;!-- springmvc的前端控制器 --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;taotao-manager-web&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+\"-servlet.xml\" --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;taotao-manager-web&lt;/servlet-name&gt;\n        &lt;!-- /*表示拦截所有，包括转发的JSP页面  这是错误的，不能用 --&gt;\n        &lt;!-- /表示拦截所有的静态资源，不包括转发的JSP --&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;/param-name&gt;\n            &lt;param-value&gt;utf-8&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n\n&lt;/web-app&gt;\n</code></pre><p>可以看到在spring前端控制器DispatcherServlet中配置的是 / 拦截规则，这里配置 / 的意思是说，所有的请求都需要经过前端控制器，自然也会拦截所有的css、jsp、js等静态资源。注意千万不能配置成 /* 否则包括jsp在内的静态资源的请求都会被拦截。</p>\n<p>这个时候如果你在spring的配置文件中没有配置静态资源拦截的话那么就会出现诸如css、js文件加载不出来的问题，你需要在springmvc.xml文件中加上<mvc>这样一句。<p></p></mvc>\n<p>springmvc.xml:</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \"&gt;\n    &lt;context:component-scan base-package=\"com.taotao.controller\" /&gt;\n   &lt;!-- 这里配置使用servlet默认的静态资源处理方式--&gt;\n    &lt;mvc:default-servlet-handler/&gt;\n    &lt;mvc:annotation-driven /&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt;\n        &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n    &lt;/bean&gt;    \n    &lt;!-- 引用dubbo --&gt;\n    &lt;dubbo:application name=\"taotao-manager-web\" /&gt;\n    &lt;dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" /&gt;\n&lt;/beans&gt;\n</code></pre><p>在注释处使用了默认的servlet静态资源处理方式，这样就是说让tomcat自己处理，如果你是这样配置的话。那么会很麻烦，因为你所有的请求都会被springmvc捕捉，然后传递请求到controller，你需要写一个页面跳转控制器</p>\n<p>PageController.java:</p>\n<pre><code>package com.taotao.controller;\n/**\n * \n * @author Administrator\n *\n */\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PageController {\n\n    @RequestMapping(\"/\")\n    public String showIndex() {\n        return \"index\";\n    }\n\n    @RequestMapping(\"/{page}\")\n    public String showPage(@PathVariable String page) {\n\n        return page;\n    }\n}\n</code></pre><p>有了这个之后，你在访问静态jsp的时候可以使用  /page名 的方式来访问，css、img资源也会正常的加载。也就是说你请求jsp的话就是通过这个controller来进行跳转的。这里需要springmvc的视图解析器配置正确。</p>\n<p>但是不推荐这种，因为需要访问controller，耗费时间。推荐在springmvc中这样修改。</p>\n<p>springmvc.xml:</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \"&gt;\n\n    &lt;context:component-scan base-package=\"com.taotao.controller\" /&gt;\n    &lt;mvc:annotation-driven /&gt;\n    &lt;bean\n        class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt;\n        &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n    &lt;/bean&gt;    \n    &lt;!-- 配置静态资源映射 --&gt;\n    &lt;!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 --&gt;\n    &lt;!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 --&gt;\n        &lt;mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/&gt;\n        &lt;mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/&gt;\n\n    &lt;!-- 引用dubbo --&gt;\n    &lt;dubbo:application name=\"taotao-manager-web\" /&gt;\n    &lt;dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" /&gt;\n&lt;/beans&gt;\n</code></pre><p>可以看到就是将<mvc>换成了以下的代码：<p></p></mvc>\n<pre><code>&lt;!-- 配置静态资源映射 --&gt;\n    &lt;!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 --&gt;\n    &lt;!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 --&gt;\n        &lt;mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/&gt;\n        &lt;mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/&gt;\n</code></pre><p>其中 location属性是你的静态资源放置的真实位置，也就是WEN-INF下面的js文件夹和css文件夹，然后将其映射到 /js/<strong> 和 /css/</strong> 路径，也就是说使用  /js/** 这样的路径不会被前端控制器处理，直接访问的是静态资源。</p>\n<p>关于SSM还有很多细节问题需要注意，希望读者能够在写代码的时候多多注意。</p>','跟着传智的视频在做那个淘淘商城的项目，做到第二天，发现自己以前学习的SSM框架还有一些东西没有完全弄懂，很多东西只是会用，但是完全不知道为什么而用，通过这个项目练手，也是对SSM框架的一种补充。\n\n今天就来说一说如何在一个SSM框架中配置访问静态资源的问题。\n\n首先，必须要有一个SSM环境呗，这里我就以淘淘商城为例子。\n\n贴一下web.xml的配置：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns=\"http://java.sun.com/xml/ns/javaee\"\n	xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n	version=\"2.5\">\n	<display-name>taotao-manager-web</display-name>\n	<welcome-file-list>\n		<welcome-file>index.html</welcome-file>\n		<welcome-file>index.htm</welcome-file>\n		<welcome-file>index.jsp</welcome-file>\n		<welcome-file>default.html</welcome-file>\n		<welcome-file>default.htm</welcome-file>\n		<welcome-file>default.jsp</welcome-file>\n	</welcome-file-list>\n	<!-- 配置dispatcherservlet -->\n	<!-- url拦截形式 -->\n	<!-- 加载springmvc -->\n	<!-- springmvc的前端控制器 -->\n	<servlet>\n		<servlet-name>taotao-manager-web</servlet-name>\n		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n		<!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+\"-servlet.xml\" -->\n		<init-param>\n			<param-name>contextConfigLocation</param-name>\n			<param-value>classpath:spring/springmvc.xml</param-value>\n		</init-param>\n		<load-on-startup>1</load-on-startup>\n	</servlet>\n	<servlet-mapping>\n		<servlet-name>taotao-manager-web</servlet-name>\n		<!-- /*表示拦截所有，包括转发的JSP页面  这是错误的，不能用 -->\n		<!-- /表示拦截所有的静态资源，不包括转发的JSP -->\n		<url-pattern>/</url-pattern>\n	</servlet-mapping>\n	<filter>\n		<filter-name>CharacterEncodingFilter</filter-name>\n		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n		<init-param>\n			<param-name>encoding</param-name>\n			<param-value>utf-8</param-value>\n		</init-param>\n	</filter>\n	<filter-mapping>\n		<filter-name>CharacterEncodingFilter</filter-name>\n		<url-pattern>/*</url-pattern>\n	</filter-mapping>\n\n</web-app>\n```\n可以看到在spring前端控制器DispatcherServlet中配置的是 / 拦截规则，这里配置 / 的意思是说，所有的请求都需要经过前端控制器，自然也会拦截所有的css、jsp、js等静态资源。注意千万不能配置成 /* 否则包括jsp在内的静态资源的请求都会被拦截。\n\n这个时候如果你在spring的配置文件中没有配置静态资源拦截的话那么就会出现诸如css、js文件加载不出来的问题，你需要在springmvc.xml文件中加上<mvc:default-servlet-handler/>这样一句。\n\nspringmvc.xml:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \">\n	<context:component-scan base-package=\"com.taotao.controller\" />\n   <!-- 这里配置使用servlet默认的静态资源处理方式-->\n	<mvc:default-servlet-handler/>\n	<mvc:annotation-driven />\n	<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n		<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n		<property name=\"suffix\" value=\".jsp\" />\n	</bean>	\n	<!-- 引用dubbo -->\n	<dubbo:application name=\"taotao-manager-web\" />\n	<dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" />\n	<dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" />\n	<dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" />\n</beans>\n```\n在注释处使用了默认的servlet静态资源处理方式，这样就是说让tomcat自己处理，如果你是这样配置的话。那么会很麻烦，因为你所有的请求都会被springmvc捕捉，然后传递请求到controller，你需要写一个页面跳转控制器\n\nPageController.java:\n```\npackage com.taotao.controller;\n/**\n * \n * @author Administrator\n *\n */\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PageController {\n	\n	@RequestMapping(\"/\")\n	public String showIndex() {\n		return \"index\";\n	}\n	\n	@RequestMapping(\"/{page}\")\n	public String showPage(@PathVariable String page) {\n		\n		return page;\n	}\n}\n\n```\n有了这个之后，你在访问静态jsp的时候可以使用  /page名 的方式来访问，css、img资源也会正常的加载。也就是说你请求jsp的话就是通过这个controller来进行跳转的。这里需要springmvc的视图解析器配置正确。\n\n但是不推荐这种，因为需要访问controller，耗费时间。推荐在springmvc中这样修改。\n\nspringmvc.xml:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \">\n\n	<context:component-scan base-package=\"com.taotao.controller\" />\n	<mvc:annotation-driven />\n	<bean\n		class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n		<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n		<property name=\"suffix\" value=\".jsp\" />\n	</bean>	\n	<!-- 配置静态资源映射 -->\n	<!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 -->\n	<!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 -->\n		<mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/>\n		<mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/>\n	\n	<!-- 引用dubbo -->\n	<dubbo:application name=\"taotao-manager-web\" />\n	<dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" />\n	<dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" />\n	<dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" />\n</beans>\n```\n可以看到就是将<mvc:default-servlet-handler/>换成了以下的代码：\n```\n<!-- 配置静态资源映射 -->\n	<!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 -->\n	<!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 -->\n		<mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/>\n		<mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/>\n```\n其中 location属性是你的静态资源放置的真实位置，也就是WEN-INF下面的js文件夹和css文件夹，然后将其映射到 /js/** 和 /css/** 路径，也就是说使用  /js/** 这样的路径不会被前端控制器处理，直接访问的是静态资源。\n\n关于SSM还有很多细节问题需要注意，希望读者能够在写代码的时候多多注意。\n\n\n\n\n\n','跟着传智的视频在做那个淘淘商城的项目，做到第二天，发现自己以前学习的SSM框架还有一些东西没有完全弄懂，很多东西只是会用，但是完全不知道为什么而用，通过这个项目练手，也是对SSM框架的一种补充。今天就来说一说如何在一个SSM框架中配置访问静态资源的问题。首先，必须要','2018-11-30 23:54:08','2018-11-30 23:54:12',5,157,10,'938b5b9a9e554fd982c6109dcae446e8',1),(2,'mybatis分页插件pageHelper使用详解','<p>一直以来都用的是自己封装的一个pageBean类来处理分页相关的业务，这个pageBean是从传智播客的视频上面学到的，最近看到别人写的都是用的mybatis的pageHelper,所以自己也心痒痒，将自己的一个竞赛管理系统的分页也换成了pageHelper的方式。话不多说，直接上配置。</p>\n<p>首先要使用mybatis的这个插件就必须在mybatis的配置文件中配置插件的相关设置。</p>\n<p>mybatis-config.xml :</p>\n<pre><code>&lt;configuration&gt;\n\n    &lt;typeAliases&gt;\n        &lt;package name=\"cn.ljtnono.jsgl.pojo\" /&gt;\n        &lt;package name=\"cn.ljtnono.jsgl.vo\" /&gt;\n    &lt;/typeAliases&gt;\n\n    &lt;plugins&gt;\n        &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt;\n            &lt;!--使用的方言，值有mysql oracle SqlServer等--&gt;\n            &lt;property name=\"dialect\" value=\"mysql\"/&gt;\n            &lt;!-- 该参数默认为false --&gt;\n            &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;\n            &lt;!-- 和startPage中的pageNum效果一样--&gt;\n            &lt;property name=\"offsetAsPageNum\" value=\"true\"/&gt;\n            &lt;!-- 该参数默认为false --&gt;\n            &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;\n            &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt;\n            &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;\n            &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）\n            &lt;property name=\"pageSizeZero\" value=\"true\"/&gt;--&gt;\n            &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;\n            &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;\n            &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;\n            &lt;property name=\"reasonable\" value=\"true\"/&gt;\n            &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;\n            &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;\n            &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;\n            &lt;!-- 不理解该含义的前提下，不要随便复制该配置\n            &lt;property name=\"params\" value=\"pageNum=start;pageSize=limit;\"/&gt;    --&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n\n    &lt;!-- 在这里环境标签默认填写的是id为mysql的环境，与spring整合后就废除了环境标签 --&gt;\n    &lt;!-- 配置从哪里读取mapper文件 --&gt;\n    &lt;mappers&gt;\n        &lt;package name=\"cn.ljtnono.jsgl.dao\" /&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre><p>这里解释下各种参数：<br>1、dialect  方言，相信大家不会陌生，就是配置数据库类型，常见的值有mysql、oracle、SqlServer等。这一项是必须配置的。<br>2、增加offsetAsPageNum属性，默认值为false，则使用默认值时不需要增加该配置，需要设为真时，需要配置该参数。当该参数设置为真时，使用RowBounds分页时，会将偏移参数当成页次使用，可以用页码和页面大小两个参数进行分页。\n<p>后面两个参数的作用在注释中解释的非常清楚了，这里不再赘述，关于参数还有好几个，大家可以查看<a href=\"https://github.com/pagehelper/Mybatis-PageHelper\">https://github.com/pagehelper/Mybatis-PageHelper</a> github官方文档。</p>\n<p>然后就是使用了，这里以查询一个竞赛列表信息为例子。</p>\n<pre><code>@Override\n    public PageInfo&lt;Contest&gt; getContestListByModality(int modality, int currentPage) {\n\n        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(1);\n        PageInfo&lt;Contest&gt; pageInfo = null;\n        map.put(\"modality\",modality);\n        try {\n            PageHelper.startPage(currentPage,CURRENTCOUNT);\n            List&lt;Contest&gt; list = contestDaoMapper.selectByModality(map);\n            pageInfo = new PageInfo&lt;&gt;(list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pageInfo;\n    }\n</code></pre><p>在PageHelper.startPage() 后面的第一个查询会默认使用分页查询，也就是说不必自己再写一个sql去查询总的条数。查询出来的结果使用pageInfo这个类进行接收。</p>\n<p>PageInfo这个类中封装了分页所需要的各种参数，十分方便。</p>\n<p>下面贴出PageInfo的源代码：</p>\n<pre><code>//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.github.pagehelper;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class PageInfo&lt;T&gt; implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private int pageNum;\n    private int pageSize;\n    private int size;\n    private int startRow;\n    private int endRow;\n    private long total;\n    private int pages;\n    private List&lt;T&gt; list;\n    private int firstPage;\n    private int prePage;\n    private int nextPage;\n    private int lastPage;\n    private boolean isFirstPage;\n    private boolean isLastPage;\n    private boolean hasPreviousPage;\n    private boolean hasNextPage;\n    private int navigatePages;\n    private int[] navigatepageNums;\n    ........\n   }\n</code></pre><p>参数解释：<br>pageNum ：当前页码数。<br>pageSize ： 每一页装的条数。<br>size ： 查询出来的总的页数。<br>startRow ：从哪一条开始查询的。<br>endRow ： 哪一条结束。<br>total ： 总的条数。<br>pages ： 总的页数。<br>list ： 记录集合。<br>firstPage ： 第一页。<br>prePage ： 上一页。<br>nextPage ： 下一页。<br>lastPage ： 最后一页。<br>isFirstPage ： 是否是第一页。<br>isLastPage ：是否是最后一页。<br>hasPreviousPage ： 是否有前一页。<br>hasNextPage ： 是否有后一页。<br>navigatePages ： 导航总的页数。<br>navigatepageNums ： 页数集合。即从第一页到最后一页的页码数。\n<p>这个类使用真的很方便，可以直接使用EL表达式来取值。</p>\n<p>在jsp中使用EL表达式取值：</p>\n<p>contest.jsp :</p>\n<pre><code>&lt;tbody&gt;\n     &lt;c:forEach items=\"${pageInfo.list}\" var=\"contest\"&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;\n                            ${contest.theam}\n                    &lt;/td&gt;\n                    &lt;td class=\"modality\"&gt;\n                        &lt;c:if test=\"${contest.modality == 0}\"&gt;\n                            个人\n                        &lt;/c:if&gt;\n                        &lt;c:if test=\"${contest.modality == 1}\"&gt;\n                            团队\n                        &lt;/c:if&gt;\n                        &lt;c:if test=\"${contest.modality == 2}\"&gt;\n                            个人/团队\n                        &lt;/c:if&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;${contest.way}&lt;/td&gt;\n                    &lt;td&gt;${contest.deadline}&lt;/td&gt;\n                    &lt;td&gt;${contest.startTime}&lt;/td&gt;\n                    &lt;td&gt;${contest.endTime}&lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;input type=\"button\" value=\"操作\" class=\"signUpOne btn btn-xs\" data-contestId=\"${contest.id}\"&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/c:forEach&gt;\n            &lt;/tbody&gt;\n</code></pre><p>以上就是最简单的pageHelper使用教程了，如果需要深入了解使用方式，请参考github：<a href=\"https://github.com/pagehelper/Mybatis-PageHelper。\">https://github.com/pagehelper/Mybatis-PageHelper。</a></p>','一直以来都用的是自己封装的一个pageBean类来处理分页相关的业务，这个pageBean是从传智播客的视频上面学到的，最近看到别人写的都是用的mybatis的pageHelper,所以自己也心痒痒，将自己的一个竞赛管理系统的分页也换成了pageHelper的方式。话不多说，直接上配置。\n\n首先要使用mybatis的这个插件就必须在mybatis的配置文件中配置插件的相关设置。\n\nmybatis-config.xml :\n```\n<configuration>\n\n	<typeAliases>\n		<package name=\"cn.ljtnono.jsgl.pojo\" />\n		<package name=\"cn.ljtnono.jsgl.vo\" />\n	</typeAliases>\n\n	<plugins>\n		<plugin interceptor=\"com.github.pagehelper.PageHelper\">\n			<!--使用的方言，值有mysql oracle SqlServer等-->\n			<property name=\"dialect\" value=\"mysql\"/>\n			<!-- 该参数默认为false -->\n			<!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 -->\n			<!-- 和startPage中的pageNum效果一样-->\n			<property name=\"offsetAsPageNum\" value=\"true\"/>\n			<!-- 该参数默认为false -->\n			<!-- 设置为true时，使用RowBounds分页会进行count查询 -->\n			<property name=\"rowBoundsWithCount\" value=\"true\"/>\n			<!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 -->\n			<!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）\n            <property name=\"pageSizeZero\" value=\"true\"/>-->\n			<!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 -->\n			<!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 -->\n			<!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 -->\n			<property name=\"reasonable\" value=\"true\"/>\n			<!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 -->\n			<!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 -->\n			<!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 -->\n			<!-- 不理解该含义的前提下，不要随便复制该配置\n            <property name=\"params\" value=\"pageNum=start;pageSize=limit;\"/>    -->\n		</plugin>\n	</plugins>\n\n	<!-- 在这里环境标签默认填写的是id为mysql的环境，与spring整合后就废除了环境标签 -->\n	<!-- 配置从哪里读取mapper文件 -->\n	<mappers>\n		<package name=\"cn.ljtnono.jsgl.dao\" />\n	</mappers>\n</configuration>\n```\n这里解释下各种参数：\n1、dialect  方言，相信大家不会陌生，就是配置数据库类型，常见的值有mysql、oracle、SqlServer等。这一项是必须配置的。\n2、增加offsetAsPageNum属性，默认值为false，则使用默认值时不需要增加该配置，需要设为真时，需要配置该参数。当该参数设置为真时，使用RowBounds分页时，会将偏移参数当成页次使用，可以用页码和页面大小两个参数进行分页。\n\n后面两个参数的作用在注释中解释的非常清楚了，这里不再赘述，关于参数还有好几个，大家可以查看https://github.com/pagehelper/Mybatis-PageHelper github官方文档。\n\n然后就是使用了，这里以查询一个竞赛列表信息为例子。\n\n```\n@Override\n    public PageInfo<Contest> getContestListByModality(int modality, int currentPage) {\n\n        Map<String,Object> map = new HashMap<>(1);\n        PageInfo<Contest> pageInfo = null;\n        map.put(\"modality\",modality);\n        try {\n            PageHelper.startPage(currentPage,CURRENTCOUNT);\n            List<Contest> list = contestDaoMapper.selectByModality(map);\n            pageInfo = new PageInfo<>(list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pageInfo;\n    }\n```\n在PageHelper.startPage() 后面的第一个查询会默认使用分页查询，也就是说不必自己再写一个sql去查询总的条数。查询出来的结果使用pageInfo这个类进行接收。\n\nPageInfo这个类中封装了分页所需要的各种参数，十分方便。\n\n下面贴出PageInfo的源代码：\n```\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.github.pagehelper;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class PageInfo<T> implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private int pageNum;\n    private int pageSize;\n    private int size;\n    private int startRow;\n    private int endRow;\n    private long total;\n    private int pages;\n    private List<T> list;\n    private int firstPage;\n    private int prePage;\n    private int nextPage;\n    private int lastPage;\n    private boolean isFirstPage;\n    private boolean isLastPage;\n    private boolean hasPreviousPage;\n    private boolean hasNextPage;\n    private int navigatePages;\n    private int[] navigatepageNums;\n    ........\n   }\n\n```\n参数解释：\npageNum ：当前页码数。\npageSize ： 每一页装的条数。\nsize ： 查询出来的总的页数。\nstartRow ：从哪一条开始查询的。\nendRow ： 哪一条结束。\ntotal ： 总的条数。\npages ： 总的页数。\nlist ： 记录集合。\nfirstPage ： 第一页。\nprePage ： 上一页。\nnextPage ： 下一页。\nlastPage ： 最后一页。\nisFirstPage ： 是否是第一页。\nisLastPage ：是否是最后一页。\nhasPreviousPage ： 是否有前一页。\nhasNextPage ： 是否有后一页。\nnavigatePages ： 导航总的页数。\nnavigatepageNums ： 页数集合。即从第一页到最后一页的页码数。\n\n这个类使用真的很方便，可以直接使用EL表达式来取值。\n\n在jsp中使用EL表达式取值：\n\ncontest.jsp :\n```\n<tbody>\n     <c:forEach items=\"${pageInfo.list}\" var=\"contest\">\n                <tr>\n                    <td>\n                            ${contest.theam}\n                    </td>\n                    <td class=\"modality\">\n                        <c:if test=\"${contest.modality == 0}\">\n                            个人\n                        </c:if>\n                        <c:if test=\"${contest.modality == 1}\">\n                            团队\n                        </c:if>\n                        <c:if test=\"${contest.modality == 2}\">\n                            个人/团队\n                        </c:if>\n                    </td>\n                    <td>${contest.way}</td>\n                    <td>${contest.deadline}</td>\n                    <td>${contest.startTime}</td>\n                    <td>${contest.endTime}</td>\n                    <td>\n                        <input type=\"button\" value=\"操作\" class=\"signUpOne btn btn-xs\" data-contestId=\"${contest.id}\">\n                    </td>\n                </tr>\n            </c:forEach>\n            </tbody>\n```\n\n以上就是最简单的pageHelper使用教程了，如果需要深入了解使用方式，请参考github：https://github.com/pagehelper/Mybatis-PageHelper。','一直以来都用的是自己封装的一个pageBean类来处理分页相关的业务，这个pageBean是从传智播客的视频上面学到的，最近看到别人写的都是用的mybatis的pageHelper,所以自己也心痒痒，将自己的一个竞赛管理系统的分页也换成了pageHelper的方式。话不多说，直接上配置。首先要使用m','2018-11-30 23:56:25','2018-11-30 23:56:28',1,104,9,'262950296d89479688830cfb7d72ed2b',1),(3,'spring aop 小结','<p>说到spring框架，大家都不会陌生，但是说到aop，可能有很多人只是听说过这个名词，但是对什么是aop以及怎么使用aop存在很多疑惑，正好最近在学spring的aop思想，现做如下总结：</p>\n<h2 id=\"h2--aop\"><a name=\"一、什么是aop\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、什么是aop</h2><p>大家可能都听说过oop，即面向对象的编程事项，与传统的面向过程的编程方法不同的是，oop思想讲究将服务（也就是函数方法）和数据（成员变量）封装成对象，由对象来调用方法，从而实现功能。因此，我们需要编写很多的类来实现我们需要的功能。但是，这种方式会导致类过多，而一些通用的方法虽然可以通过重构手法可以提取出来，但是还是有一些不足，那就是不能够自动化。我们希望能够在自动的增强某个函数的功能，不需要在每次调用的地方写任何代码，只需要写一次就OK。在这样的需求下，aop思想诞生了。aop—-自动增强函数方法的思想，面向切面的编程方法。</p>\n<p>下面一张图可以让你更加了解什么是aop思想：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-4b5298e806abb641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>也就是说如果有多个Service，aop就是研究怎么将安全，事务，其他这几个模块加入到service中去。下面我就用在java和spring环境下做实验。</p>\n<h2 id=\"h2--java-spring-aop\"><a name=\"二、java、spring环境下的aop\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、java、spring环境下的aop</h2><p>spring中自己对aop有一套实现，底层用的是jdk的动态代理和cglib代理，但是spring发现Aspectj对aop思想的实现更加方便我们开发，所以，spring运用拿来主义，将Aspectj中的aop实现整合到spring框架中了，所以本篇只讨论Aspectj中的aop实现，工作中一般也只用到Aspectj的aop实现。</p>\n<p>首先我们搭建一下spring的环境：maven   pom.xml如下：</p>\n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;AspectjDemo&lt;/groupId&gt;\n  &lt;artifactId&gt;cn.ljtnono&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;AspectDemo&lt;/name&gt;\n\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n          &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n          &lt;version&gt;1.7.2&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;log4j&lt;/groupId&gt;\n          &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n          &lt;version&gt;1.2.12&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;junit&lt;/groupId&gt;\n          &lt;artifactId&gt;junit&lt;/artifactId&gt;\n          &lt;version&gt;4.12&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n\n      &lt;!-- cglib代理模式  类模式代理 --&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;cglib&lt;/groupId&gt;\n        &lt;artifactId&gt;cglib&lt;/artifactId&gt;\n        &lt;version&gt;3.2.8&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;source&gt;1.8&lt;/source&gt;\n          &lt;target&gt;1.8&lt;/target&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre><p>项目结构图如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-6b89631f0bd6ee9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>这里先创建一个切面t类，这是一个普通的pojo类。（不知道什么是切面？<a href=\"https://www.jianshu.com/p/e2046e43cc3d\">点击这里</a>）</p>\n<pre><code>package cn.ljtnono.aop;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n//@Aspect\n@Component(\"Aspect1\")\npublic class Aspect1 {\n\n    //@Before(\"execution( * *..SomeService*.firstService(..))\")\n    public void myBefore() {\n        System.out.println(\"这是一个前置通知\");\n    }\n}\n</code></pre><p>创建一个方法，一个前置通知。编写要增强的类的接口以及实现类</p>\n<pre><code>package cn.ljtnono.service;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\n\npublic interface SomeService {\n\n\n    void firstService();\n\n    void secondService();\n\n    void thiredService();\n}\n</code></pre><pre><code>package cn.ljtnono.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service(value=\"SomeService\")\npublic class SomeServiceImpl  {\n\n\n    public void firstService() {\n        // TODO Auto-generated method stub\n        System.out.println(\"======执行了firstService方法\");\n    }\n\n\n    public void secondService() {\n        // TODO Auto-generated method stub\n        System.out.println(\"======执行了secondService方法\");\n\n    }\n\n\n    public void thiredService() {\n        // TODO Auto-generated method stub\n\n        System.out.println(\"======执行了thiredService方法\");\n    }\n\n\n\n}\n</code></pre><p>在spring配置文件中配置：</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://www.springframework.org/schema/mvc\n                        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://mybatis.org/schema/mybatis-spring\n                        http://mybatis.org/schema/mybatis-spring.xsd\n                        http://www.springframework.org/schema/cache\n                        http://www.springframework.org/schema/cache/spring-cache-3.1.xsd\n                        http://www.springframework.org/schema/aop\n                        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\"&gt;\n\n    &lt;!-- 开启注解配置 --&gt;\n    &lt;context:component-scan base-package=\"cn.ljtnono\" /&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:pointcut expression=\"execution( * *..SomeService*.firstService(..))\" id=\"myPointCut\"/&gt;\n        &lt;aop:aspect ref=\"Aspect1\"&gt;\n            &lt;aop:before method=\"myBefore\" pointcut-ref=\"myPointCut\"/&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n</code></pre><p>aop:config中的配置：首先要配置一个切入点，然后配置切面的实现。这里应该容易理解。这其中需要aspect类和目标对象被容器识别，也就是必须交给spring管理这两个对象。其中execution表达式详解见我的另一篇博文。</p>\n<p>现在测试：</p>\n<pre><code>package cn.ljtnono.test;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport cn.ljtnono.service.SomeService;\nimport cn.ljtnono.service.SomeServiceImpl;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class Aspect1Test {\n\n\n\n\n    @Test\n    public void testBefore() {\n\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        SomeServiceImpl service = (SomeServiceImpl) ac.getBean(\"SomeService\");\n        service.firstService();\n    }\n}\n</code></pre><p><img src=\"https://upload-images.jianshu.io/upload_images/13105398-47c3a1fe9d8a5782.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>至此，一个简单的aop demo完成了，有不懂的可以查看以下资料：</p>\n<p>AOP execution表达式详解：<a href=\"https://www.jianshu.com/u/0eac251981be\">https://www.jianshu.com/u/0eac251981be</a></p>','说到spring框架，大家都不会陌生，但是说到aop，可能有很多人只是听说过这个名词，但是对什么是aop以及怎么使用aop存在很多疑惑，正好最近在学spring的aop思想，现做如下总结：\n\n##一、什么是aop\n大家可能都听说过oop，即面向对象的编程事项，与传统的面向过程的编程方法不同的是，oop思想讲究将服务（也就是函数方法）和数据（成员变量）封装成对象，由对象来调用方法，从而实现功能。因此，我们需要编写很多的类来实现我们需要的功能。但是，这种方式会导致类过多，而一些通用的方法虽然可以通过重构手法可以提取出来，但是还是有一些不足，那就是不能够自动化。我们希望能够在自动的增强某个函数的功能，不需要在每次调用的地方写任何代码，只需要写一次就OK。在这样的需求下，aop思想诞生了。aop---自动增强函数方法的思想，面向切面的编程方法。\n\n下面一张图可以让你更加了解什么是aop思想：\n![](https://upload-images.jianshu.io/upload_images/13105398-4b5298e806abb641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也就是说如果有多个Service，aop就是研究怎么将安全，事务，其他这几个模块加入到service中去。下面我就用在java和spring环境下做实验。\n\n##二、java、spring环境下的aop\nspring中自己对aop有一套实现，底层用的是jdk的动态代理和cglib代理，但是spring发现Aspectj对aop思想的实现更加方便我们开发，所以，spring运用拿来主义，将Aspectj中的aop实现整合到spring框架中了，所以本篇只讨论Aspectj中的aop实现，工作中一般也只用到Aspectj的aop实现。\n\n首先我们搭建一下spring的环境：maven   pom.xml如下：\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>AspectjDemo</groupId>\n  <artifactId>cn.ljtnono</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>AspectDemo</name>\n  \n    <dependencies>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-aop</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-aspects</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-beans</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-context</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-context-support</artifactId>\n  		<version>5.0.8.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-core</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-expression</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.slf4j</groupId>\n  		<artifactId>slf4j-log4j12</artifactId>\n  		<version>1.7.2</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>log4j</groupId>\n  		<artifactId>log4j</artifactId>\n  		<version>1.2.12</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>junit</groupId>\n  		<artifactId>junit</artifactId>\n  		<version>4.12</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-test</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	\n  	<!-- cglib代理模式  类模式代理 -->\n  	<dependency>\n	    <groupId>cglib</groupId>\n	    <artifactId>cglib</artifactId>\n	    <version>3.2.8</version>\n	</dependency>\n    </dependencies>\n  \n  <build>\n    <plugins>\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n```\n项目结构图如下：\n![](https://upload-images.jianshu.io/upload_images/13105398-6b89631f0bd6ee9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里先创建一个切面t类，这是一个普通的pojo类。（不知道什么是切面？[点击这里](https://www.jianshu.com/p/e2046e43cc3d)）\n```\npackage cn.ljtnono.aop;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n//@Aspect\n@Component(\"Aspect1\")\npublic class Aspect1 {\n	\n	//@Before(\"execution( * *..SomeService*.firstService(..))\")\n	public void myBefore() {\n		System.out.println(\"这是一个前置通知\");\n	}\n}\n\n```\n创建一个方法，一个前置通知。编写要增强的类的接口以及实现类\n```\npackage cn.ljtnono.service;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\n \npublic interface SomeService {\n	\n	\n	void firstService();\n	\n	void secondService();\n	\n	void thiredService();\n}\n\n```\n```\npackage cn.ljtnono.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service(value=\"SomeService\")\npublic class SomeServiceImpl  {\n\n	\n	public void firstService() {\n		// TODO Auto-generated method stub\n		System.out.println(\"======执行了firstService方法\");\n	}\n\n	\n	public void secondService() {\n		// TODO Auto-generated method stub\n		System.out.println(\"======执行了secondService方法\");\n\n	}\n\n	\n	public void thiredService() {\n		// TODO Auto-generated method stub\n\n		System.out.println(\"======执行了thiredService方法\");\n	}\n	\n	\n\n}\n```\n在spring配置文件中配置：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	   xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"\n	   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	   xmlns:p=\"http://www.springframework.org/schema/p\"\n	   xmlns:context=\"http://www.springframework.org/schema/context\"\n	   xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	   xmlns:aop=\"http://www.springframework.org/schema/aop\"\n	   xmlns:tx=\"http://www.springframework.org/schema/tx\"\n	   xmlns:cache=\"http://www.springframework.org/schema/cache\"\n	   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			            http://www.springframework.org/schema/beans/spring-beans.xsd\n			            http://www.springframework.org/schema/context\n			            http://www.springframework.org/schema/context/spring-context.xsd\n			            http://www.springframework.org/schema/mvc\n			            http://www.springframework.org/schema/mvc/spring-mvc.xsd\n			            http://www.springframework.org/schema/tx\n			            http://www.springframework.org/schema/tx/spring-tx.xsd\n			            http://mybatis.org/schema/mybatis-spring\n			            http://mybatis.org/schema/mybatis-spring.xsd\n						http://www.springframework.org/schema/cache\n						http://www.springframework.org/schema/cache/spring-cache-3.1.xsd\n						http://www.springframework.org/schema/aop\n        				http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\">\n	\n	<!-- 开启注解配置 -->\n	<context:component-scan base-package=\"cn.ljtnono\" />\n	\n	<aop:config>\n		<aop:pointcut expression=\"execution( * *..SomeService*.firstService(..))\" id=\"myPointCut\"/>\n		<aop:aspect ref=\"Aspect1\">\n			<aop:before method=\"myBefore\" pointcut-ref=\"myPointCut\"/>\n		</aop:aspect>\n	</aop:config>\n	\n</beans>\n```\naop:config中的配置：首先要配置一个切入点，然后配置切面的实现。这里应该容易理解。这其中需要aspect类和目标对象被容器识别，也就是必须交给spring管理这两个对象。其中execution表达式详解见我的另一篇博文。\n\n现在测试：\n```\npackage cn.ljtnono.test;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport cn.ljtnono.service.SomeService;\nimport cn.ljtnono.service.SomeServiceImpl;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class Aspect1Test {\n	\n	\n	\n	\n	@Test\n	public void testBefore() {\n		\n		ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n		SomeServiceImpl service = (SomeServiceImpl) ac.getBean(\"SomeService\");\n		service.firstService();\n	}\n}\n\n```\n![](https://upload-images.jianshu.io/upload_images/13105398-47c3a1fe9d8a5782.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，一个简单的aop demo完成了，有不懂的可以查看以下资料：\n\n\nAOP execution表达式详解：https://www.jianshu.com/u/0eac251981be\n\n\n\n','说到spring框架，大家都不会陌生，但是说到aop，可能有很多人只是听说过这个名词，但是对什么是aop以及怎么使用aop存在很多疑惑，正好最近在学spring的aop思想，现做如下总结：##一、什么是aop大家可能都听说过oop，即面向对象的编程事项，与传统的面向过程的编程方法不同的是，oop思想','2018-11-30 23:57:52','2018-11-30 23:57:54',1,136,8,'e35357207ed9496d9a63bc4bdaf8a1f6',1),(4,'Aspectj aop 名词解释','<p>这里对aop一些术语进行解释：<br>   1.通知（Advice）<br>      就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。<br>  2.连接点（JoinPoint）<br>   这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。<br>  3.切入点（Pointcut）<br>   上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。<br>  4.切面（Aspect）<br>   切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。<br>  5.引入（introduction）<br>   允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗<br>  6.目标（target）<br>   引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。<br>  7.代理(proxy)<br>   怎么实现整套aop机制的，都是通过代理，这个一会给细说。<br>   8.织入(weaving)<br>   把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。<br>关键就是：切点定义了哪些连接点会得到通知\n<hr>\n<p>本文来自 yuanye348623610 的CSDN 博客 ，全文地址请点击：<a href=\"https://blog.csdn.net/yuanye348623610/article/details/8823429?utm_source=copy\">https://blog.csdn.net/yuanye348623610/article/details/8823429?utm_source=copy</a> </p>','这里对aop一些术语进行解释：\n   1.通知（Advice）   \n      就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。\n  2.连接点（JoinPoint）\n   这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。\n  3.切入点（Pointcut）\n   上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。\n  4.切面（Aspect）\n   切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。\n  5.引入（introduction）\n   允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗\n  6.目标（target）\n   引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。\n  7.代理(proxy)\n   怎么实现整套aop机制的，都是通过代理，这个一会给细说。\n   8.织入(weaving)\n   把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。\n关键就是：切点定义了哪些连接点会得到通知\n\n---------------------\n\n本文来自 yuanye348623610 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/yuanye348623610/article/details/8823429?utm_source=copy ','这里对aop一些术语进行解释：   1.通知（Advice）         就是你想要的功能，也就是上面说的安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。  2.连接点（JoinPoint）   这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后','2018-11-30 23:59:38','2018-11-30 23:59:41',1,50,8,'a879f54812294c07b961dc9257451ffb',1),(5,'Aspectj execution表达式','<p>Aspectj切入点语法定义</p>\n<p>在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut”切入点”</p>\n<p>例如定义切入点表达式  execution (<em> com.sample.service.impl..</em>.*(..))</p>\n<p>execution()是最常用的切点函数，其语法如下所示：</p>\n<p> 整个表达式可以分为五个部分：</p>\n<p> 1、execution(): 表达式主体。</p>\n<p> 2、第一个<em>号：表示返回类型，</em>号表示所有的类型。</p>\n<p> 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。</p>\n<p> 4、第二个<em>号：表示类名，</em>号表示所有的类。</p>\n<p> 5、<em>(..):最后这个星号表示方法名，</em>号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。</p>\n<p>AspectJ的Execution表达式</p>\n<p>execution()</p>\n<p>execution()是最常用的切点函数，其语法如下所示：</p>\n<p>execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)<br>  除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。与其直接讲解该方法的使用规则，还不如通过一个个具体的例子进行理解。下面，我们给出各种使用execution()函数实例。\n<p>1)通过方法签名定义切点</p>\n<p> execution(public <em> </em>(..))l</p>\n<p>匹配所有目标类的public方法，但不匹配SmartSeller和protected void showGoods()方法。第一个<em>代表返回类型，第二个</em>代表方法名，而..代表任意入参的方法；</p>\n<p> execution(<em> </em>To(..))l</p>\n<p>匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个<em>代表返回类型，而</em>To代表任意以To为后缀的方法；</p>\n<p>2)通过类定义切点</p>\n<p> execution(<em> com.baobaotao.Waiter.</em>(..))l</p>\n<p>匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个<em>代表返回任意类型，com.baobaotao.Waiter.</em>代表Waiter接口中的所有方法；</p>\n<p> execution(<em> com.baobaotao.Waiter+.</em>(..))l</p>\n<p>匹 配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这 两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter 接口中定义的方法。</p>\n<p>3)通过类包定义切点</p>\n<p>在类名模式串中，“.<em>”表示包下的所有类，而“..</em>”表示包、子孙包下的所有类。</p>\n<p> execution(<em> com.baobaotao.</em>(..))l</p>\n<p>匹配com.baobaotao包下所有类的所有方法；</p>\n<p> execution(<em> com.baobaotao..</em>(..))l</p>\n<p>匹 配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及 com.baobaotao.dao.user包下的所有类的所有方法都匹配。“..”出现在类名中时，后面必须跟“*”，表示包、子孙包下的所有类；</p>\n<p> execution(<em> com..</em>.<em>Dao.find</em>(..))l</p>\n<p>匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。</p>\n<p>4)通过方法入参定义切点</p>\n<p>切点表达式中方法入参部分比较复杂，可以使用“<em>”和“ ..”通配符，其中“</em>”表示任意类型的参数，而“..”表示任意类型参数且参数个数不限。</p>\n<p> execution(* joke(String,int)))l</p>\n<p>匹 配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配 NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是java.lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)；</p>\n<p> execution(<em> joke(String,</em>)))l</p>\n<p>匹 配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(String s1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,double d2,String s3)则不匹配；</p>\n<p> execution(* joke(String,..)))l</p>\n<p>匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(String s1)、joke(String s1,String s2)和joke(String s1,double d2,String s3)都匹配。</p>\n<p> execution(* joke(Object+)))l</p>\n<p>匹 配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(String s1)和joke(Client c)。如果我们定义的切点是execution(* joke(Object))，则只匹配joke(Object object)而不匹配joke(String cc)或joke(Client c)。</p>\n<p>args()和<a href=\"https://github.com/args\" title=\"@args\" class=\"at-link\">@args</a>()</p>\n<p>args()函数的入参是类名，<a href=\"https://github.com/args\" title=\"@args\" class=\"at-link\">@args</a>()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。</p>\n<p>1)args()</p>\n<p>该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：</p>\n<p>args(com.baobaotao.Waiter)</p>\n<p>表 示运行时入参是Waiter类型的方法，它和execution(<em> </em>(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如 args(com.baobaotao.Waiter)既匹配于addWaiter(Waiter waiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(<em> </em>(com.baobaotao.Waiter))只匹配addWaiter(Waiter<br> waiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(<em> </em>(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。</p>\n<p>2)<a href=\"https://github.com/args\" title=\"@args\" class=\"at-link\">@args</a>()</p>\n<p>该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。这个切点函数的匹配规则不太容易理解，我们通过以下示意图对此进行详细讲解：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13105398-f02203f4cd9dae39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\">\n<p>转自：<a href=\"https://blog.csdn.net/lang_niu/article/details/51559994\">https://blog.csdn.net/lang_niu/article/details/51559994</a></p>','Aspectj切入点语法定义\n\n\n\n\n在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut\"切入点\"\n\n例如定义切入点表达式  execution (* com.sample.service.impl..*.*(..))\n\nexecution()是最常用的切点函数，其语法如下所示：\n\n 整个表达式可以分为五个部分：\n\n 1、execution(): 表达式主体。\n\n 2、第一个*号：表示返回类型，*号表示所有的类型。\n\n 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。\n\n 4、第二个*号：表示类名，*号表示所有的类。\n\n 5、*(..):最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。\n\n \n\n\n\nAspectJ的Execution表达式\n\nexecution()\n\nexecution()是最常用的切点函数，其语法如下所示：\n\n \n\nexecution(<修饰符模式>? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?)\n  除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。与其直接讲解该方法的使用规则，还不如通过一个个具体的例子进行理解。下面，我们给出各种使用execution()函数实例。\n\n \n\n1)通过方法签名定义切点\n\n execution(public * *(..))l\n\n匹配所有目标类的public方法，但不匹配SmartSeller和protected void showGoods()方法。第一个*代表返回类型，第二个*代表方法名，而..代表任意入参的方法；\n\n \n\n execution(* *To(..))l\n\n匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个*代表返回类型，而*To代表任意以To为后缀的方法；\n\n \n\n2)通过类定义切点\n\n execution(* com.baobaotao.Waiter.*(..))l\n\n匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个*代表返回任意类型，com.baobaotao.Waiter.*代表Waiter接口中的所有方法；\n\n \n\n execution(* com.baobaotao.Waiter+.*(..))l\n\n匹 配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这 两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter 接口中定义的方法。\n\n \n\n3)通过类包定义切点\n\n在类名模式串中，“.*”表示包下的所有类，而“..*”表示包、子孙包下的所有类。\n\n execution(* com.baobaotao.*(..))l\n\n匹配com.baobaotao包下所有类的所有方法；\n\n \n\n execution(* com.baobaotao..*(..))l\n\n匹 配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及 com.baobaotao.dao.user包下的所有类的所有方法都匹配。“..”出现在类名中时，后面必须跟“*”，表示包、子孙包下的所有类；\n\n \n\n execution(* com..*.*Dao.find*(..))l\n\n匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。\n\n \n\n4)通过方法入参定义切点\n\n切点表达式中方法入参部分比较复杂，可以使用“*”和“ ..”通配符，其中“*”表示任意类型的参数，而“..”表示任意类型参数且参数个数不限。\n\n \n\n execution(* joke(String,int)))l\n\n匹 配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配 NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是java.lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)；\n\n \n\n execution(* joke(String,*)))l\n\n匹 配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(String s1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,double d2,String s3)则不匹配；\n\n \n\n execution(* joke(String,..)))l\n\n匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(String s1)、joke(String s1,String s2)和joke(String s1,double d2,String s3)都匹配。\n\n \n\n execution(* joke(Object+)))l\n\n匹 配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(String s1)和joke(Client c)。如果我们定义的切点是execution(* joke(Object))，则只匹配joke(Object object)而不匹配joke(String cc)或joke(Client c)。\n\n \n\nargs()和@args()\n\nargs()函数的入参是类名，@args()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。\n\n \n\n1)args()\n\n该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：\n\nargs(com.baobaotao.Waiter)\n\n表 示运行时入参是Waiter类型的方法，它和execution(* *(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如 args(com.baobaotao.Waiter)既匹配于addWaiter(Waiter waiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(* *(com.baobaotao.Waiter))只匹配addWaiter(Waiter\n waiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(* *(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。\n\n \n\n2)@args()\n\n该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。这个切点函数的匹配规则不太容易理解，我们通过以下示意图对此进行详细讲解：\n\n\n![image.png](https://upload-images.jianshu.io/upload_images/13105398-f02203f4cd9dae39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n转自：https://blog.csdn.net/lang_niu/article/details/51559994','Aspectj切入点语法定义在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut\"切入点\"例如定义切入点表达式  execution(*com.sample.service.impl..*.*(..))execution()是最常用的切点函数，其语','2018-12-01 00:03:18','2018-12-01 00:03:20',0,33,8,'3f0da92ec0d64b5b8186b6a7621e5d6c',1),(6,'java IO流-基本概念','<p>一个好的编程语言应该具有良好的io系统。java能够火这么多年其io系统功不可没。</p>\n<p>流的概念：流式一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>\n<p>流的分类：<br>按数据方向分：输入流和输出流<br>输入流：InputStream/Reader<br>输出流：OutputStream/Writer<br>按数据类型分：字节流和字符流<br>字节流：InputStream/OutputStream<br>字符流：Reader/Writer\n<p>下图是常用的IO流：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-e349b4e03fef2cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>关于字节流和字符流的区别<br>1、字节流和字符流的时候，读到一个字节就返回一个字节。<br>字符流使用了字节流读到一个或多个字节（中文对应的字节是两个，UTF-8码表中是三个）时，先去查指定的编码表，将查到的字符返回。<br>2、字符流可以初六所有数据，如图片，MP3等，字符流只能处理文本。<br>3、能使用字符流就使用字符流，不能就使用字节流。','一个好的编程语言应该具有良好的io系统。java能够火这么多年其io系统功不可没。\n\n流的概念：流式一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。\n\n流的分类：\n按数据方向分：输入流和输出流\n输入流：InputStream/Reader\n输出流：OutputStream/Writer\n按数据类型分：字节流和字符流\n字节流：InputStream/OutputStream\n字符流：Reader/Writer\n\n下图是常用的IO流：\n![](https://upload-images.jianshu.io/upload_images/13105398-e349b4e03fef2cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n关于字节流和字符流的区别\n1、字节流和字符流的时候，读到一个字节就返回一个字节。\n字符流使用了字节流读到一个或多个字节（中文对应的字节是两个，UTF-8码表中是三个）时，先去查指定的编码表，将查到的字符返回。\n2、字符流可以初六所有数据，如图片，MP3等，字符流只能处理文本。\n3、能使用字符流就使用字符流，不能就使用字节流。','一个好的编程语言应该具有良好的io系统。java能够火这么多年其io系统功不可没。流的概念：流式一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其','2018-12-01 00:05:39','2018-12-01 00:05:41',0,32,1,'2835dec0c12744e5a67c748ad4254a9d',1),(7,'java IO流-常用流','<p>根据java类之间的关系，整理出java常用IO流之间的UML类图<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-14ee140748acb8c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>初学UML，如果有错的话请谅解，这里面只写了关键的方法。</p>\n<p><code>字节输入流：InputStream类为所有自己输入流的父类</code><br><code>主要方法有三个：</code></p>\n<p><code>int read()</code><br><code>从流里面读出一个字节。不推荐使用</code><br><code>int read(byte[] b)</code><br><code>将数据读入到字节数组中，并返回所读的字节数</code><br><code>inte read(byte[] b,int off,int len)</code><br><code>off 从哪里开始读</code><br><code>len读取多少</code><br><code>将输入流中最多len个数据字节读入字节数组</code></p>\n<p><code>其他方法：</code><br><code>void close()</code><br><code>关闭流资源</code><br><code>int available()</code><br><code>返回不受阻塞地从此输入流读取的字节数</code><br><code>long skip(long n)</code><br><code>跳过和放弃此输入流中的n个数据字节，该方法有可能失效</code><br><code>boolean markSupported()</code><br><code>测试此输入流是否支持mark和reset方法</code><br><code>void mark(int n)</code><br><code>在此输入流中标记当前的位置</code><br><code>void reset()</code><br><code>将此流重新定位到对此输入流最后调用mark方法时的位置。</code></p>\n<p><code>字节输出流：OutputStream是所有字节输出流的父类。</code><br><code>三个基本的write()方法：</code><br><code>void write(int n)</code><br><code>将指定的字节写入此输出流。</code><br><code>void write(byte[] b)</code><br><code>将b.length个字节从指定的字节数组写入此输出流</code><br><code>void write(byte[] b,int off,int len)</code><br><code>将指定字节数组中从偏移量off开始的len个字节写入此输出流</code></p>\n<p><code>其他方法：</code><br><code>void close()</code><br><code>关闭此输出流并释放与此流有关的所有系统资源</code><br><code>void flush()</code><br><code>刷新此输出流并强制写出所有缓冲的输出字节</code></p>\n<p>文件输入输出流：FileInputStream和FileOutputStream,要构造一个FileInputStream，所关联的文件必须存在并且可读。</p>\n<pre><code>FileInputStream fis = new FileInputStream(\"demo.java\");\n</code></pre><p>要构造一个FileOutputStream,而输出文件已经存在，则它将被覆盖</p>\n<pre><code>FileOutputStream fos = new FileInputStream(\"results.dat\");\n</code></pre><p>想要以追加的方式写，则需要一个额外的参数，如：</p>\n<pre><code>FileOutputStream outfile = new FileOutputStream(\"results.dat\",true);\n</code></pre><p>字符流：Reader和Writer所有字符流的父类型。<br>java技术使用Unicode来表示字符串和字符，而且提供16位版本的流，以便用类似的方法处理字符。如果构造了一个连接到流的Reader和Writer，转换规则会在使用缺省平台所定义的字节编码和Unicode之间切换。<br>桥梁流：InputStreamReader和OutputStreamWriter(字节流转换成字符流的转换器)<br>这两个类不是用于直接输入输出的，他是将字节流转换成字符流的桥转换器，并可以指定编解码方式。<br>逐行读写流：BufferedReader/BufferedWriter<br>以上两个都是过滤流，需要用其他的节点流来作为参数的构造对象。<br>BufferedReader的方法：readLine():String，当他的返回值是null时，就表示读取完毕了。要注意，在写入时要注意写换行符，否则会出现阻塞。<br>BufferedWriter的方法：newLine(),这个方法会写出一个换行符。<br>管道流:线程交互的时候使用<br>PipedInputStream/PipedOutputStream<br>传送输出流可以连接到传送输入流，以创建通信管道。传送输出流是管道的发送端。通常，数据由某个线程写入PipedOutputStream对象，并由其他线程从连接的PipedInputStream读取。','根据java类之间的关系，整理出java常用IO流之间的UML类图\n![](https://upload-images.jianshu.io/upload_images/13105398-14ee140748acb8c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n初学UML，如果有错的话请谅解，这里面只写了关键的方法。\n\n`字节输入流：InputStream类为所有自己输入流的父类`\n`主要方法有三个：`\n\n`int read()`\n`从流里面读出一个字节。不推荐使用`\n`int read(byte[] b)`\n`将数据读入到字节数组中，并返回所读的字节数`\n`inte read(byte[] b,int off,int len)`\n`off 从哪里开始读`\n`len读取多少`\n`将输入流中最多len个数据字节读入字节数组`\n\n`其他方法：`\n`void close()`\n`关闭流资源`\n`int available()`\n`返回不受阻塞地从此输入流读取的字节数`\n`long skip(long n)`\n`跳过和放弃此输入流中的n个数据字节，该方法有可能失效`\n`boolean markSupported()`\n`测试此输入流是否支持mark和reset方法`\n`void mark(int n)`\n`在此输入流中标记当前的位置`\n`void reset()`\n`将此流重新定位到对此输入流最后调用mark方法时的位置。`\n\n`字节输出流：OutputStream是所有字节输出流的父类。`\n`三个基本的write()方法：`\n`void write(int n)`\n`将指定的字节写入此输出流。`\n`void write(byte[] b)`\n`将b.length个字节从指定的字节数组写入此输出流`\n`void write(byte[] b,int off,int len)`\n`将指定字节数组中从偏移量off开始的len个字节写入此输出流`\n\n`其他方法：`\n`void close()`\n`关闭此输出流并释放与此流有关的所有系统资源`\n`void flush()`\n`刷新此输出流并强制写出所有缓冲的输出字节`\n\n文件输入输出流：FileInputStream和FileOutputStream,要构造一个FileInputStream，所关联的文件必须存在并且可读。\n```\nFileInputStream fis = new FileInputStream(\"demo.java\");\n```\n要构造一个FileOutputStream,而输出文件已经存在，则它将被覆盖\n```\nFileOutputStream fos = new FileInputStream(\"results.dat\");\n```\n想要以追加的方式写，则需要一个额外的参数，如：\n```\nFileOutputStream outfile = new FileOutputStream(\"results.dat\",true);\n```\n\n字符流：Reader和Writer所有字符流的父类型。\njava技术使用Unicode来表示字符串和字符，而且提供16位版本的流，以便用类似的方法处理字符。如果构造了一个连接到流的Reader和Writer，转换规则会在使用缺省平台所定义的字节编码和Unicode之间切换。\n桥梁流：InputStreamReader和OutputStreamWriter(字节流转换成字符流的转换器)\n这两个类不是用于直接输入输出的，他是将字节流转换成字符流的桥转换器，并可以指定编解码方式。\n逐行读写流：BufferedReader/BufferedWriter\n以上两个都是过滤流，需要用其他的节点流来作为参数的构造对象。\nBufferedReader的方法：readLine():String，当他的返回值是null时，就表示读取完毕了。要注意，在写入时要注意写换行符，否则会出现阻塞。\nBufferedWriter的方法：newLine(),这个方法会写出一个换行符。\n管道流:线程交互的时候使用\nPipedInputStream/PipedOutputStream\n传送输出流可以连接到传送输入流，以创建通信管道。传送输出流是管道的发送端。通常，数据由某个线程写入PipedOutputStream对象，并由其他线程从连接的PipedInputStream读取。\n','根据java类之间的关系，整理出java常用IO流之间的UML类图![](https://upload-images.jianshu.io/upload_images/13105398-14ee140748acb8c8.png?imageMogr2/auto-orient/strip%7Cimage','2018-12-01 00:06:39','2018-12-01 00:06:40',2,76,1,'c8dd963fd2b74bacad22bec8cace59aa',1),(8,'java IO-File类的基本使用','<p>【创建一个新的文件】</p>\n<pre><code>package cn.ljtnono.io;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * File 类的基本使用方式\n * @author Administrator\n *\n */\npublic class UseFile {\n\n\n\n    /**\n     * 创建一个新的File\n     */\n    public static void createNewFile(String filePath) throws IllegalArgumentException{\n        if (filePath == null || filePath.isEmpty()) {\n            throw new IllegalArgumentException(\"请指定正确的文件路径！\");\n        }\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"当前File已经存在\");\n        } else {\n            try {\n                file.createNewFile();\n                System.out.println(\"文件创建成功！\");\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                System.out.println(\"create File failed!\");\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        createNewFile(\"Demo.txt\");\n        System.out.println(File.separator);\n        System.out.println(File.pathSeparator);\n    }\n\n    //怎么判断一个文件的路径是合法的\n}\n</code></pre><p>运行结果：在eclipse项目的根目录创建了一个Demo.txt的文件。</p>\n<p>【删除一个文件】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"Demo.txt\";\n        File file = new File(fileName);\n        if (file.exists()) {\n            file.delete();\n        } else {\n            System.out.println(\"文件不存在！\");\n        }\n    }\n</code></pre><p>运行结果：删除了创建的Demo.txt文件</p>\n<p>【创建一个文件夹】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"Demo\";\n        File file = new File(fileName);\n        file.mkdir();\n    }\n</code></pre><p>运行结果：在eclipse项目的根目录下创建一个名为Demo的文件夹</p>\n<p>【列出指定目录的全部文件（包括隐藏文件）】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"src\";\n        File file = new File(fileName);\n        String[] list = file.list();\n        for (String f : list) {\n            System.out.println(f);\n        }\n    }\n</code></pre><p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-b97d6a0ece71426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>由于没有做是文件还是文件夹的判断，所以显示的是main和test文件夹。\n<p>【判断文件是否是目录】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"src\";\n        File file = new File(fileName);\n        if (file.isDirectory()) {\n            System.out.println(\"文件是目录！\");\n        } else {\n            System.out.println(\"文件不是目录！\");\n        }\n    }\n</code></pre><p>运行结果：文件是目录</p>\n<p>【搜索指定目录的全部内容】</p>\n<pre><code>//搜索指定目录的全部内容\n    public static void main(String[] args) {\n        String fileName = \"src\";\n        File file = new File(fileName);\n        print(file);\n    }\n\n    public static void print(File f) {\n        if (f != null) {\n            if (f.isDirectory()) {\n                File[] fileArray = f.listFiles();\n                if (fileArray != null) {\n                    for (int i = 0; i &lt; fileArray.length;i++) {\n                        print(fileArray[i]);\n                    }\n                }\n            }\n            else {\n                System.out.println(f);\n            }\n        }\n    }\n</code></pre><p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-1de2559d7fe7c991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>【使用RandomAccessFile写入文件】</p>\n<pre><code>    public static void main(String[] args) throws IOException {\n        String fileName = \"hello.txt\";\n        File f = new File(fileName);\n        RandomAccessFile demo = new RandomAccessFile(f,\"rw\");\n        demo.writeBytes(\"asdsad\");\n        demo.writeInt(12);\n        demo.writeBoolean(true);\n        demo.writeChar(\'A\');\n        demo.writeFloat(1.21f);\n        demo.writeDouble(12.123);\n        demo.close();\n    }\n</code></pre><p>运行结果：在eclipse根目录下的hello.txt文件中写入了各种数据，但是打开看的话发现是乱码。</p>\n<p>【文件的复制】</p>\n<pre><code>public static void main(String[] args) throws IOException {\n        //1.创建两个File\n        String sourcePath = \"bmp.bmp\";\n        String targetPath = \"bb.bmp\";\n        File source = new File(sourcePath);\n        File target = new File(targetPath);\n        if (!source.exists()) {\n            System.out.println(\"原文件不存在！\");\n        } else {\n            // 2. 创建输入流\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));\n            byte[] buff = new byte[bis.available()];\n            //3.创建输出流\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(target));\n\n            while (bis.read(buff, 0, buff.length) != -1) {\n                bos.write(buff, 0, buff.length);\n            }\n            bis.close();\n            bos.close();\n        }\n    }\n</code></pre><p>运行结果：复制了bmp.bmp文件</p>','【创建一个新的文件】\n```\npackage cn.ljtnono.io;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * File 类的基本使用方式\n * @author Administrator\n *\n */\npublic class UseFile {\n\n	\n	\n	/**\n	 * 创建一个新的File\n	 */\n	public static void createNewFile(String filePath) throws IllegalArgumentException{\n		if (filePath == null || filePath.isEmpty()) {\n			throw new IllegalArgumentException(\"请指定正确的文件路径！\");\n		}\n		File file = new File(filePath);\n		if (file.exists()) {\n			System.out.println(\"当前File已经存在\");\n		} else {\n			try {\n				file.createNewFile();\n				System.out.println(\"文件创建成功！\");\n			} catch (IOException e) {\n				// TODO Auto-generated catch block\n				System.out.println(\"create File failed!\");\n				e.printStackTrace();\n			}\n		}\n	}\n	\n	public static void main(String[] args) {\n		createNewFile(\"Demo.txt\");\n		System.out.println(File.separator);\n		System.out.println(File.pathSeparator);\n	}\n	\n	//怎么判断一个文件的路径是合法的\n}\n```\n运行结果：在eclipse项目的根目录创建了一个Demo.txt的文件。\n\n【删除一个文件】\n```\npublic static void main(String[] args) {\n		String fileName = \"Demo.txt\";\n		File file = new File(fileName);\n		if (file.exists()) {\n			file.delete();\n		} else {\n			System.out.println(\"文件不存在！\");\n		}\n	}\n```\n运行结果：删除了创建的Demo.txt文件\n\n【创建一个文件夹】\n```\npublic static void main(String[] args) {\n		String fileName = \"Demo\";\n		File file = new File(fileName);\n		file.mkdir();\n	}\n```\n运行结果：在eclipse项目的根目录下创建一个名为Demo的文件夹\n\n【列出指定目录的全部文件（包括隐藏文件）】\n```\npublic static void main(String[] args) {\n		String fileName = \"src\";\n		File file = new File(fileName);\n		String[] list = file.list();\n		for (String f : list) {\n			System.out.println(f);\n		}\n	}\n```\n运行结果：\n![](https://upload-images.jianshu.io/upload_images/13105398-b97d6a0ece71426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n由于没有做是文件还是文件夹的判断，所以显示的是main和test文件夹。\n\n【判断文件是否是目录】\n```\npublic static void main(String[] args) {\n		String fileName = \"src\";\n		File file = new File(fileName);\n		if (file.isDirectory()) {\n			System.out.println(\"文件是目录！\");\n		} else {\n			System.out.println(\"文件不是目录！\");\n		}\n	}\n```\n运行结果：文件是目录\n\n【搜索指定目录的全部内容】\n```\n//搜索指定目录的全部内容\n	public static void main(String[] args) {\n		String fileName = \"src\";\n		File file = new File(fileName);\n		print(file);\n	}\n	\n	public static void print(File f) {\n		if (f != null) {\n			if (f.isDirectory()) {\n				File[] fileArray = f.listFiles();\n				if (fileArray != null) {\n					for (int i = 0; i < fileArray.length;i++) {\n						print(fileArray[i]);\n					}\n				}\n			}\n			else {\n				System.out.println(f);\n			}\n		}\n	}\n```\n运行结果：\n![](https://upload-images.jianshu.io/upload_images/13105398-1de2559d7fe7c991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n【使用RandomAccessFile写入文件】\n```\n	public static void main(String[] args) throws IOException {\n		String fileName = \"hello.txt\";\n		File f = new File(fileName);\n		RandomAccessFile demo = new RandomAccessFile(f,\"rw\");\n		demo.writeBytes(\"asdsad\");\n		demo.writeInt(12);\n		demo.writeBoolean(true);\n		demo.writeChar(\'A\');\n		demo.writeFloat(1.21f);\n		demo.writeDouble(12.123);\n		demo.close();\n	}\n```\n运行结果：在eclipse根目录下的hello.txt文件中写入了各种数据，但是打开看的话发现是乱码。\n\n【文件的复制】\n```\npublic static void main(String[] args) throws IOException {\n		//1.创建两个File\n		String sourcePath = \"bmp.bmp\";\n		String targetPath = \"bb.bmp\";\n		File source = new File(sourcePath);\n		File target = new File(targetPath);\n		if (!source.exists()) {\n			System.out.println(\"原文件不存在！\");\n		} else {\n			// 2. 创建输入流\n			BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));\n			byte[] buff = new byte[bis.available()];\n			//3.创建输出流\n			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(target));\n			\n			while (bis.read(buff, 0, buff.length) != -1) {\n				bos.write(buff, 0, buff.length);\n			}\n			bis.close();\n			bos.close();\n		}\n	}\n```\n运行结果：复制了bmp.bmp文件\n','【创建一个新的文件】packagecn.ljtnono.io;importjava.io.File;importjava.io.IOException;/***File类的基本使用方式*@authorAdministrator**/publicclassUseFile{/***创建一个新的File*','2018-12-01 00:06:39','2018-12-01 00:06:40',1,31,1,'7cb943cdf99b4d4ab9705def3d123c4a',1),(9,'java IO流小结','<p>1、字节与字符的区别：一个字节占8个bit，范围是-128—127，一个字符占一个字节。汉字占两个字节。英文字符占一个字节。<br>2、字节输入流的抽象基类：InputStream常用的方法是read，这个方法重载了三个函数，分别对应一个一个字节的读取，字节数组的读取，控制长度字节数组的读取方式。其中read()无参方法是抽象的，即读取一个字节。<br>3、字节输出流的抽象基类：OutputStream常用的方法是write，这个方法也重载了三个函数，分别对应的是一个一个字节的写入，字节数组的写入，控制长度字节数组的写入方式。其中write(int b)方法是抽象的，即写一个字节。 这里是b的低8位被写入。 b的24个高位被忽略。','1、字节与字符的区别：一个字节占8个bit，范围是-128--127，一个字符占一个字节。汉字占两个字节。英文字符占一个字节。\n2、字节输入流的抽象基类：InputStream常用的方法是read，这个方法重载了三个函数，分别对应一个一个字节的读取，字节数组的读取，控制长度字节数组的读取方式。其中read()无参方法是抽象的，即读取一个字节。\n3、字节输出流的抽象基类：OutputStream常用的方法是write，这个方法也重载了三个函数，分别对应的是一个一个字节的写入，字节数组的写入，控制长度字节数组的写入方式。其中write(int b)方法是抽象的，即写一个字节。 这里是b的低8位被写入。 b的24个高位被忽略。\n','1、字节与字符的区别：一个字节占8个bit，范围是-128—127，一个字符占一个字节。汉字占两个字节。英文字符占一个字节。2、字节输入流的抽象基类：InputStream常用的方法是read，这个方法重载了三个函数，分别对应一个一个字节的读取，字节数组的读取，控制长度字节数组的读取方式。其中rea','2018-12-01 00:06:39','2018-12-01 00:06:40',0,33,1,'3730dde8166449e88d4987f2023db622',1),(10,'Effictive Java','<h2 id=\"h2--\"><a name=\"第二章 创建和销毁对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第二章 创建和销毁对象</h2><p><img src=\"images/blog/java.jpg\" alt=\"\"></p>\n<p><strong>第2条：遇到多个构造器参数时要考虑用构建器</strong></p>\n<p>如果一个类有很多参数，例如考虑一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等，这样的类该怎么去定义呢？</p>\n<p><strong>常见的定义方式</strong></p>\n<pre><code class=\"lang-java\">public class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n\n    public NutritionFacts(param1,param2....) {\n\n    }\n\n}\n</code></pre>\n<p>这种方式通过构造器的方式直接将字段的实际值传入，然后根据这些值创建一个对象，这样做通常需要定义多个重载的构造器，然而，一旦参数非常多的情况下（多余5个）那么使用这个构造器会很繁琐，程序员一般不会记得这么多的构造函数。所以，为了减少繁琐的构造函数，可以采用JavaBean的方式进行，一般情况下就是采用的JavaBean的方式。</p>\n<p><strong>使用JavaBean的方式进行定义</strong></p>\n<pre><code class=\"lang-java\">public class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n   //各种set get 函数\n\n}\n</code></pre>\n<p>使用JavaBean的模式时候将每个字段的set函数单独分离出来，然后程序员调用的时候大概会如下面这样</p>\n<pre><code class=\"lang-java\">NutritionFacts ntf = new NutritionFacts();\nntf.setXXX(val);\nntf.setXXX(val);\nntf.setXXX(val);\n</code></pre>\n<p>可以看到，这样做解决了构造函数参数过长的问题，但是却存在了一个新的问题，那就是每次setXXX的时候导致此对象的状态不一致，如果是在多线程的条件下可能会出现严重的问题，（不知所云的，但是书上这么说的，不知道为什么？）</p>\n<p>为了解决这个问题，推荐使用建造者模式。</p>\n<p><strong>使用建造者模式</strong></p>\n<pre><code class=\"lang-java\">public class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n\n    public static class Builder {\n        //Required paramters\n        private final int servingSize;\n        private final int servings;\n        //Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int carbohydrate = 0;\n        private int sodium = 0;\n\n        public Builder calories(int val) {\n            calories = val; \n            return this;\n        }\n        public Builder fat(int val) {\n            fat = val;\n        }\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n        }\n        public Builder NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n\n    }\n}\n</code></pre>\n<p>建造者模式是在需要创建对象的类里面定义一个内部类，然后通过这个内部类来实现set函数的功能，不同的是set函数返回void，而建造者类的函数返回本身，这样就实现了链式编程的原理。</p>\n','## 第二章 创建和销毁对象\n![](images/blog/java.jpg)\n\n**第2条：遇到多个构造器参数时要考虑用构建器**\n\n如果一个类有很多参数，例如考虑一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等，这样的类该怎么去定义呢？\n\n\n\n**常见的定义方式**\n\n```java\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n    \n    public NutritionFacts(param1,param2....) {\n        \n    }\n    \n}\n```\n\n这种方式通过构造器的方式直接将字段的实际值传入，然后根据这些值创建一个对象，这样做通常需要定义多个重载的构造器，然而，一旦参数非常多的情况下（多余5个）那么使用这个构造器会很繁琐，程序员一般不会记得这么多的构造函数。所以，为了减少繁琐的构造函数，可以采用JavaBean的方式进行，一般情况下就是采用的JavaBean的方式。\n\n**使用JavaBean的方式进行定义**\n\n```java\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n   //各种set get 函数\n    \n}\n```\n\n使用JavaBean的模式时候将每个字段的set函数单独分离出来，然后程序员调用的时候大概会如下面这样\n\n```java\nNutritionFacts ntf = new NutritionFacts();\nntf.setXXX(val);\nntf.setXXX(val);\nntf.setXXX(val);\n```\n\n可以看到，这样做解决了构造函数参数过长的问题，但是却存在了一个新的问题，那就是每次setXXX的时候导致此对象的状态不一致，如果是在多线程的条件下可能会出现严重的问题，（不知所云的，但是书上这么说的，不知道为什么？）\n\n\n\n为了解决这个问题，推荐使用建造者模式。\n\n**使用建造者模式**\n\n```java\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n    \n    public static class Builder {\n        //Required paramters\n        private final int servingSize;\n        private final int servings;\n        //Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int carbohydrate = 0;\n        private int sodium = 0;\n        \n        public Builder calories(int val) {\n            calories = val; \n            return this;\n        }\n        public Builder fat(int val) {\n            fat = val;\n        }\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n        }\n        public Builder NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n    \n    private NutritionFacts(Builder builder) {\n        \n    }\n}\n```\n\n建造者模式是在需要创建对象的类里面定义一个内部类，然后通过这个内部类来实现set函数的功能，不同的是set函数返回void，而建造者类的函数返回本身，这样就实现了链式编程的原理。','第二章 创建和销毁对象\n第2条：遇到多个构造器参数时要考虑用构建器\n如果一个类有很多参数，例如考虑一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等，这样的类该怎么去定义呢','2018-12-18 11:22:28','2018-12-18 11:22:28',8,86,1,'973ff24c034a4d029a73b4d95f8aeb26',1),(11,'springmvc注解开发','<h1 id=\"h1-spring-\"><a name=\"Spring注解开发\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring注解开发</h1><p>使用<a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a> 、 <a href=\"https://github.com/service\" title=\"&#64;service\" class=\"at-link\">@service</a> 、<a href=\"https://github.com/Repository\" title=\"&#64;Repository\" class=\"at-link\">@Repository</a> 这样的注解进行开发已经是很平常的事情了，这里不再详述了</p>\n<h2 id=\"h2--configuration-\"><a name=\"使用@Configuration注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用<a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>注解</h2><p><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>注解是一个spring注解，这个注解用于告诉spring框架这是一个配置类，这里配置的Bean要交给Spring去管理。来看看这个注解的具体内容</p>\n<pre><code class=\"lang-java\">@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Configuration {\n    String value() default &quot;&quot;;\n}\n</code></pre>\n<h2 id=\"h2--componentscan-\"><a name=\"@ComponentScan 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a> 注解</h2><p>这个注解和xml文件中的context:component-scan 这个属性是一模一样的。包括属性。这里有一个例子</p>\n<pre><code class=\"lang-java\">package cn.ljtnono.myblog.config;\n\nimport cn.ljtnono.myblog.utils.SpringUtil;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\n\n/**\n *  配置了各种bean\n *  @author ljt\n *  @date 2018/12/17\n *  @version 1.0\n */\n@Configuration\n@ComponentScan(value = {&quot;cn.ljtnono.myblog&quot;,&quot;cn.ljtnono.myblog.aspect&quot;},excludeFilters = {\n        @ComponentScan.Filter(Controller.class),\n        @ComponentScan.Filter(Aspect.class)\n})\npublic class MainConfig {\n\n    /**\n     * 配置一个SpringUtil 用来在任何环境下能够获取ioc容器中的Bean\n     * @return SpringUtil\n     */\n    @Bean\n    @Lazy //懒加载\n    public ApplicationContextAware setApplicationContextAware() {\n        return new SpringUtil();\n    }\n\n    /**\n     * 设置文件上传下载组件\n     * 这里name必须设置为multipartResolver\n     * @return CommonsMultipartResolver组件\n     */\n    @Bean(name = &quot;multipartResolver&quot;)\n    @Lazy\n    public CommonsMultipartResolver setCommonsMultipartResolver() {\n        CommonsMultipartResolver resolver = new CommonsMultipartResolver();\n        resolver.setMaxUploadSizePerFile(500000000);\n        resolver.setDefaultEncoding(&quot;UTF-8&quot;);\n        resolver.setResolveLazily(true);\n        return resolver;\n    }\n\n\n}\n</code></pre>\n<p>这里我是配置了一个文件上传的处理Bean和一个用于获取Bean的SpringUtil，这里都很好理解，主要是上面的</p>\n<p><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>注解的内容，我这里配置的value值是两个基础包，然后配置了不要扫描Controller层和切片层</p>\n<p>因为被Springmvc的配置文件已经扫描了。具体的内容就不详述。</p>\n<p><strong><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>注解</strong></p>\n<p>这个注解可以实现在一个配置类中引入另外一个配置类的相关配置</p>\n<pre><code class=\"lang-java\">@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n    Class&lt;?&gt;[] value();\n}\n</code></pre>\n<p>只需要传入class数组就OK</p>\n','# Spring注解开发\n\n使用@Controller 、 @service 、@Repository 这样的注解进行开发已经是很平常的事情了，这里不再详述了\n\n\n\n## 使用@Configuration注解\n\n@Configuration注解是一个spring注解，这个注解用于告诉spring框架这是一个配置类，这里配置的Bean要交给Spring去管理。来看看这个注解的具体内容\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Configuration {\n    String value() default \"\";\n}\n```\n\n\n\n## @ComponentScan 注解\n\n这个注解和xml文件中的context:component-scan 这个属性是一模一样的。包括属性。这里有一个例子\n\n```java\npackage cn.ljtnono.myblog.config;\n\nimport cn.ljtnono.myblog.utils.SpringUtil;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\n\n/**\n *  配置了各种bean\n *  @author ljt\n *  @date 2018/12/17\n *  @version 1.0\n */\n@Configuration\n@ComponentScan(value = {\"cn.ljtnono.myblog\",\"cn.ljtnono.myblog.aspect\"},excludeFilters = {\n        @ComponentScan.Filter(Controller.class),\n        @ComponentScan.Filter(Aspect.class)\n})\npublic class MainConfig {\n\n    /**\n     * 配置一个SpringUtil 用来在任何环境下能够获取ioc容器中的Bean\n     * @return SpringUtil\n     */\n    @Bean\n    @Lazy //懒加载\n    public ApplicationContextAware setApplicationContextAware() {\n        return new SpringUtil();\n    }\n\n    /**\n     * 设置文件上传下载组件\n     * 这里name必须设置为multipartResolver\n     * @return CommonsMultipartResolver组件\n     */\n    @Bean(name = \"multipartResolver\")\n    @Lazy\n    public CommonsMultipartResolver setCommonsMultipartResolver() {\n        CommonsMultipartResolver resolver = new CommonsMultipartResolver();\n        resolver.setMaxUploadSizePerFile(500000000);\n        resolver.setDefaultEncoding(\"UTF-8\");\n        resolver.setResolveLazily(true);\n        return resolver;\n    }\n\n\n}\n\n```\n\n这里我是配置了一个文件上传的处理Bean和一个用于获取Bean的SpringUtil，这里都很好理解，主要是上面的\n\n@ComponentScan注解的内容，我这里配置的value值是两个基础包，然后配置了不要扫描Controller层和切片层\n\n因为被Springmvc的配置文件已经扫描了。具体的内容就不详述。\n\n\n\n**@Import注解**\n\n这个注解可以实现在一个配置类中引入另外一个配置类的相关配置\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n    Class<?>[] value();\n}\n\n```\n\n只需要传入class数组就OK\n\n\n\n','Spring注解开发使用@Controller 、 @service 、@Repository 这样的注解进行开发已经是很平常的事情了，这里不再详述了\n使用@Configuration注解@Configuration注解是一个spring注解，这个注解用于告诉spring框架这是一个配置类，这里配置','2019-01-06 23:10:52','2019-01-06 23:10:52',0,39,10,'8d8bb38d44c945d8b7c643b8ebcf6049',1),(12,'Spring源码阅读','<h3 id=\"h3-spring-factorybean-\"><a name=\"spring中FactoryBean的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>spring中FactoryBean的使用</h3><p>在spring中一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案，Spring提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户通过实现该接口定制实例化bean的逻辑</p>\n<pre><code class=\"lang-java\">package org.springframework.beans.factory;\n\npublic interface FactoryBean&lt;T&gt; {\n\n    //返回需要生产的bean\n    T getObject() throws Exception;\n    //bean的class属性\n    Class&lt;?&gt; getObjectType();\n    //是否是单例\n    boolean isSingleton();\n}\n</code></pre>\n<p>用户只需要实现这个接口，然后将接口的实例类配置到容器中，那么通过getBean得到的就是工厂生产的bean，在getBean使用&amp;前缀就是得到这个FactoryBean本身。这里写个例子看下</p>\n<pre><code class=\"lang-java\">package cn.ljtnono.pojo;\n\npublic class User {\n    private String username;\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n//然后再写一个UserFactory实现FactoryBean接口\npackage cn.ljtnono.pojo;\n\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class UserFactory implements FactoryBean&lt;User&gt; {\n\n    @Override\n    public User getObject() throws Exception {\n        User user = new User();\n        user.setUsername(&quot;zs&quot;);\n        user.setPassword(&quot;lisi&quot;);\n        return user;\n    }\n\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return User.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n//测试\n    @Test\n    public void test1() {\n        //1.获取当前IOC容器\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);\n        BeanFactory beanFactory = ((ClassPathXmlApplicationContext) context).getBeanFactory();\n        //Object user =  beanFactory.getBean(&quot;userFactory&quot;); cn.ljtnono.pojo.User@69930714\n        //Object user =  beanFactory.getBean(&quot;&amp;userFactory&quot;); cn.ljtnono.pojo.UserFactory@69930714\n        System.out.println(user);\n    }\n</code></pre>\n<p>可以看到，如果加上&amp;获取的是UserFactory类型，不加上获取的是User类型。</p>\n','### spring中FactoryBean的使用\n\n在spring中一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案，Spring提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户通过实现该接口定制实例化bean的逻辑\n\n```java\npackage org.springframework.beans.factory;\n\npublic interface FactoryBean<T> {\n\n	//返回需要生产的bean\n	T getObject() throws Exception;\n	//bean的class属性\n	Class<?> getObjectType();\n	//是否是单例\n	boolean isSingleton();\n}\n\n```\n\n用户只需要实现这个接口，然后将接口的实例类配置到容器中，那么通过getBean得到的就是工厂生产的bean，在getBean使用&前缀就是得到这个FactoryBean本身。这里写个例子看下\n\n```java\npackage cn.ljtnono.pojo;\n\npublic class User {\n    private String username;\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n//然后再写一个UserFactory实现FactoryBean接口\npackage cn.ljtnono.pojo;\n\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class UserFactory implements FactoryBean<User> {\n\n    @Override\n    public User getObject() throws Exception {\n        User user = new User();\n        user.setUsername(\"zs\");\n        user.setPassword(\"lisi\");\n        return user;\n    }\n\n\n    @Override\n    public Class<?> getObjectType() {\n        return User.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n//测试\n    @Test\n    public void test1() {\n        //1.获取当前IOC容器\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        BeanFactory beanFactory = ((ClassPathXmlApplicationContext) context).getBeanFactory();\n        //Object user =  beanFactory.getBean(\"userFactory\"); cn.ljtnono.pojo.User@69930714\n        //Object user =  beanFactory.getBean(\"&userFactory\"); cn.ljtnono.pojo.UserFactory@69930714\n        System.out.println(user);\n    }\n```\n\n可以看到，如果加上&获取的是UserFactory类型，不加上获取的是User类型。','spring中FactoryBean的使用在spring中一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息，配置方式的灵活性是受限的，这时采用','2019-01-08 00:15:20','2019-01-08 00:15:20',1,80,8,'1ef20a29c76e4b6ebc82e65cd0dcedb3',1),(13,'JS表单验证','<h2 id=\"h2-u5173u4E8Eu8868u5355u7684u63D0u4EA4u9A8Cu8BC1\"><a name=\"关于表单的提交验证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于表单的提交验证</h2><p>表单的提交验证是通过调用表单的onsubmit方法来实现提交的，这里我们可以使用JS监听表单的onsubmit方法来实现对表单元素的验证</p>\n<p>例如：</p>\n<pre><code class=\"lang-html\">&lt;form action=&quot;${basePath}back/login&quot; method=&quot;post&quot; id=&quot;loginform&quot;&gt;\n                &lt;div class=&quot;layui-form&quot;&gt;\n                    &lt;div class=&quot;layui-form-item&quot;&gt;\n                        &lt;input type=&quot;text&quot; name=&quot;user&quot; class=&quot;layui-input user&quot; placeholder=&quot;用户名&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;layui-form-item&quot;&gt;\n                        &lt;input type=&quot;password&quot; name=&quot;psw&quot; class=&quot;layui-input psw&quot; placeholder=&quot;密码&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;layui-form-item&quot; style=&quot;margin-top: 60px;&quot;&gt;\n                        &lt;div class=&quot;layui-input-block&quot;&gt;\n                            &lt;input class=&quot;layui-btn submit&quot; type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/form&gt;\n</code></pre>\n<p>这里使用JQuery来实现对表单的验证</p>\n<pre><code class=\"lang-javascript\">//输入过滤\n    $(&quot;#loginform&quot;).submit(function () {\n        const $user = $(&quot;.user&quot;);\n        const $psw = $(&quot;.psw&quot;);\n        if (testUser($user)) {\n            //发送请求\n            if (testPsw($psw)) {\n                return true;\n            } else {\n                layui.use(&quot;layer&quot;, function () {\n                    layer.msg(&quot;密码不能为空！&quot;);\n                });\n                return false;\n            }\n        } else {\n            layui.use(&quot;layer&quot;, function () {\n                layer.msg(&quot;请检查用户名的正确性！用户名不能包含中文，是数字和字母的6-10位组合&quot;);\n            });\n            return false;\n        }\n    });\n</code></pre>\n<p>说明：监听onsibmit方法的时候</p>\n<p>返回 false 不进行提交表单</p>\n<p>返回 true 提交表单</p>\n<p>默认返回 true</p>\n','## 关于表单的提交验证\n\n表单的提交验证是通过调用表单的onsubmit方法来实现提交的，这里我们可以使用JS监听表单的onsubmit方法来实现对表单元素的验证\n\n例如：\n\n```html\n<form action=\"${basePath}back/login\" method=\"post\" id=\"loginform\">\n                <div class=\"layui-form\">\n                    <div class=\"layui-form-item\">\n                        <input type=\"text\" name=\"user\" class=\"layui-input user\" placeholder=\"用户名\">\n                    </div>\n                    <div class=\"layui-form-item\">\n                        <input type=\"password\" name=\"psw\" class=\"layui-input psw\" placeholder=\"密码\">\n                    </div>\n                    <div class=\"layui-form-item\" style=\"margin-top: 60px;\">\n                        <div class=\"layui-input-block\">\n                            <input class=\"layui-btn submit\" type=\"submit\" value=\"登陆\"/>\n                        </div>\n                    </div>\n                </div>\n            </form>\n```\n\n这里使用JQuery来实现对表单的验证\n\n```javascript\n//输入过滤\n    $(\"#loginform\").submit(function () {\n        const $user = $(\".user\");\n        const $psw = $(\".psw\");\n        if (testUser($user)) {\n            //发送请求\n            if (testPsw($psw)) {\n                return true;\n            } else {\n                layui.use(\"layer\", function () {\n                    layer.msg(\"密码不能为空！\");\n                });\n                return false;\n            }\n        } else {\n            layui.use(\"layer\", function () {\n                layer.msg(\"请检查用户名的正确性！用户名不能包含中文，是数字和字母的6-10位组合\");\n            });\n            return false;\n        }\n    });\n```\n\n说明：监听onsibmit方法的时候\n\n返回 false 不进行提交表单\n\n返回 true 提交表单\n\n默认返回 true','关于表单的提交验证表单的提交验证是通过调用表单的onsubmit方法来实现提交的，这里我们可以使用JS监听表单的onsubmit方法来实现对表单元素的验证\n例如：\n&lt;form action=&quot;${basePath}back/login&quot; method=&quot;post&','2019-01-08 00:36:31','2019-01-08 00:36:31',0,12,5,'1f2c8fc02c7f4d85b71bc084dd8b20f2',1),(14,'java代码改善','<h2 id=\"h2--equals-hashcode-\"><a name=\"关于覆盖equals和hashCode方法的一些建议和想法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于覆盖equals和hashCode方法的一些建议和想法</h2><p>1、 当类是私有的或者包级私有（不加任何修饰符）,如果你确定它的equals方法永远也不会被调用。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用。</p>\n<pre><code class=\"lang-java\">@Override\npublic boolean equals(Object 0) {\n    throw new AssertionError(); // Method is never called;\n}\n</code></pre>\n<h2 id=\"h2-u4EE3u7801u8D28u91CFu6539u5584\"><a name=\"代码质量改善\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码质量改善</h2><p>1、工具类如果没有必要，那么请将其构造函数私有化，防止不必要的创建其对象实体</p>\n<p>2、在for循环中尽量不要重复创建对象的引用，例如</p>\n<pre><code class=\"lang-java\">for (int i = 0 ; i &lt; 10; i++) {\n    Object o = new Object();\n}\n\n//应该改成\nObject o = null;\nfor (int i = 0; i &lt; 10; i++) {\n    o = new Object();\n}\n</code></pre>\n<h2 id=\"h2-comparable-comparator-\"><a name=\"Comparable 和 Comparator接口的学习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Comparable 和 Comparator接口的学习</h2><p>Comparable接口只有一个方法</p>\n<pre><code class=\"lang-java\">public interface Comparable&lt;T&gt; {\n\n    public int comparaTo(T o);\n\n}\n</code></pre>\n<p>Comparable可以认为是一个<strong>内比较器</strong>，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为<strong>自然比较方法</strong>。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：</p>\n<p>1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数</p>\n<p>2、比较者等于被比较者，那么返回0</p>\n<p>3、比较者小于被比较者，那么返回负整数</p>\n<p><strong>Comparator</strong></p>\n<p>Comparator可以认为是是一个<strong>外比较器</strong>，个人认为有两种情况可以使用实现Comparator接口的方式：</p>\n<p>1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较</p>\n<p>2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式</p>\n<p>Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：</p>\n<p>1、o1大于o2，返回正整数</p>\n<p>2、o1等于o2，返回0</p>\n<p>3、o1小于o3，返回负整数</p>\n<p><strong>总结：Comparable接口是一个内比较器，主要用于同一类型的数据对自己进行比较，Comparator接口主要用于实现外比较，就是实现不同对象之间的比较。</strong></p>\n<h2 id=\"h2-u547Du540Du89C4u8303\"><a name=\"命名规范\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命名规范</h2><h3 id=\"h3--strong-strong-\"><a name=\"<strong>驼峰法则：</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>驼峰法则：</strong></h3><p>将所有字母都小写(包括缩写)，然后将单词的第一个字母大写。</p>\n<p>每个单词的第一个字母都大写，来得到<strong>大驼峰</strong>式命名。</p>\n<p>除了第一个单词，每个单词的第一个字母都大写，来得到<strong>(小)驼峰</strong>式命名。</p>\n<p>为避免歧义，文中小驼峰法统称为驼峰法，大驼峰/帕斯卡法统称为大驼峰法则。</p>\n<h2 id=\"h2-1-package\"><a name=\"1. Package\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Package</h2><p>项目包命名规则：&lt;域名反转&gt;.&lt;团队名&gt;.&lt;项目名&gt;。相关项目可使用&lt;域名反转&gt;.&lt;团队名&gt;.&lt;父项目名&gt;.&lt;子项目名&gt;的命名法则。</p>\n<p>命名必须全部使用英文小写字母，禁止使用“下划线”等字符。（除常量外，Java命名习惯中均不推荐使用下划线等字符）</p>\n<p>示例：</p>\n<pre><code>com.cnblogs.niceboat.soyteam.anticorruptionsystem\n</code></pre><h2 id=\"h2-2-class-object-interface\"><a name=\"2. Class/Object、Interface\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Class/Object、Interface</h2><p>类和接口使用大驼峰命名法</p>\n<p>抽象类使用“Abstract”做为类命名的开头</p>\n<p>Exception类命名使用“Exception”做为类命名的结尾</p>\n<p>Test类使用“Test”做为类命名的结尾</p>\n<p>在面向接口编程中，接口的实现类的命名规则为：&lt;接口名&gt;+”Impl”。禁止使用匈牙利命名法。</p>\n<p>示例（正确）：</p>\n<table>\n<thead>\n<tr>\n<th><strong>接口</strong></th>\n<th><strong>实现类</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HandsomeProvider</td>\n<td>HandsomeProviderImpl</td>\n</tr>\n</tbody>\n</table>\n<p>匈牙利命名法（不推荐）：</p>\n<table>\n<thead>\n<tr>\n<th><strong>接口</strong></th>\n<th><strong>实现类</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IHandsomeProvider</td>\n<td>HandsomeProvider</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-3-method-function\"><a name=\"3. Method/Function\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Method/Function</h2><p>方法的命名使用驼峰法，一般使用动词或动词+名词组合。</p>\n<p>设置/获取某个值的方法，命名为setV/getV</p>\n<p>返回长度的方法，命名为length</p>\n<p>判断布尔值的方法，命名为isV</p>\n<p>将对象转换为某个特定类型的方法应该命名为toT</p>\n<p>示例：</p>\n<table>\n<thead>\n<tr>\n<th>getSecretStage()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>length()</td>\n</tr>\n<tr>\n<td>isEmpty()</td>\n</tr>\n<tr>\n<td>toSpecialFormat()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-4-variable\"><a name=\"4. Variable\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Variable</h2><p>变量的命名使用驼峰法</p>\n<p>示例：</p>\n<pre><code>OpenId\n</code></pre><p>常量命名使用大写字母并用下划线分割</p>\n<p>示例：</p>\n<pre><code>MAX_SUITABLE_SIZE\n</code></pre><h2 id=\"h2--equals-hashcode-\"><a name=\"关于重载equals和hashCode方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于重载equals和hashCode方法</h2><pre><code>/**\n * 通用equals重载方法的写法\n * @param o 需要比较的对象\n * @return true 相等  false 不相等\n */\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    //如果类型不一样那么直接返回false 这里可以自定义相关的比较功能\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    Img img = (Img) o;\n    return Objects.equals(id, img.id) &amp;&amp;\n            Objects.equals(title, img.title) &amp;&amp;\n            Objects.equals(type, img.type) &amp;&amp;\n            Objects.equals(src, img.src) &amp;&amp;\n            Objects.equals(updateDateTime, img.updateDateTime) &amp;&amp;\n            Objects.equals(createDateTime, img.createDateTime);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(id, title, type, src, updateDateTime, createDateTime);\n}\n</code></pre>','## 关于覆盖equals和hashCode方法的一些建议和想法\n\n1、 当类是私有的或者包级私有（不加任何修饰符）,如果你确定它的equals方法永远也不会被调用。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用。\n\n```java\n@Override\npublic boolean equals(Object 0) {\n    throw new AssertionError(); // Method is never called;\n}\n```\n\n\n\n## 代码质量改善\n\n1、工具类如果没有必要，那么请将其构造函数私有化，防止不必要的创建其对象实体\n\n2、在for循环中尽量不要重复创建对象的引用，例如\n\n```java\nfor (int i = 0 ; i < 10; i++) {\n    Object o = new Object();\n}\n\n//应该改成\nObject o = null;\nfor (int i = 0; i < 10; i++) {\n    o = new Object();\n}\n\n```\n\n\n\n\n\n## Comparable 和 Comparator接口的学习\n\nComparable接口只有一个方法\n\n```java\npublic interface Comparable<T> {\n  \n    public int comparaTo(T o);\n    \n}\n```\n\nComparable可以认为是一个**内比较器**，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为**自然比较方法**。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：\n\n1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数\n\n2、比较者等于被比较者，那么返回0\n\n3、比较者小于被比较者，那么返回负整数\n\n\n\n**Comparator**\n\nComparator可以认为是是一个**外比较器**，个人认为有两种情况可以使用实现Comparator接口的方式：\n\n1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较\n\n2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式\n\nComparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：\n\n1、o1大于o2，返回正整数\n\n2、o1等于o2，返回0\n\n3、o1小于o3，返回负整数\n\n**总结：Comparable接口是一个内比较器，主要用于同一类型的数据对自己进行比较，Comparator接口主要用于实现外比较，就是实现不同对象之间的比较。**\n\n## 命名规范\n\n### **驼峰法则：**\n\n将所有字母都小写(包括缩写)，然后将单词的第一个字母大写。\n\n每个单词的第一个字母都大写，来得到**大驼峰**式命名。\n\n除了第一个单词，每个单词的第一个字母都大写，来得到**(小)驼峰**式命名。\n\n \n\n为避免歧义，文中小驼峰法统称为驼峰法，大驼峰/帕斯卡法统称为大驼峰法则。\n\n## 1. Package\n\n项目包命名规则：<域名反转>.<团队名>.<项目名>。相关项目可使用<域名反转>.<团队名>.<父项目名>.<子项目名>的命名法则。\n\n命名必须全部使用英文小写字母，禁止使用“下划线”等字符。（除常量外，Java命名习惯中均不推荐使用下划线等字符）\n\n示例：\n\n```\ncom.cnblogs.niceboat.soyteam.anticorruptionsystem\n```\n\n \n\n## 2. Class/Object、Interface\n\n类和接口使用大驼峰命名法\n\n抽象类使用“Abstract”做为类命名的开头\n\nException类命名使用“Exception”做为类命名的结尾\n\nTest类使用“Test”做为类命名的结尾\n\n在面向接口编程中，接口的实现类的命名规则为：<接口名>+\"Impl\"。禁止使用匈牙利命名法。\n\n示例（正确）：\n\n| **接口**         | **实现类**           |\n| ---------------- | -------------------- |\n| HandsomeProvider | HandsomeProviderImpl |\n\n匈牙利命名法（不推荐）：\n\n| **接口**          | **实现类**       |\n| ----------------- | ---------------- |\n| IHandsomeProvider | HandsomeProvider |\n\n## 3. Method/Function\n\n方法的命名使用驼峰法，一般使用动词或动词+名词组合。\n\n设置/获取某个值的方法，命名为setV/getV\n\n返回长度的方法，命名为length\n\n判断布尔值的方法，命名为isV\n\n将对象转换为某个特定类型的方法应该命名为toT\n\n示例：\n\n| getSecretStage()  |\n| ----------------- |\n| length()          |\n| isEmpty()         |\n| toSpecialFormat() |\n\n## 4. Variable\n\n变量的命名使用驼峰法\n\n示例：\n\n```\nOpenId\n```\n\n常量命名使用大写字母并用下划线分割\n\n示例：\n\n```\nMAX_SUITABLE_SIZE\n```\n\n\n\n## 关于重载equals和hashCode方法\n\n```\n/**\n * 通用equals重载方法的写法\n * @param o 需要比较的对象\n * @return true 相等  false 不相等\n */\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    //如果类型不一样那么直接返回false 这里可以自定义相关的比较功能\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    Img img = (Img) o;\n    return Objects.equals(id, img.id) &&\n            Objects.equals(title, img.title) &&\n            Objects.equals(type, img.type) &&\n            Objects.equals(src, img.src) &&\n            Objects.equals(updateDateTime, img.updateDateTime) &&\n            Objects.equals(createDateTime, img.createDateTime);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(id, title, type, src, updateDateTime, createDateTime);\n}\n```\n\n','关于覆盖equals和hashCode方法的一些建议和想法1、 当类是私有的或者包级私有（不加任何修饰符）,如果你确定它的equals方法永远也不会被调用。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用。\n@Override\npublic boolean equals(Objec','2019-01-08 00:38:47','2019-01-08 00:38:47',0,5,1,'30bc3a736fc4468f9056d8d189785dd2',1),(15,'Springmvc异常处理','<h2 id=\"h2-springmvc-\"><a name=\"springmvc中异常的处理方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc中异常的处理方式</h2><p>springmvc中主要提供了两种处理异常的方式</p>\n<ul>\n<li>使用SimpleMappingExceptionResolver</li><li>使用<a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a>注解实现局部异常处理或使用<a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a>注解实现统一异常处理</li></ul>\n<p>1、SimpleMappingExceptionResolver方式</p>\n<p>这种方式其实很简单，主要是在xml文件中进行一些简单的配置就OK了</p>\n<p>例如：</p>\n<pre><code class=\"lang-xml\">&lt;!--配置异常处理bean--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot; &gt;\n        &lt;!--表示所有没有指定的异常全部由defaultError.jsp进行处理--&gt;\n        &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot; /&gt;\n        &lt;!--配置在页面中访问的异常对象的名字\n            也就是说，在所有的页面中都可以通过EL表达式的来访问ex这个变量，进而获取异常信息进行处理\n        --&gt;\n        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot; /&gt;\n        &lt;property name=&quot;exceptionMappings&quot; &gt;\n            &lt;props&gt;\n                &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;/defaultError&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>实际上就是配置一个bean，这个bean是SimpleMappingExceptionResolver的实例</p>\n<p>这里主要就是配置三个属性</p>\n<ul>\n<li>defaultErroeView就是默认异常跳转的页面，这里需要注意的是不能直接写成xxx.jsp或者xxx.html，而是需要根据你当前的springmvc的视图解析的环境进行设置。</li><li>exceptionAttribute 这个属性是配置返回视图时携带的参数的名称，这里设置为ex，到了JSP环境中就可以使用El表达式获取相关错误信息。例如${ex.message}</li><li>exceptionMappings 这个属性主要是设置某个具体的异常跳转的页面，这是一个数组，里面的子标签props的key属性配置的是处理的异常的全限定类名，然后值也是根据当前的springmvc的配置进行跳转的请求URL。</li></ul>\n<p>2、使用<a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a>注解进行异常处理</p>\n<p>这个注解可以声明在一个方法上</p>\n<pre><code class=\"lang-java\">@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface ExceptionHandler {\n\n    /**\n     * Exceptions handled by the annotated method. If empty, will default to any\n     * exceptions listed in the method argument list.\n     */\n    Class&lt;? extends Throwable&gt;[] value() default {};\n\n}\n</code></pre>\n<p>接收具体的类作为一个参数，然后如果抛出了这个异常那么就使用这个方法进行处理，但是据李刚的疯狂讲义上面说这个注解需要这个函数声明在controller中，例如</p>\n<pre><code class=\"lang-java\">@Controller\npublic class BlogController {\n    ...\n        some method and field\n    ...\n    @ExceptionHandler(Exception.class)\n    public ModelAndView deal(Exception e) {\n         ...\n           do something     \n        ...\n        return new ModelAndView();\n    }\n}\n</code></pre>\n<p>然后这个controller中如果抛出异常的话，那么会使用这个方法来处理异常。</p>\n<p>这种方式有一个缺点，那就是当controller多了之后，每个controller都需要写一个这样的方法作异常处理，那么么会很不方便，解决办法有两个：</p>\n<ul>\n<li><p>声明一个父类的controller，然后让所有的controller去继承这个controller（不推荐）</p>\n</li><li><p>使用<a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\"><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></a> 这是一个通知，打上这个注解的类会被spring给识别，然后可以在这个类中定义方法来处理异常，例如：</p>\n<pre><code class=\"lang-java\"><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a>\npublic class SpringExceptionHandler{\n\n    /**\n     * 统一异常处理方式\n     * <a href=\"https://github.com/param\" title=\"&#64;param\" class=\"at-link\">@param</a> e 出现的异常类\n     * <a href=\"https://github.com/return\" title=\"&#64;return\" class=\"at-link\">@return</a> 跳转的视图\n     */\n    <a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a>(Exception.class)\n    public ModelAndView globalExceptionHandler(Exception e) {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject(&quot;ex&quot;,e);\n        mv.setViewName(&quot;error&quot;);\n        return mv;\n    }\n\n}\n</code></pre>\n</li></ul>\n<p>springmvc的异常处理方式大概就说完了，还有就是这些类的源码需要去花时间阅读，搞清楚其中到底是怎么实现的。</p>\n','## springmvc中异常的处理方式\n\nspringmvc中主要提供了两种处理异常的方式\n\n- 使用SimpleMappingExceptionResolver\n- 使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\n\n\n\n1、SimpleMappingExceptionResolver方式\n\n这种方式其实很简单，主要是在xml文件中进行一些简单的配置就OK了\n\n例如：\n\n```xml\n<!--配置异常处理bean-->\n	<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\" >\n		<!--表示所有没有指定的异常全部由defaultError.jsp进行处理-->\n		<property name=\"defaultErrorView\" value=\"error\" />\n		<!--配置在页面中访问的异常对象的名字\n			也就是说，在所有的页面中都可以通过EL表达式的来访问ex这个变量，进而获取异常信息进行处理\n		-->\n		<property name=\"exceptionAttribute\" value=\"ex\" />\n		<property name=\"exceptionMappings\" >\n			<props>\n				<prop key=\"org.apache.shiro.authz.UnauthorizedException\">/defaultError</prop>\n			</props>\n		</property>\n	</bean>\n```\n\n实际上就是配置一个bean，这个bean是SimpleMappingExceptionResolver的实例\n\n这里主要就是配置三个属性\n\n- defaultErroeView就是默认异常跳转的页面，这里需要注意的是不能直接写成xxx.jsp或者xxx.html，而是需要根据你当前的springmvc的视图解析的环境进行设置。\n- exceptionAttribute 这个属性是配置返回视图时携带的参数的名称，这里设置为ex，到了JSP环境中就可以使用El表达式获取相关错误信息。例如${ex.message}\n- exceptionMappings 这个属性主要是设置某个具体的异常跳转的页面，这是一个数组，里面的子标签props的key属性配置的是处理的异常的全限定类名，然后值也是根据当前的springmvc的配置进行跳转的请求URL。\n\n\n\n\n\n2、使用@ExceptionHandler注解进行异常处理\n\n这个注解可以声明在一个方法上\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface ExceptionHandler {\n\n	/**\n	 * Exceptions handled by the annotated method. If empty, will default to any\n	 * exceptions listed in the method argument list.\n	 */\n	Class<? extends Throwable>[] value() default {};\n\n}\n```\n\n接收具体的类作为一个参数，然后如果抛出了这个异常那么就使用这个方法进行处理，但是据李刚的疯狂讲义上面说这个注解需要这个函数声明在controller中，例如\n\n\n\n```java\n@Controller\npublic class BlogController {\n    ...\n        some method and field\n    ...\n    @ExceptionHandler(Exception.class)\n    public ModelAndView deal(Exception e) {\n 		...\n       	do something     \n        ...\n        return new ModelAndView();\n    }\n}\n```\n\n然后这个controller中如果抛出异常的话，那么会使用这个方法来处理异常。\n\n这种方式有一个缺点，那就是当controller多了之后，每个controller都需要写一个这样的方法作异常处理，那么么会很不方便，解决办法有两个：\n\n- 声明一个父类的controller，然后让所有的controller去继承这个controller（不推荐）\n\n- 使用@ControllerAdvice 这是一个通知，打上这个注解的类会被spring给识别，然后可以在这个类中定义方法来处理异常，例如：\n\n  ```java\n  @ControllerAdvice\n  public class SpringExceptionHandler{\n  \n      /**\n       * 统一异常处理方式\n       * @param e 出现的异常类\n       * @return 跳转的视图\n       */\n      @ExceptionHandler(Exception.class)\n      public ModelAndView globalExceptionHandler(Exception e) {\n          ModelAndView mv = new ModelAndView();\n          mv.addObject(\"ex\",e);\n          mv.setViewName(\"error\");\n          return mv;\n      }\n  \n  }\n  \n  ```\n\nspringmvc的异常处理方式大概就说完了，还有就是这些类的源码需要去花时间阅读，搞清楚其中到底是怎么实现的。','springmvc中异常的处理方式springmvc中主要提供了两种处理异常的方式\n\n使用SimpleMappingExceptionResolver使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\n1、SimpleMapping','2019-01-08 00:41:45','2019-01-08 00:41:45',0,13,10,'1718cbd0a41f4153a420600c14f6379b',1),(16,'Redis 安装','<h2 id=\"h2-redis-\"><a name=\"redis学习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis学习</h2><p>1、redis的安装</p>\n<ul>\n<li>首先在官方网站中下载gz包然后上传到linux中</li><li>解压</li><li>安装gcc环境，如果已经安装那么直接下一步</li><li>进入bin目录并且执行make编译（不同于nginx，因为redis自带有makefile文件)</li><li>编译完成后执行 make install PREFIX=安装路径 命令</li><li>将bin文件夹中的redis.conf文件移动到安装路径中的bin目录下，方便执行后台运行</li><li>将redis.conf文件中的daemonize属性改为yes，开启后台执行</li><li>将redis.conf文件中的<strong>stop-writes-on-bgsave-error yes</strong> 改为<strong>stop-writes-on-bgsave-error no</strong></li></ul>\n<p>2、创建日志文件夹以及redis持久化文件夹并且赋予读写权限</p>\n<p>3、相关的命令</p>\n<ul>\n<li>启动redis：./redis-server xxx.conf</li><li>关闭redis：./redis-cli shutdown</li><li>连接redis：./redis-cli</li><li>连接上之后退出：quit</li></ul>\n<h2 id=\"h2-redis-\"><a name=\"redis关闭服务出现错误的问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis关闭服务出现错误的问题</h2><p><strong>1、(error) ERR Errors trying to SHUTDOWN. Check logs.</strong></p>\n<blockquote>\n<p>./redis-cli shutdown</p>\n<p>错误提示：(error) ERR Errors trying to SHUTDOWN. Check logs.</p>\n</blockquote>\n<p>解决办法：</p>\n<p>修改redis.conf文件中的</p>\n<p>dir这一行   ，改为一个自己创建的目录，这个目录用于存储数据，也就是做持久化的目录</p>\n<p>例如：</p>\n<blockquote>\n<p>dir /usr/local/redis/bin/redis_dbfiles</p>\n</blockquote>\n<p><strong>2、日志文件报错</strong></p>\n<p>23072:M 08 Jan 2019 22&#58;09&#58;31.857 <em> Ready to accept connections<br>23072:M 08 Jan 2019 22&#58;11&#58;05.727 # User requested shutdown…<br>23072:M 08 Jan 2019 22&#58;11&#58;05.729 </em> Saving the final RDB snapshot before exiting.<br>23072:M 08 Jan 2019 22&#58;11&#58;05.729 # <strong>Failed opening the RDB file dump.rdb (in server root dir /usr/local/redis/bin/redis_dbfiles) for saving: Permission denied</strong></p>\n<p>这里是没有权限的问题，给日志的文件及文件夹授予读写权限即可</p>\n<blockquote>\n<p>sudo chmod 777 xxx文件或文件夹</p>\n</blockquote>\n','## redis学习\n\n1、redis的安装\n\n- 首先在官方网站中下载gz包然后上传到linux中\n- 解压\n- 安装gcc环境，如果已经安装那么直接下一步\n- 进入bin目录并且执行make编译（不同于nginx，因为redis自带有makefile文件)\n- 编译完成后执行 make install PREFIX=安装路径 命令\n- 将bin文件夹中的redis.conf文件移动到安装路径中的bin目录下，方便执行后台运行\n- 将redis.conf文件中的daemonize属性改为yes，开启后台执行\n- 将redis.conf文件中的**stop-writes-on-bgsave-error yes** 改为**stop-writes-on-bgsave-error no**\n\n2、创建日志文件夹以及redis持久化文件夹并且赋予读写权限\n\n3、相关的命令\n\n- 启动redis：./redis-server xxx.conf\n- 关闭redis：./redis-cli shutdown\n- 连接redis：./redis-cli\n- 连接上之后退出：quit\n\n\n## redis关闭服务出现错误的问题\n\n**1、(error) ERR Errors trying to SHUTDOWN. Check logs.**\n\n> ./redis-cli shutdown\n>\n> 错误提示：(error) ERR Errors trying to SHUTDOWN. Check logs.\n\n解决办法：\n\n修改redis.conf文件中的\n\ndir这一行   ，改为一个自己创建的目录，这个目录用于存储数据，也就是做持久化的目录\n\n例如：\n\n> dir /usr/local/redis/bin/redis_dbfiles\n\n**2、日志文件报错**\n\n23072:M 08 Jan 2019 22:09:31.857 * Ready to accept connections\n23072:M 08 Jan 2019 22:11:05.727 # User requested shutdown...\n23072:M 08 Jan 2019 22:11:05.729 * Saving the final RDB snapshot before exiting.\n23072:M 08 Jan 2019 22:11:05.729 # **Failed opening the RDB file dump.rdb (in server root dir /usr/local/redis/bin/redis_dbfiles) for saving: Permission denied**\n\n这里是没有权限的问题，给日志的文件及文件夹授予读写权限即可\n\n> sudo chmod 777 xxx文件或文件夹\n\n','redis学习1、redis的安装\n\n首先在官方网站中下载gz包然后上传到linux中解压安装gcc环境，如果已经安装那么直接下一步进入bin目录并且执行make编译（不同于nginx，因为redis自带有makefile文件)编译完成后执行 make install PREFIX=安装路径 命令将','2019-01-17 18:34:19','2019-01-17 18:34:19',0,38,1,'beab3bfd981e49a8879fea4f66b94f07',1),(17,'多线程技能','<h3 id=\"h3-u7EBFu7A0Bu7684u521Bu5EFAu65B9u5F0F\"><a name=\"线程的创建方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程的创建方式</h3><ul>\n<li><p>继承Thread类</p>\n<p>Thread类是一个线程的抽象，通过创建Thread类的子类并且复写Thread类的run方法来创建一个线程。</p>\n</li><li><p>实现Runnable接口</p>\n<p>Thread类实际上实现了接口Runnable，这个接口有一个方法是run方法，而Thread类的构造函数可以传递一个Runnable接口作为参数，在使用多线程时，如果该类需要继承其他类的时候可以使用实现Runnable接口的方式，其他情况下可使用继承方式。</p>\n</li></ul>\n<h3 id=\"h3-thread-\"><a name=\"Thread类的重要属性和方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Thread类的重要属性和方法</h3><p>Thread类有很多重要的属性和方法，其中比较有用的是以下这些</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>tid</td>\n<td></td>\n<td>线程的id号（long）</td>\n</tr>\n<tr>\n<td>name</td>\n<td></td>\n<td>线程的名字（String）</td>\n</tr>\n<tr>\n<td>daemon</td>\n<td></td>\n<td>是否为守护线程（boolean）</td>\n</tr>\n<tr>\n<td>target</td>\n<td></td>\n<td>Runnable接口，决定了线程执行的任务（Runnable）</td>\n</tr>\n<tr>\n<td>priority</td>\n<td></td>\n<td>线程的优先级（int）最大为10，最小为1，越大越优先</td>\n</tr>\n<tr>\n<td></td>\n<td>isAlive()</td>\n<td>判断线程是否还活着，true表示活着，false表示死了</td>\n</tr>\n<tr>\n<td></td>\n<td>sleep(long m)</td>\n<td>线程睡眠，m为毫秒</td>\n</tr>\n<tr>\n<td></td>\n<td>start()</td>\n<td>启动线程</td>\n</tr>\n<tr>\n<td></td>\n<td>join()</td>\n<td>等待线程线程完成任务</td>\n</tr>\n<tr>\n<td></td>\n<td>getXXX()</td>\n<td>获取线程的一些状态等，如getName,getId,getPriority之类</td>\n</tr>\n<tr>\n<td></td>\n<td>stop()</td>\n<td>强制杀死线程</td>\n</tr>\n<tr>\n<td></td>\n<td>interrupt()</td>\n<td>中断线程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3-u505Cu6B62u7EBFu7A0Bu7684u65B9u6CD5\"><a name=\"停止线程的方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止线程的方法</h3><p>线程的停止是一个比较头疼的问题，因为一些原因，Thread类本身提供的函数有的时候并不能达到停止线程的效果。例如当在线程运行的时候使用interrupt()方法，则停止不了正在运行的线程，因为这个方法只是在线程上面打上一个停止标记，并没有真正的停止线程。</p>\n<p>那怎么样去停止线程呢？下面通过几段代码演示线程停止的几种方式：</p>\n<ul>\n<li><strong>使用interrupt() 配合isInterrupted() 方法</strong></li></ul>\n<pre><code class=\"lang-java\">// 一段简单的代码\npublic class StopThread extends Thread{\n\n    private static int count = 100;\n\n    @Override\n    public void run() {\n        while(true) {\n            count--;\n            System.out.println(Thread.currentThread().getName() + &quot; count = &quot; + count);\n            if (count == 0) {\n                this.interrupt();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        //Thread a = new StopThread();\n        //a.start();\n        // 运行结果是一直在打印，并没有停止\n        // 想要停止的话，在count==0的时候使用stop()方法，但是这个方法太暴力，已经过时了，不推荐\n        // 还有一种方法是在前面判断一下线程是否停止，停止则退出循环即可\n    }\n}\n</code></pre>\n<p>运行结果是一直在打印，并没有停止。</p>\n<p>想要停止的话，在count==0的时候使用stop()方法，但是这个方法太暴力，已经过时了，不推荐。</p>\n<p>还有一种方法是在前面判断一下线程是否停止，停止则退出循环即可。</p>\n<pre><code class=\"lang-java\">public class StopThread extends Thread{ \n    @Override\n    public void run() {\n        while(true) {\n            // 判断当前线程是否已经停止\n            if (this.isInterrupted()) {\n                break;\n            }\n            count--;\n            System.out.println(Thread.currentThread().getName() + &quot; count = &quot; + count);\n            if (count == 0) {\n                this.interrupt();\n            }\n        }\n    }\n}\n</code></pre>\n<ul>\n<li><p><strong>使用return</strong></p>\n<p>这个就不必多说了，在run方法的合适的地方使用return;语句能够使线程结束。</p>\n</li><li><p><strong>使用异常的方式</strong></p>\n</li></ul>\n<pre><code class=\"lang-java\">public class StopThreadByException extends Thread{\n    private static int count = 100;\n    @Override\n    public void run() {\n        try {\n            while(true) {\n                count--;\n                System.out.println(Thread.currentThread().getName() + &quot; count = &quot; + count);\n                if (count == 0) {\n                    throw new InterruptedException();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread a = new StopThreadByException();\n        a.start();\n    }\n}\n// 结果是\n/**\n....\nThread-0 count = 3\nThread-0 count = 2\nThread-0 count = 1\nThread-0 count = 0\njava.lang.InterruptedException\n    at cn.ljtnono.capter1.refresh.StopThreadByException.run(StopThreadByException.java:14)\n\n*/\n</code></pre>\n<h3 id=\"h3-u5B88u62A4u7EBFu7A0B\"><a name=\"守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>守护线程</h3><p>在java中具有两种线程，一个是用户线程，另外一个是守护线程。</p>\n<p>守护线程除了一个特点以外其他的和用户线程是一样的，这个特点是：<strong>只要当前JVM中存在任何一个非守护线程没有结束，守护线程就工作，只有当最后一个非守护线程结束时，守护线程才随JVM一同结束工作。</strong></p>\n<h3 id=\"h3-u7EBFu7A0Bu7684u72B6u6001u8F6Cu6362u56FE\"><a name=\"线程的状态转换图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程的状态转换图</h3><p><img src=\"https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zBC5OAbiRWAAGUJICt9mE398.jpg\" alt=\"\"></p>','### 线程的创建方式\n\n- 继承Thread类\n\n  Thread类是一个线程的抽象，通过创建Thread类的子类并且复写Thread类的run方法来创建一个线程。\n\n- 实现Runnable接口\n\n  Thread类实际上实现了接口Runnable，这个接口有一个方法是run方法，而Thread类的构造函数可以传递一个Runnable接口作为参数，在使用多线程时，如果该类需要继承其他类的时候可以使用实现Runnable接口的方式，其他情况下可使用继承方式。\n\n### Thread类的重要属性和方法\n\nThread类有很多重要的属性和方法，其中比较有用的是以下这些\n\n| 属性     | 方法          | 说明                                                  |\n| -------- | ------------- | ----------------------------------------------------- |\n| tid      |               | 线程的id号（long）                                    |\n| name     |               | 线程的名字（String）                                  |\n| daemon   |               | 是否为守护线程（boolean）                             |\n| target   |               | Runnable接口，决定了线程执行的任务（Runnable）        |\n| priority |               | 线程的优先级（int）最大为10，最小为1，越大越优先      |\n|          | isAlive()     | 判断线程是否还活着，true表示活着，false表示死了       |\n|          | sleep(long m) | 线程睡眠，m为毫秒                                     |\n|          | start()       | 启动线程                                              |\n|          | join()        | 等待线程线程完成任务                                  |\n|          | getXXX()      | 获取线程的一些状态等，如getName,getId,getPriority之类 |\n|          | stop()        | 强制杀死线程                                          |\n|          | interrupt()   | 中断线程                                              |\n\n### 停止线程的方法\n\n线程的停止是一个比较头疼的问题，因为一些原因，Thread类本身提供的函数有的时候并不能达到停止线程的效果。例如当在线程运行的时候使用interrupt()方法，则停止不了正在运行的线程，因为这个方法只是在线程上面打上一个停止标记，并没有真正的停止线程。\n\n那怎么样去停止线程呢？下面通过几段代码演示线程停止的几种方式：\n\n- **使用interrupt() 配合isInterrupted() 方法**\n\n```java\n// 一段简单的代码\npublic class StopThread extends Thread{\n    \n    private static int count = 100;\n    \n    @Override\n    public void run() {\n        while(true) {\n            count--;\n            System.out.println(Thread.currentThread().getName() + \" count = \" + count);\n            if (count == 0) {\n                this.interrupt();\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        //Thread a = new StopThread();\n        //a.start();\n    	// 运行结果是一直在打印，并没有停止\n        // 想要停止的话，在count==0的时候使用stop()方法，但是这个方法太暴力，已经过时了，不推荐\n        // 还有一种方法是在前面判断一下线程是否停止，停止则退出循环即可\n    }\n}\n```\n\n运行结果是一直在打印，并没有停止。\n\n想要停止的话，在count==0的时候使用stop()方法，但是这个方法太暴力，已经过时了，不推荐。\n\n还有一种方法是在前面判断一下线程是否停止，停止则退出循环即可。\n\n```java\npublic class StopThread extends Thread{ \n	@Override\n    public void run() {\n        while(true) {\n            // 判断当前线程是否已经停止\n            if (this.isInterrupted()) {\n                break;\n            }\n            count--;\n            System.out.println(Thread.currentThread().getName() + \" count = \" + count);\n            if (count == 0) {\n                this.interrupt();\n            }\n        }\n    }\n}\n```\n\n- **使用return**\n\n  这个就不必多说了，在run方法的合适的地方使用return;语句能够使线程结束。\n\n- **使用异常的方式**\n\n```java\npublic class StopThreadByException extends Thread{\n    private static int count = 100;\n    @Override\n    public void run() {\n        try {\n            while(true) {\n                count--;\n                System.out.println(Thread.currentThread().getName() + \" count = \" + count);\n                if (count == 0) {\n                    throw new InterruptedException();\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread a = new StopThreadByException();\n        a.start();\n    }\n}\n// 结果是\n/**\n....\nThread-0 count = 3\nThread-0 count = 2\nThread-0 count = 1\nThread-0 count = 0\njava.lang.InterruptedException\n	at cn.ljtnono.capter1.refresh.StopThreadByException.run(StopThreadByException.java:14)\n\n*/\n```\n\n### 守护线程\n\n在java中具有两种线程，一个是用户线程，另外一个是守护线程。\n\n守护线程除了一个特点以外其他的和用户线程是一样的，这个特点是：**只要当前JVM中存在任何一个非守护线程没有结束，守护线程就工作，只有当最后一个非守护线程结束时，守护线程才随JVM一同结束工作。**\n\n### 线程的状态转换图\n![](https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zBC5OAbiRWAAGUJICt9mE398.jpg)','线程的创建方式\n继承Thread类\nThread类是一个线程的抽象，通过创建Thread类的子类并且复写Thread类的run方法来创建一个线程。\n实现Runnable接口\nThread类实际上实现了接口Runnable，这个接口有一个方法是run方法，而Thread类的构造函数可以传递一个Runn','2019-04-25 16:56:09','2019-04-25 16:56:09',0,4,1,'eca3e9a0d36f4c63b1eb5a03d0939db0',1),(18,'对象及变量的并发访问','<h3 id=\"h3--synchronized-\"><a name=\"线程同步与synchronized的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程同步与synchronized的使用</h3><p>什么叫线程同步，线程同步就是多个线程访问一个共享的变量，从而产生共享变量状态的不同的问题，例如：在A线程中修改了count值，在B线程中此时读取到的是修改之后的值，而B线程则不知情，仍然将这个值当做是没有改变之前来处理，这就会出现问题，为了解决这个问题，java使用synchronized关键字来实现线程同步。</p>\n<h4 id=\"h4-synchronized-\"><a name=\"synchronized 修饰方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>synchronized 修饰方法</h4><p>当多个线程同时访问一个共享数据的时候，如果不使用synchronized来同步，就会出现问题，如下所示：</p>\n<pre><code class=\"lang-java\">public class Service {\n    // 模拟一个卖飞机票的场景\n    private int tickets = 100;\n    public void sale() {\n        if (tickets &gt; 0) {\n            tickets--;\n            System.out.println(Thread.currentThread().getName() + &quot; 卖出 一张票！&quot;);\n            System.out.println(&quot;还剩余&quot; + tickets + &quot; 张票&quot;);\n        }\n    }\n    public int getTickets() {\n        return tickets;\n    }\n}\npublic class ThreadA extends Thread{\n    private Service service;\n    public ThreadA(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        //一直卖票\n        while(true) {\n            if (service.getTickets() == 0) {\n                break;\n            }\n            service.sale();\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        // 创建两个线程一起卖票\n        Service service = new Service();\n        ThreadA a = new ThreadA(service);\n        a.setName(&quot;a&quot;);\n        ThreadA b = new ThreadA(service);\n        b.setName(&quot;b&quot;);\n        a.start();\n        b.start();\n    }\n}\n/**\n结果如下：\n。。。。\nb 卖出 一张票！\na 卖出 一张票！\n还剩余59 张票\n还剩余59 张票\nb 卖出 一张票！\na 卖出 一张票！\n还剩余57 张票\nb 卖出 一张票！\na 卖出 一张票！\n。。。\n还剩余0 张票\n还剩余5 张票\n*/\n</code></pre>\n<p>可以看到出现了变量不同步的问题，如何解决这个问题呢？，那就是使用synchronized修饰方法</p>\n<pre><code class=\"lang-java\">// 修改service的sale 和 getTickets 方法如下\npublic class Service {\n    // 模拟一个卖飞机票的场景\n    private int tickets = 100;\n    synchronized public void sale() {\n        if (tickets &gt; 0) {\n            tickets--;\n            System.out.println(Thread.currentThread().getName() + &quot; 卖出 一张票！&quot;);\n            System.out.println(&quot;还剩余&quot; + tickets + &quot; 张票&quot;);\n        }\n    }\n    synchronized public int getTickets() {\n        return tickets;\n    }\n}\n/**\n结果发现a、b两个线程平等的卖票，并没有发生异常情况\n*/\n</code></pre>\n<h4 id=\"h4-synchronized-\"><a name=\"synchronized修饰代码块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>synchronized修饰代码块</h4><p>除了上面使用的synchronized来修饰函数以外，还可以使用synchronized来修饰需要同步的代码块</p>\n<pre><code class=\"lang-java\">// 修改上例的service类\npublic class Service {\n    // 模拟一个卖飞机票的场景\n    private int tickets = 100;\n    synchronized public void sale() {\n        if (tickets &gt; 0) {\n            tickets--;\n            System.out.println(Thread.currentThread().getName() + &quot; 卖出 一张票！&quot;);\n            System.out.println(&quot;还剩余&quot; + tickets + &quot; 张票&quot;);\n        }\n    }\n    public int getTickets() {\n        synchronized (this) {\n            return tickets;\n        }\n    }\n}\n/**\n结果：没有异常\n*/\n</code></pre>\n<h4 id=\"h4-synchronized-\"><a name=\"synchronized与对象监视器（锁）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>synchronized与对象监视器（锁）</h4><p>在上面的例子中，可以看到当使用synchronized修饰代码块的时候，括号里面的写了一个this，这个this是什么？这个this是对象监视器，什么是对象监视器？对象监视器就相当于是锁，当一个线程去访问synchronized方法时，这个方法相当于被上了一个锁，这个锁是这个对象，也就是this，等到此线程完成任务或者主动释放锁之后其他线程才能再访问这个方法，也就是说如果没有锁就得等待，有锁才可以执行。</p>\n<h4 id=\"h4-synchronized-\"><a name=\"synchronized与锁的类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>synchronized与锁的类型</h4><p>synchronized修饰的位置不同，锁的类型也不同，具体关系如下表：</p>\n<table>\n<thead>\n<tr>\n<th>synchronized修饰的位置</th>\n<th>锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>修饰方法</td>\n<td>this对象</td>\n</tr>\n<tr>\n<td>修饰代码块 例如  synchronized(lock)</td>\n<td>括号中表示的对象（lock)</td>\n</tr>\n<tr>\n<td>修饰静态方法</td>\n<td>class对象</td>\n</tr>\n<tr>\n<td>修饰静态代码块</td>\n<td>class对象</td>\n</tr>\n</tbody>\n</table>','### 线程同步与synchronized的使用\n\n什么叫线程同步，线程同步就是多个线程访问一个共享的变量，从而产生共享变量状态的不同的问题，例如：在A线程中修改了count值，在B线程中此时读取到的是修改之后的值，而B线程则不知情，仍然将这个值当做是没有改变之前来处理，这就会出现问题，为了解决这个问题，java使用synchronized关键字来实现线程同步。\n\n#### synchronized 修饰方法\n\n当多个线程同时访问一个共享数据的时候，如果不使用synchronized来同步，就会出现问题，如下所示：\n\n```java\npublic class Service {\n    // 模拟一个卖飞机票的场景\n    private int tickets = 100;\n    public void sale() {\n        if (tickets > 0) {\n            tickets--;\n            System.out.println(Thread.currentThread().getName() + \" 卖出 一张票！\");\n            System.out.println(\"还剩余\" + tickets + \" 张票\");\n        }\n    }\n    public int getTickets() {\n        return tickets;\n    }\n}\npublic class ThreadA extends Thread{\n    private Service service;\n    public ThreadA(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        //一直卖票\n        while(true) {\n            if (service.getTickets() == 0) {\n                break;\n            }\n            service.sale();\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        // 创建两个线程一起卖票\n        Service service = new Service();\n        ThreadA a = new ThreadA(service);\n        a.setName(\"a\");\n        ThreadA b = new ThreadA(service);\n        b.setName(\"b\");\n        a.start();\n        b.start();\n    }\n}\n/**\n结果如下：\n。。。。\nb 卖出 一张票！\na 卖出 一张票！\n还剩余59 张票\n还剩余59 张票\nb 卖出 一张票！\na 卖出 一张票！\n还剩余57 张票\nb 卖出 一张票！\na 卖出 一张票！\n。。。\n还剩余0 张票\n还剩余5 张票\n*/\n\n```\n\n可以看到出现了变量不同步的问题，如何解决这个问题呢？，那就是使用synchronized修饰方法\n\n```java\n// 修改service的sale 和 getTickets 方法如下\npublic class Service {\n    // 模拟一个卖飞机票的场景\n    private int tickets = 100;\n    synchronized public void sale() {\n        if (tickets > 0) {\n            tickets--;\n            System.out.println(Thread.currentThread().getName() + \" 卖出 一张票！\");\n            System.out.println(\"还剩余\" + tickets + \" 张票\");\n        }\n    }\n    synchronized public int getTickets() {\n        return tickets;\n    }\n}\n/**\n结果发现a、b两个线程平等的卖票，并没有发生异常情况\n*/\n```\n\n#### synchronized修饰代码块\n\n除了上面使用的synchronized来修饰函数以外，还可以使用synchronized来修饰需要同步的代码块\n\n```java\n// 修改上例的service类\npublic class Service {\n    // 模拟一个卖飞机票的场景\n    private int tickets = 100;\n    synchronized public void sale() {\n        if (tickets > 0) {\n            tickets--;\n            System.out.println(Thread.currentThread().getName() + \" 卖出 一张票！\");\n            System.out.println(\"还剩余\" + tickets + \" 张票\");\n        }\n    }\n    public int getTickets() {\n        synchronized (this) {\n            return tickets;\n        }\n    }\n}\n/**\n结果：没有异常\n*/\n```\n\n#### synchronized与对象监视器（锁）\n\n在上面的例子中，可以看到当使用synchronized修饰代码块的时候，括号里面的写了一个this，这个this是什么？这个this是对象监视器，什么是对象监视器？对象监视器就相当于是锁，当一个线程去访问synchronized方法时，这个方法相当于被上了一个锁，这个锁是这个对象，也就是this，等到此线程完成任务或者主动释放锁之后其他线程才能再访问这个方法，也就是说如果没有锁就得等待，有锁才可以执行。\n\n#### synchronized与锁的类型\n\nsynchronized修饰的位置不同，锁的类型也不同，具体关系如下表：\n\n| synchronized修饰的位置              | 锁                      |\n| ----------------------------------- | ----------------------- |\n| 修饰方法                            | this对象                |\n| 修饰代码块 例如  synchronized(lock) | 括号中表示的对象（lock) |\n| 修饰静态方法                        | class对象               |\n| 修饰静态代码块                      | class对象               |','线程同步与synchronized的使用什么叫线程同步，线程同步就是多个线程访问一个共享的变量，从而产生共享变量状态的不同的问题，例如：在A线程中修改了count值，在B线程中此时读取到的是修改之后的值，而B线程则不知情，仍然将这个值当做是没有改变之前来处理，这就会出现问题，为了解决这个问题，jav','2019-04-26 05:02:58','2019-04-26 05:02:58',0,1,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(19,'线程间通信','<p>线程之间不仅需要同步，而且需要通信机制。举个例子来说，总共100张票，编号1到100，第一个线程卖1到25张，第二个线程卖26到50张，第三个线程卖51到75张，第四个线程卖76到100张。这个使用线程同步机制很难实现，所以就需要使用线程通信的机制</p>\n<h3 id=\"h3-wait-notify-\"><a name=\"wait() 和 notify() 方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>wait() 和 notify() 方法</h3><p>wait()方法是Object类中的方法，<strong>只能在同步方法或者同步块中调用wait(),执行wait()方法之后，线程释放掉锁。使用notify()来唤醒wait()的线程，而且使用notify()之后是随机唤醒一个线程，并且执行notify()之后并不会马上释放锁，会等notify()所在的代码执行完毕之后才释放掉锁。</strong></p>\n<pre><code class=\"lang-java\">public class Service {\n    public void testMethod(Object lock) {\n        try {\n            synchronized (lock) {\n                System.out.println(&quot;begin wait()&quot;);\n                lock.wait();\n                System.out.println(&quot;end wait()&quot;);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class ThreadA extends Thread{\n    private Object lock;\n    public ThreadA(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.testMethod(lock);\n    }\n}\npublic class ThreadB extends Thread{\n    private Object lock;\n    public ThreadB(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.testMethod(lock);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Object lock = new Object();\n        ThreadA a = new ThreadA(lock);\n        ThreadB b = new ThreadB(lock);\n        a.start();\n        b.start();\n    }\n}\n//  结果  \n//begin wait()\n//begin wait()\n// 程序没有结束，说明wait()之后释放了锁，但是线程还是一直在那等着\n</code></pre>\n<p>还要验证一个结论，方法被notify()之后，不释放锁</p>\n<pre><code class=\"lang-java\">public class Service {\n    public void testMethod(Object lock) {\n        try {\n            synchronized (lock) {\n                System.out.println(&quot;begin wait() ThreadName=&quot; + Thread.currentThread().getName());\n                lock.wait();\n                System.out.println(&quot; end wait() ThreadName=&quot; + Thread.currentThread().getName());\n            }\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    public void synNotifyMethod(Object lock) {\n\n        try {\n            synchronized (lock) {\n                System.out.println(&quot;begin notify() ThreadName=&quot; + Thread.currentThread().getName() + &quot; time=&quot; + System.currentTimeMillis());\n                lock.notify();\n                Thread.sleep(5000);\n                System.out.println(&quot;end notify() ThreadName=&quot; + Thread.currentThread().getName() + &quot; time=&quot; + System.currentTimeMillis());\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class NotifyThread extends Thread{\n    private Object lock;\n    NotifyThread(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.synNotifyMethod(lock);\n    }\n}\npublic class synNotifyMethodThread extends Thread{\n    private Object lock;\n    public synNotifyMethodThread(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.synNotifyMethod(lock);\n    }\n}\npublic class ThreadA extends Thread{\n    private Object lock;\n    public ThreadA(Object lock) {\n        super();\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.testMethod(lock);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Object lock = new Object();\n        ThreadA a = new ThreadA(lock);\n        a.start();\n        NotifyThread notifyThread = new NotifyThread(lock);\n        notifyThread.start();\n        synNotifyMethodThread c = new synNotifyMethodThread(lock);\n        c.start();\n    }\n}\n// 结果\n//begin wait() ThreadName=Thread-0\n//begin notify() ThreadName=Thread-1 time=1555671773053\n//end notify() ThreadName=Thread-1 time=1555671778054\n//begin notify() ThreadName=Thread-2 time=1555671778054\n//end notify() ThreadName=Thread-2 time=1555671783054\n//end wait() ThreadName=Thread-0\n/**\n如果notify()立即释放锁那么可能出现C线程先执行完毕，然而并没有出现，所以说明notify()没有立即释放锁\n*/\n</code></pre>\n<h3 id=\"h3-u751Fu4EA7u8005u6D88u8D39u8005u6A21u5F0F\"><a name=\"生产者消费者模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>生产者消费者模式</h3><p>在等待/通知模式最经典的案例就是生产者消费者模式。生产者消费者模式在使用上有好几种变形的模式</p>\n<h4 id=\"h4--\"><a name=\"一生产一消费：操作栈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一生产一消费：操作栈</h4><pre><code class=\"lang-java\">// 生产者\npublic class P {\n    // 持有栈的引用\n    private MyStack myStack;\n    public P(MyStack myStack) {\n        super();\n        this.myStack = myStack;\n    }\n    public void pushService() {\n        myStack.push();\n    }\n}\n// 消费者\npublic class C {\n    private MyStack myStack;\n    public C(MyStack myStack) {\n        super();\n        this.myStack = myStack;\n    }\n    public void popService() {\n        System.out.println(&quot;pop=&quot; + myStack.pop());\n    }\n}\npublic class P_Thread extends Thread{\n    private P p;\n    public P_Thread(P p) {\n        this.p = p;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            p.pushService();\n        }\n    }\n}\npublic class C_Thread extends Thread{\n    private C c;\n    public C_Thread(C c){\n        this.c = c;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            c.popService();\n        }\n    }\n}\n// 栈\npublic class MyStack {\n    private List list = new ArrayList();\n    // 进栈是同步的\n    synchronized public void push() {\n        try {\n            // 最大容量为1\n            if (list.size() == 1) {\n                this.wait();\n            }\n            list.add(&quot;anyString =&quot; + Math.random());\n            this.notify();\n            System.out.println(&quot;push=&quot; + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    //出栈也是同步的\n    synchronized public String pop() {\n        String returnValue = &quot;&quot;;\n        try {\n            if (list.size() == 0) {\n                System.out.println(&quot;pop 操作中的：&quot; + Thread.currentThread().getName() + &quot; 线程呈 wait状态&quot;);\n                this.wait();\n            }\n            returnValue = &quot;&quot;  + list.get(0);\n            list.remove(0);\n            this.notify();\n            System.out.println(&quot;pop = &quot; + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return returnValue;\n    }\n}\npublic class Run {\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p = new P(myStack);\n        C c = new C(myStack);\n        P_Thread pThread = new P_Thread(p);\n        C_Thread rTHread = new C_Thread(c);\n        pThread.start();\n        rTHread.start();\n    }\n}\n/**\n....\npop=anyString =0.632213572286416\npop 操作中的：Thread-1 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.4144763421023485\npop 操作中的：Thread-1 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.8213303342393905\npop 操作中的：Thread-1 线程呈 wait状态\npush=1\npop = 0\n....\n*/\n</code></pre>\n<h4 id=\"h4--\"><a name=\"一生产多消费：操作栈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一生产多消费：操作栈</h4><pre><code class=\"lang-java\">// 将上面的栈的类重写为下面的就可以了\npublic class MyStack {\n    private List list = new ArrayList();\n    synchronized public void push() {\n        try {\n            while (list.size() == 1) {\n                this.wait();\n            }\n            list.add(&quot;anyString =&quot; + Math.random());\n            this.notifyAll();\n            System.out.println(&quot;push=&quot; + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    synchronized public String pop() {\n        String returnValue = &quot;&quot;;\n        try {\n            // 这里吧if修改成为了while是因为如果还是if条件的话，当次线程使用wait()会释放锁，另外一个线程就会执行，如果是if的话不能保证后面执行的是在list.size()!=0的条件下执行的,再使用while循环的条件检查一次\n            while (list.size() == 0) {\n                System.out.println(&quot;pop 操作中的：&quot; + Thread.currentThread().getName() + &quot; 线程呈 wait状态&quot;);\n                this.wait();\n            }\n            returnValue = &quot;&quot;  + list.get(0);\n            list.remove(0);\n            this.notifyAll();\n            System.out.println(&quot;pop = &quot; + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return returnValue;\n    }\n\n}\npublic class Run {\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p = new P(myStack);\n        C r1 = new C(myStack);\n        C r2 = new C(myStack);\n        C r3 = new C(myStack);\n        C r4 = new C(myStack);\n        C r5 = new C(myStack);\n        P_Thread pThread = new P_Thread(p);\n        pThread.start();\n        C_Thread cThread1 = new C_Thread(r1);\n        C_Thread cThread2 = new C_Thread(r2);\n        C_Thread cThread3 = new C_Thread(r3);\n        C_Thread cThread4 = new C_Thread(r4);\n        C_Thread cThread5 = new C_Thread(r5);\n        cThread1.start();\n        cThread2.start();\n        cThread3.start();\n        cThread4.start();\n        cThread5.start();\n    }\n}\n/**\n结果\npop=anyString =0.62873287441692\npop 操作中的：Thread-1 线程呈 wait状态\npop 操作中的：Thread-2 线程呈 wait状态\npop 操作中的：Thread-3 线程呈 wait状态\npop 操作中的：Thread-4 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.5384005101639541\npop 操作中的：Thread-5 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.643314368964546\npop 操作中的：Thread-4 线程呈 wait状态\npop 操作中的：Thread-3 线程呈 wait状态\n*/\n</code></pre>\n<h4 id=\"h4--\"><a name=\"多生产一消费：操作栈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>多生产一消费：操作栈</h4><pre><code class=\"lang-java\">// 修改Run类\npublic class Run{\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p1 = new P(myStack);\n        P p2 = new P(myStack);\n        P p3 = new P(myStack);\n        P p4 = new P(myStack);\n        P p5 = new P(myStack);\n        P p6 = new P(myStack);\n        P_Thread pThread1 = new P_Thread(p1);\n        P_Thread pThread2 = new P_Thread(p2);\n        P_Thread pThread3 = new P_Thread(p3);\n        P_Thread pThread4 = new P_Thread(p4);\n        P_Thread pThread5 = new P_Thread(p5);\n        P_Thread pThread6 = new P_Thread(p6);\n        pThread1.start();\n        pThread2.start();\n        pThread3.start();\n        pThread4.start();\n        pThread5.start();\n        pThread6.start();\n        C c1 = new C(myStack);\n        C_Thread cThread = new C_Thread(c1);\n        cThread.start();\n    }\n}\n/**\npush=1\npop = 0\npop=anyString =0.5780693574176647\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.07774474768334627\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.757967773681697\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.648124896285258\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.833150449656568\nProcess finished with exit code -1\n*/\n</code></pre>\n<h4 id=\"h4--\"><a name=\"多生产多消费：操作栈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>多生产多消费：操作栈</h4><pre><code class=\"lang-java\">// 修改Run类\npublic class Run {\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p1 = new P(myStack);\n        P p2 = new P(myStack);\n        P p3 = new P(myStack);\n        P p4 = new P(myStack);\n        P p5 = new P(myStack);\n        P p6 = new P(myStack);\n        P_Thread pThread1 = new P_Thread(p1);\n        P_Thread pThread2 = new P_Thread(p2);\n        P_Thread pThread3 = new P_Thread(p3);\n        P_Thread pThread4 = new P_Thread(p4);\n        P_Thread pThread5 = new P_Thread(p5);\n        P_Thread pThread6 = new P_Thread(p6);\n        pThread1.start();\n        pThread2.start();\n        pThread3.start();\n        pThread4.start();\n        pThread5.start();\n        pThread6.start();\n        C r1 = new C(myStack);\n        C r2 = new C(myStack);\n        C r3 = new C(myStack);\n        C r4 = new C(myStack);\n        C r5 = new C(myStack);\n        C r6 = new C(myStack);\n        C r7 = new C(myStack);\n        C r8 = new C(myStack);\n        C_Thread cThread1 = new C_Thread(r1);\n        C_Thread cThread2 = new C_Thread(r2);\n        C_Thread cThread3 = new C_Thread(r3);\n        C_Thread cThread4 = new C_Thread(r4);\n        C_Thread cThread5 = new C_Thread(r5);\n        C_Thread cThread6 = new C_Thread(r6);\n        C_Thread cThread7 = new C_Thread(r7);\n        C_Thread cThread8 = new C_Thread(r8);\n        cThread1.start();\n        cThread2.start();\n        cThread3.start();\n        cThread4.start();\n        cThread5.start();\n        cThread6.start();\n        cThread7.start();\n        cThread8.start();\n    }\n}\n/**\npop 操作中的：Thread-6 线程呈 wait状态\npop 操作中的：Thread-12 线程呈 wait状态\npop 操作中的：Thread-10 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.5901748948498622\npop 操作中的：Thread-8 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.21791547367562114\npop 操作中的：Thread-11 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.3699275254114449\npop 操作中的：Thread-10 线程呈 wait状态\npop 操作中的：Thread-12 线程呈 wait状态\npop 操作中的：Thread-6 线程呈 wait状态\n\n*/\n</code></pre>\n<h3 id=\"h3-join-\"><a name=\"join方法的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>join方法的使用</h3><p>在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线往往将早于子线程结束之前结束。这时，如果主线想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。</p>\n<pre><code class=\"lang-java\">public class MyThread extends Thread{\n    @Override\n    public void run() {\n\n        try {\n            int secondValue = (int) (Math.random() * 10000);\n            System.out.println(secondValue);\n            Thread.sleep(secondValue);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        MyThread threadTest = new MyThread();\n        threadTest.start();\n        try {\n            // 这里如果使用threadTest.sleep() 无论填睡眠多少秒都不合适，而join方法可以一直阻塞到该线程结束\n            threadTest.join();\n            System.out.println(&quot;对象执行完毕之后我再执行&quot;);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n/**\n3500\n对象执行完毕之后我再执行\n*/\n</code></pre>\n<h4 id=\"h4-join-sleep-\"><a name=\"join方法和sleep方法的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>join方法和sleep方法的区别</h4><p>join方法内部使用的是wait方法，而我们知道wait方法在使用的时候是会释放锁的，而sleep方法则不会释放锁。</p>\n<h3 id=\"h3-threadlocal-\"><a name=\"ThreadLocal类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ThreadLocal类</h3><p>ThreadLocal类是jdk提供的一个用于存储线程本地变量的类，这个类会根据不同的线程来存储不同的变量，也就是说不同的线程访问这个类的时候，获取的都是独一无二的。</p>','线程之间不仅需要同步，而且需要通信机制。举个例子来说，总共100张票，编号1到100，第一个线程卖1到25张，第二个线程卖26到50张，第三个线程卖51到75张，第四个线程卖76到100张。这个使用线程同步机制很难实现，所以就需要使用线程通信的机制\n\n### wait() 和 notify() 方法\n\nwait()方法是Object类中的方法，**只能在同步方法或者同步块中调用wait(),执行wait()方法之后，线程释放掉锁。使用notify()来唤醒wait()的线程，而且使用notify()之后是随机唤醒一个线程，并且执行notify()之后并不会马上释放锁，会等notify()所在的代码执行完毕之后才释放掉锁。**\n\n```java\npublic class Service {\n    public void testMethod(Object lock) {\n        try {\n            synchronized (lock) {\n                System.out.println(\"begin wait()\");\n                lock.wait();\n                System.out.println(\"end wait()\");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class ThreadA extends Thread{\n    private Object lock;\n    public ThreadA(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.testMethod(lock);\n    }\n}\npublic class ThreadB extends Thread{\n    private Object lock;\n    public ThreadB(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.testMethod(lock);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Object lock = new Object();\n        ThreadA a = new ThreadA(lock);\n        ThreadB b = new ThreadB(lock);\n        a.start();\n        b.start();\n    }\n}\n//  结果  \n//begin wait()\n//begin wait()\n// 程序没有结束，说明wait()之后释放了锁，但是线程还是一直在那等着\n```\n\n还要验证一个结论，方法被notify()之后，不释放锁\n\n```java\npublic class Service {\n    public void testMethod(Object lock) {\n        try {\n            synchronized (lock) {\n                System.out.println(\"begin wait() ThreadName=\" + Thread.currentThread().getName());\n                lock.wait();\n                System.out.println(\" end wait() ThreadName=\" + Thread.currentThread().getName());\n            }\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    public void synNotifyMethod(Object lock) {\n\n        try {\n            synchronized (lock) {\n                System.out.println(\"begin notify() ThreadName=\" + Thread.currentThread().getName() + \" time=\" + System.currentTimeMillis());\n                lock.notify();\n                Thread.sleep(5000);\n                System.out.println(\"end notify() ThreadName=\" + Thread.currentThread().getName() + \" time=\" + System.currentTimeMillis());\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class NotifyThread extends Thread{\n    private Object lock;\n    NotifyThread(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.synNotifyMethod(lock);\n    }\n}\npublic class synNotifyMethodThread extends Thread{\n    private Object lock;\n    public synNotifyMethodThread(Object lock) {\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.synNotifyMethod(lock);\n    }\n}\npublic class ThreadA extends Thread{\n    private Object lock;\n    public ThreadA(Object lock) {\n        super();\n        this.lock = lock;\n    }\n    @Override\n    public void run() {\n        Service service = new Service();\n        service.testMethod(lock);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Object lock = new Object();\n        ThreadA a = new ThreadA(lock);\n        a.start();\n        NotifyThread notifyThread = new NotifyThread(lock);\n        notifyThread.start();\n        synNotifyMethodThread c = new synNotifyMethodThread(lock);\n        c.start();\n    }\n}\n// 结果\n//begin wait() ThreadName=Thread-0\n//begin notify() ThreadName=Thread-1 time=1555671773053\n//end notify() ThreadName=Thread-1 time=1555671778054\n//begin notify() ThreadName=Thread-2 time=1555671778054\n//end notify() ThreadName=Thread-2 time=1555671783054\n//end wait() ThreadName=Thread-0\n/**\n如果notify()立即释放锁那么可能出现C线程先执行完毕，然而并没有出现，所以说明notify()没有立即释放锁\n*/\n```\n\n### 生产者消费者模式\n\n在等待/通知模式最经典的案例就是生产者消费者模式。生产者消费者模式在使用上有好几种变形的模式\n\n#### 一生产一消费：操作栈\n\n```java\n// 生产者\npublic class P {\n    // 持有栈的引用\n    private MyStack myStack;\n    public P(MyStack myStack) {\n        super();\n        this.myStack = myStack;\n    }\n    public void pushService() {\n        myStack.push();\n    }\n}\n// 消费者\npublic class C {\n    private MyStack myStack;\n    public C(MyStack myStack) {\n        super();\n        this.myStack = myStack;\n    }\n    public void popService() {\n        System.out.println(\"pop=\" + myStack.pop());\n    }\n}\npublic class P_Thread extends Thread{\n    private P p;\n    public P_Thread(P p) {\n        this.p = p;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            p.pushService();\n        }\n    }\n}\npublic class C_Thread extends Thread{\n    private C c;\n    public C_Thread(C c){\n        this.c = c;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            c.popService();\n        }\n    }\n}\n// 栈\npublic class MyStack {\n    private List list = new ArrayList();\n    // 进栈是同步的\n    synchronized public void push() {\n        try {\n            // 最大容量为1\n            if (list.size() == 1) {\n                this.wait();\n            }\n            list.add(\"anyString =\" + Math.random());\n            this.notify();\n            System.out.println(\"push=\" + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    //出栈也是同步的\n    synchronized public String pop() {\n        String returnValue = \"\";\n        try {\n            if (list.size() == 0) {\n                System.out.println(\"pop 操作中的：\" + Thread.currentThread().getName() + \" 线程呈 wait状态\");\n                this.wait();\n            }\n            returnValue = \"\"  + list.get(0);\n            list.remove(0);\n            this.notify();\n            System.out.println(\"pop = \" + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return returnValue;\n    }\n}\npublic class Run {\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p = new P(myStack);\n        C c = new C(myStack);\n        P_Thread pThread = new P_Thread(p);\n        C_Thread rTHread = new C_Thread(c);\n        pThread.start();\n        rTHread.start();\n    }\n}\n/**\n....\npop=anyString =0.632213572286416\npop 操作中的：Thread-1 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.4144763421023485\npop 操作中的：Thread-1 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.8213303342393905\npop 操作中的：Thread-1 线程呈 wait状态\npush=1\npop = 0\n....\n*/\n```\n\n#### 一生产多消费：操作栈\n\n```java\n// 将上面的栈的类重写为下面的就可以了\npublic class MyStack {\n    private List list = new ArrayList();\n    synchronized public void push() {\n        try {\n            while (list.size() == 1) {\n                this.wait();\n            }\n            list.add(\"anyString =\" + Math.random());\n            this.notifyAll();\n            System.out.println(\"push=\" + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    synchronized public String pop() {\n        String returnValue = \"\";\n        try {\n            // 这里吧if修改成为了while是因为如果还是if条件的话，当次线程使用wait()会释放锁，另外一个线程就会执行，如果是if的话不能保证后面执行的是在list.size()!=0的条件下执行的,再使用while循环的条件检查一次\n            while (list.size() == 0) {\n                System.out.println(\"pop 操作中的：\" + Thread.currentThread().getName() + \" 线程呈 wait状态\");\n                this.wait();\n            }\n            returnValue = \"\"  + list.get(0);\n            list.remove(0);\n            this.notifyAll();\n            System.out.println(\"pop = \" + list.size());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return returnValue;\n    }\n\n}\npublic class Run {\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p = new P(myStack);\n        C r1 = new C(myStack);\n        C r2 = new C(myStack);\n        C r3 = new C(myStack);\n        C r4 = new C(myStack);\n        C r5 = new C(myStack);\n        P_Thread pThread = new P_Thread(p);\n        pThread.start();\n        C_Thread cThread1 = new C_Thread(r1);\n        C_Thread cThread2 = new C_Thread(r2);\n        C_Thread cThread3 = new C_Thread(r3);\n        C_Thread cThread4 = new C_Thread(r4);\n        C_Thread cThread5 = new C_Thread(r5);\n        cThread1.start();\n        cThread2.start();\n        cThread3.start();\n        cThread4.start();\n        cThread5.start();\n    }\n}\n/**\n结果\npop=anyString =0.62873287441692\npop 操作中的：Thread-1 线程呈 wait状态\npop 操作中的：Thread-2 线程呈 wait状态\npop 操作中的：Thread-3 线程呈 wait状态\npop 操作中的：Thread-4 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.5384005101639541\npop 操作中的：Thread-5 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.643314368964546\npop 操作中的：Thread-4 线程呈 wait状态\npop 操作中的：Thread-3 线程呈 wait状态\n*/\n```\n\n#### 多生产一消费：操作栈\n\n```java\n// 修改Run类\npublic class Run{\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p1 = new P(myStack);\n        P p2 = new P(myStack);\n        P p3 = new P(myStack);\n        P p4 = new P(myStack);\n        P p5 = new P(myStack);\n        P p6 = new P(myStack);\n        P_Thread pThread1 = new P_Thread(p1);\n        P_Thread pThread2 = new P_Thread(p2);\n        P_Thread pThread3 = new P_Thread(p3);\n        P_Thread pThread4 = new P_Thread(p4);\n        P_Thread pThread5 = new P_Thread(p5);\n        P_Thread pThread6 = new P_Thread(p6);\n        pThread1.start();\n        pThread2.start();\n        pThread3.start();\n        pThread4.start();\n        pThread5.start();\n        pThread6.start();\n        C c1 = new C(myStack);\n        C_Thread cThread = new C_Thread(c1);\n        cThread.start();\n    }\n}\n/**\npush=1\npop = 0\npop=anyString =0.5780693574176647\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.07774474768334627\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.757967773681697\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.648124896285258\npop 操作中的：Thread-6 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.833150449656568\nProcess finished with exit code -1\n*/\n```\n\n#### 多生产多消费：操作栈\n\n```java\n// 修改Run类\npublic class Run {\n    public static void main(String[] args) {\n        MyStack myStack = new MyStack();\n        P p1 = new P(myStack);\n        P p2 = new P(myStack);\n        P p3 = new P(myStack);\n        P p4 = new P(myStack);\n        P p5 = new P(myStack);\n        P p6 = new P(myStack);\n        P_Thread pThread1 = new P_Thread(p1);\n        P_Thread pThread2 = new P_Thread(p2);\n        P_Thread pThread3 = new P_Thread(p3);\n        P_Thread pThread4 = new P_Thread(p4);\n        P_Thread pThread5 = new P_Thread(p5);\n        P_Thread pThread6 = new P_Thread(p6);\n        pThread1.start();\n        pThread2.start();\n        pThread3.start();\n        pThread4.start();\n        pThread5.start();\n        pThread6.start();\n        C r1 = new C(myStack);\n        C r2 = new C(myStack);\n        C r3 = new C(myStack);\n        C r4 = new C(myStack);\n        C r5 = new C(myStack);\n        C r6 = new C(myStack);\n        C r7 = new C(myStack);\n        C r8 = new C(myStack);\n        C_Thread cThread1 = new C_Thread(r1);\n        C_Thread cThread2 = new C_Thread(r2);\n        C_Thread cThread3 = new C_Thread(r3);\n        C_Thread cThread4 = new C_Thread(r4);\n        C_Thread cThread5 = new C_Thread(r5);\n        C_Thread cThread6 = new C_Thread(r6);\n        C_Thread cThread7 = new C_Thread(r7);\n        C_Thread cThread8 = new C_Thread(r8);\n        cThread1.start();\n        cThread2.start();\n        cThread3.start();\n        cThread4.start();\n        cThread5.start();\n        cThread6.start();\n        cThread7.start();\n        cThread8.start();\n    }\n}\n/**\npop 操作中的：Thread-6 线程呈 wait状态\npop 操作中的：Thread-12 线程呈 wait状态\npop 操作中的：Thread-10 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.5901748948498622\npop 操作中的：Thread-8 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.21791547367562114\npop 操作中的：Thread-11 线程呈 wait状态\npush=1\npop = 0\npop=anyString =0.3699275254114449\npop 操作中的：Thread-10 线程呈 wait状态\npop 操作中的：Thread-12 线程呈 wait状态\npop 操作中的：Thread-6 线程呈 wait状态\n\n*/\n```\n\n### join方法的使用\n\n在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线往往将早于子线程结束之前结束。这时，如果主线想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。\n\n```java\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n\n        try {\n            int secondValue = (int) (Math.random() * 10000);\n            System.out.println(secondValue);\n            Thread.sleep(secondValue);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        MyThread threadTest = new MyThread();\n        threadTest.start();\n        try {\n            // 这里如果使用threadTest.sleep() 无论填睡眠多少秒都不合适，而join方法可以一直阻塞到该线程结束\n            threadTest.join();\n            System.out.println(\"对象执行完毕之后我再执行\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n/**\n3500\n对象执行完毕之后我再执行\n*/\n```\n\n#### join方法和sleep方法的区别\n\njoin方法内部使用的是wait方法，而我们知道wait方法在使用的时候是会释放锁的，而sleep方法则不会释放锁。\n\n### ThreadLocal类\n\nThreadLocal类是jdk提供的一个用于存储线程本地变量的类，这个类会根据不同的线程来存储不同的变量，也就是说不同的线程访问这个类的时候，获取的都是独一无二的。','线程之间不仅需要同步，而且需要通信机制。举个例子来说，总共100张票，编号1到100，第一个线程卖1到25张，第二个线程卖26到50张，第三个线程卖51到75张，第四个线程卖76到100张。这个使用线程同步机制很难实现，所以就需要使用线程通信的机制\nwait() 和 notify() 方法wait(','2019-04-26 05:06:20','2019-04-26 05:06:20',0,1,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(20,'FastDFS安装教程','<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和均衡负载的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>\n<p>安装步骤：</p>\n<p>准备步骤：gcc  + fastdfs + libfastcommonV1.0.7.tar.gz + nginx 安装</p>\n<ol>\n<li><p>解压libfastcommonV1.0.7.tar.gz</p>\n<p>这里我解压到/usr/fastdfs 这个目录下，然后进行编译安装。</p>\n<pre><code class=\"lang-shell\">## 进入到安装这个的目录\n./make.sh\n./make.sh install\n</code></pre>\n<p>安装完毕之后会在/usr/lib64 文件夹中生成一系列的文件，因为这个文件安装到了/usr/lib64中去，但是FastDFS主程序设置的lib目录时/usr/local/lib,所以需要建立软连接。</p>\n<pre><code class=\"lang-shell\"># ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so\n# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so\n# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so\n# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so\n</code></pre>\n</li><li><p>安装和编译FastDFS主程序</p>\n<p>首先，需要将压缩包上传到服务器中去，这里我安装的是/usr/fastdfs/FastDFS这个目录下面去，然后，编译和安装。</p>\n<pre><code class=\"lang-shell\">./make.sh \n./make.sh install\n</code></pre>\n<p>由于FastDFS服务脚本中设置的bin目录是/usr/local/bin,但实际命令安装到/usr/bin 的目录下</p>\n<p>两种方式：</p>\n<ul>\n<li><p>修改FastDFS服务脚本中相应的命令路径，也就是把/etc/init.d/fdfs_storaged 和 /etc/init.d/fdfs_tracker两个脚本中的/user/lcoal/bin修改成/usr/bin</p>\n<pre><code class=\"lang-shell\"># 使用vim命令编辑这两个文件\n# %s+/usr/local/bin+/usr/bin\n# 注意这两个文件都需要修改，否者会出现错误\n</code></pre>\n</li><li><p>第二种方式就是建立软连接</p>\n<pre><code class=\"lang-shell\"># ln -s /usr/bin/fdfs_trackerd   /usr/local/bin\n# ln -s /usr/bin/fdfs_storaged   /usr/local/bin\n# ln -s /usr/bin/stop.sh         /usr/local/bin\n# ln -s /usr/bin/restart.sh      /usr/local/bin\n</code></pre>\n</li></ul>\n</li><li><p>配置FastDFS跟踪器（tracker）</p>\n<p>安装FastDFS软件的时候会在/etc/fdfs 中生成配置文件例子</p>\n<ul>\n<li>进入 /etc/fdfs，复制 FastDFS 跟踪器样例配置文件 tracker.conf.sample，并重命名为 tracker.conf。</li></ul>\n<pre><code class=\"lang-shell\"># cd /etc/fdfs\n# cp tracker.conf.sample tracker.conf\n# vim tracker.conf\n</code></pre>\n<ul>\n<li>编辑tracker.conf ，标红的需要修改下，其它的默认即可。</li></ul>\n<pre><code class=\"lang-shell\"># 配置文件是否不生效，false 为生效\ndisabled=false\n\n# 提供服务的端口\n# 这里需要防火墙放通这个端口\nport=22122\n\n# Tracker 数据和日志目录地址(这里这个目录必须要存在)\nbase_path=/home/fastdfs/tracker\n\n# HTTP 服务端口  这里需要和nginx 配合的时候就是nginx监听的web端口\nhttp.server_port=8081\n</code></pre>\n<ul>\n<li><p>启动tracker</p>\n<p>初次成功启动，会在 /home/fdfsdfs/tracker (配置的base_path)下创建 data、logs 两个目录。</p>\n</li></ul>\n<pre><code class=\"lang-shell\">可以用这种方式启动\n# /etc/init.d/fdfs_trackerd start\n\n也可以用这种方式启动，前提是上面创建了软链接，后面都用这种方式\n# service fdfs_trackerd start\n</code></pre>\n<ul>\n<li>还有就是tracker的其他命令，以及怎么查看日志文件和其他的东西</li></ul>\n</li><li><p>配置FastDFS存储（storage)</p>\n<p>进入/etc/fdfs目录，复制FastDFS存储器配置文件storage.conf.sample，并重命名为 storage.conf</p>\n<pre><code class=\"lang-shell\"># cd /etc/fdfs\n# cp storage.conf.sample storage.conf\n# vim storage.conf\n</code></pre>\n<ul>\n<li>编辑storage.conf  具体查看服务器上的配置</li></ul>\n<pre><code class=\"lang-shell\"># 配置文件是否不生效，false 为生效\ndisabled=false\n# 指定此 storage server 所在 组(卷)\ngroup_name=group1\n# storage server 服务端口 这个端口需要防火墙放通\nport=23000\n# 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳)\nheart_beat_interval=30\n# Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)\nbase_path=/home/fastdfs/storage\n# 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。\nstore_path_count=1\n# 逐一配置 store_path_count 个路径，索引号基于 0。\n# 如果不配置 store_path0，那它就和 base_path 对应的路径一样。\nstore_path0=/home/fastdfs\n# FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 \n# 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。\nsubdir_count_per_path=256\n# tracker_server 的列表 ，会主动连接 tracker_server\n# 有多个 tracker server 时，每个 tracker server 写一行\ntracker_server=118.89.247.210:22122\n# 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。\nsync_start_time=00:00\nsync_end_time=23:59\n# 访问端口\nhttp.server_port=8888\n</code></pre>\n<ul>\n<li><p>启动storage</p>\n<p>启动Storage前确保Tracker是启动的。初次启动成功，会在 /ljzsg/fastdfs/storage 目录下创建 data、 logs 两个目录。</p>\n</li></ul>\n<pre><code class=\"lang-shell\">可以用这种方式启动\n# /etc/init.d/fdfs_storaged start\n\n也可以用这种方式，后面都用这种\n# service fdfs_storaged start\n</code></pre>\n</li><li><p>nginx_fastdfs 模块的安装</p>\n<p>首先需要安装几个依赖的库</p>\n<pre><code class=\"lang-shell\">apt install pcre \napt install pcre-devel\napt install zlib\napt install zlib-devel\n</code></pre>\n<p>然后把fastdfs-nginx-module模块上传到linux服务器上面并解压到指定目录下面去</p>\n<pre><code class=\"lang-shell\"># tar zxf fastdfs-nginx-module_v1.16.tar.gz -C /usr/fastdfs/\n\n# 这里随便解压到一个目录都是可以的\n</code></pre>\n<p>安装完成之后进入module下面的src目录下面去</p>\n<pre><code class=\"lang-shell\"># cd /usr/fastdfs\n</code></pre>\n<p>编辑配置文件config</p>\n<pre><code class=\"lang-shell\"># vim /usr/fastdfs/fastdfs-nginx-module/src/config\n# 修改内容 修改成这个样子\nngx_addon_name=ngx_http_fastdfs_module\nHTTP_MODULES=&quot;$HTTP_MODULES ngx_http_fastdfs_module&quot;\nNGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fastdfs_module.c&quot;\nCORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;\nCORE_LIBS=&quot;$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient&quot;\nCFLAGS=&quot;$CFLAGS -D_FILE_OFFSET_BITS=64 -DFDFS_OUTPUT_CHUNK_SIZE=&#39;256*1024&#39; -DFDFS_MOD_CONF_FILENAME=&#39;\\&quot;/etc/fdfs/mod_fastdfs.conf\\&quot;&#39;&quot;\n</code></pre>\n<p>FastDFS与nginx集成，如果已经安装了nginx，那么就只需要在原来nginx的模块中添加一个fastdfs模块</p>\n<pre><code class=\"lang-shell\">#  首先需要进入到以前安装的nginx的目录中去\n# 执行 ./configure --add-module=fastdfs-nginx-module/src/\n# 重新编译nginx make\n# 重新执行编译之后的nginx 千万不要再重新安装，只需要将生成的二进制文件进行替换就行了\n# cp /usr/nginx-xxx/objs/nginx /usr/local/nginx/sbin/nginx\n</code></pre>\n<p>然后将模块的配置文件复制到/etc/fdfs/下面</p>\n<pre><code class=\"lang-shell\">cp fastdfs-nginx模块目录/src/mod_fastdfs.conf /etc/fdfs/\n</code></pre>\n<p>编辑这个配置文件</p>\n<pre><code class=\"lang-shell\"># 修改内容：比如连接超时时间、跟踪器路径等等、\nconnect_timeout=10   #  10 秒\ntracker_server=url   #  tracker所在的ip地址加上端口号\nurl_have_group_name=true   #  改为true\nstore_path0=storage目录   #  这里填的是配置storage配置的目录路径\n</code></pre>\n<p>复制FastDFS中的两个配置文件到 /etc/fdfs/中去</p>\n<p><img src=\"https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zCtaaAU9U4AAGGeh2JHHs430.png\" alt=\"\"></p>\n<pre><code class=\"lang-shell\"># cp FastDFS安装目录/conf/http.conf mime.types /etc/fdfs/\n</code></pre>\n<p>创建一个软连接,在/fastdfs/storage 文件存储目录下创建软连接，将其连接到实际存放数据的目录</p>\n<pre><code class=\"lang-shell\">ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00  \n# 这里软连接中的fastdfs目录根据自己配置文件中配置的目录来的，不一定是上面这样的\n# 为什么创建这个软连接诶，就是为了与下面的nginx 的匹配规则对应\n# 也就是说如果URL中访问到了M00  目录就会去到storage/data/ 这个目录下去找需要的文件\n</code></pre>\n<p>修改nginx配置文件</p>\n<pre><code class=\"lang-shell\">server {\n            listen       8888;  #这里注意端口访问的时候要加上 这里端口号和配置storage中的http.server_port=8888 是一样的\n            server_name  localhost;\n            location ~/group[0-9]/M00 {\n                ngx_fastdfs_module;\n            }\n}\n</code></pre>\n<p>重新启动nginx就OK了</p>\n</li></ol>','FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和均衡负载的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。\n\n安装步骤：\n\n准备步骤：gcc  + fastdfs + libfastcommonV1.0.7.tar.gz + nginx 安装\n\n1. 解压libfastcommonV1.0.7.tar.gz\n\n   这里我解压到/usr/fastdfs 这个目录下，然后进行编译安装。\n\n   ```shell\n   ## 进入到安装这个的目录\n   ./make.sh\n   ./make.sh install\n   ```\n\n   安装完毕之后会在/usr/lib64 文件夹中生成一系列的文件，因为这个文件安装到了/usr/lib64中去，但是FastDFS主程序设置的lib目录时/usr/local/lib,所以需要建立软连接。\n\n   ```shell\n   # ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so\n   # ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so\n   # ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so\n   # ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so \n   ```\n\n2. 安装和编译FastDFS主程序\n\n   首先，需要将压缩包上传到服务器中去，这里我安装的是/usr/fastdfs/FastDFS这个目录下面去，然后，编译和安装。\n\n   ```shell\n   ./make.sh \n   ./make.sh install\n   ```\n\n   由于FastDFS服务脚本中设置的bin目录是/usr/local/bin,但实际命令安装到/usr/bin 的目录下\n\n   两种方式：\n\n   - 修改FastDFS服务脚本中相应的命令路径，也就是把/etc/init.d/fdfs_storaged 和 /etc/init.d/fdfs_tracker两个脚本中的/user/lcoal/bin修改成/usr/bin\n\n     ```shell\n     # 使用vim命令编辑这两个文件\n     # %s+/usr/local/bin+/usr/bin\n     # 注意这两个文件都需要修改，否者会出现错误\n     ```\n\n   - 第二种方式就是建立软连接\n\n     ```shell\n     # ln -s /usr/bin/fdfs_trackerd   /usr/local/bin\n     # ln -s /usr/bin/fdfs_storaged   /usr/local/bin\n     # ln -s /usr/bin/stop.sh         /usr/local/bin\n     # ln -s /usr/bin/restart.sh      /usr/local/bin\n     ```\n\n3. 配置FastDFS跟踪器（tracker）\n\n   安装FastDFS软件的时候会在/etc/fdfs 中生成配置文件例子\n\n   - 进入 /etc/fdfs，复制 FastDFS 跟踪器样例配置文件 tracker.conf.sample，并重命名为 tracker.conf。\n\n   ```shell\n   # cd /etc/fdfs\n   # cp tracker.conf.sample tracker.conf\n   # vim tracker.conf\n   ```\n\n   - 编辑tracker.conf ，标红的需要修改下，其它的默认即可。\n\n   ```shell\n   # 配置文件是否不生效，false 为生效\n   disabled=false\n   \n   # 提供服务的端口\n   # 这里需要防火墙放通这个端口\n   port=22122\n   \n   # Tracker 数据和日志目录地址(这里这个目录必须要存在)\n   base_path=/home/fastdfs/tracker\n    \n   # HTTP 服务端口  这里需要和nginx 配合的时候就是nginx监听的web端口\n   http.server_port=8081\n   ```\n\n   - 启动tracker\n\n     初次成功启动，会在 /home/fdfsdfs/tracker (配置的base_path)下创建 data、logs 两个目录。\n\n   ```shell\n   可以用这种方式启动\n   # /etc/init.d/fdfs_trackerd start\n   \n   也可以用这种方式启动，前提是上面创建了软链接，后面都用这种方式\n   # service fdfs_trackerd start\n   ```\n\n   - 还有就是tracker的其他命令，以及怎么查看日志文件和其他的东西\n\n4. 配置FastDFS存储（storage)\n\n   进入/etc/fdfs目录，复制FastDFS存储器配置文件storage.conf.sample，并重命名为 storage.conf\n\n   ```shell\n   # cd /etc/fdfs\n   # cp storage.conf.sample storage.conf\n   # vim storage.conf\n   ```\n\n   - 编辑storage.conf  具体查看服务器上的配置\n\n   ```shell\n   # 配置文件是否不生效，false 为生效\n   disabled=false\n   # 指定此 storage server 所在 组(卷)\n   group_name=group1\n   # storage server 服务端口 这个端口需要防火墙放通\n   port=23000\n   # 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳)\n   heart_beat_interval=30\n   # Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)\n   base_path=/home/fastdfs/storage\n   # 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。\n   store_path_count=1\n   # 逐一配置 store_path_count 个路径，索引号基于 0。\n   # 如果不配置 store_path0，那它就和 base_path 对应的路径一样。\n   store_path0=/home/fastdfs\n   # FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 \n   # 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。\n   subdir_count_per_path=256\n   # tracker_server 的列表 ，会主动连接 tracker_server\n   # 有多个 tracker server 时，每个 tracker server 写一行\n   tracker_server=118.89.247.210:22122\n   # 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。\n   sync_start_time=00:00\n   sync_end_time=23:59\n   # 访问端口\n   http.server_port=8888\n   ```\n\n   - 启动storage\n\n     启动Storage前确保Tracker是启动的。初次启动成功，会在 /ljzsg/fastdfs/storage 目录下创建 data、 logs 两个目录。\n\n   ```shell\n   可以用这种方式启动\n   # /etc/init.d/fdfs_storaged start\n   \n   也可以用这种方式，后面都用这种\n   # service fdfs_storaged start\n   ```\n\n5. nginx_fastdfs 模块的安装\n\n   首先需要安装几个依赖的库\n\n   ```shell\n   apt install pcre \n   apt install pcre-devel\n   apt install zlib\n   apt install zlib-devel\n   ```\n\n   然后把fastdfs-nginx-module模块上传到linux服务器上面并解压到指定目录下面去\n\n   ```shell\n   # tar zxf fastdfs-nginx-module_v1.16.tar.gz -C /usr/fastdfs/\n   \n   # 这里随便解压到一个目录都是可以的\n   ```\n\n   安装完成之后进入module下面的src目录下面去\n\n   ```shell\n   # cd /usr/fastdfs\n   ```\n\n   编辑配置文件config\n\n   ```shell\n   # vim /usr/fastdfs/fastdfs-nginx-module/src/config\n   # 修改内容 修改成这个样子\n   ngx_addon_name=ngx_http_fastdfs_module\n   HTTP_MODULES=\"$HTTP_MODULES ngx_http_fastdfs_module\"\n   NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fastdfs_module.c\"\n   CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\"\n   CORE_LIBS=\"$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient\"\n   CFLAGS=\"$CFLAGS -D_FILE_OFFSET_BITS=64 -DFDFS_OUTPUT_CHUNK_SIZE=\'256*1024\' -DFDFS_MOD_CONF_FILENAME=\'\\\"/etc/fdfs/mod_fastdfs.conf\\\"\'\"\n   \n   ```\n\n   FastDFS与nginx集成，如果已经安装了nginx，那么就只需要在原来nginx的模块中添加一个fastdfs模块\n\n   ```shell\n   #  首先需要进入到以前安装的nginx的目录中去\n   # 执行 ./configure --add-module=fastdfs-nginx-module/src/\n   # 重新编译nginx make\n   # 重新执行编译之后的nginx 千万不要再重新安装，只需要将生成的二进制文件进行替换就行了\n   # cp /usr/nginx-xxx/objs/nginx /usr/local/nginx/sbin/nginx\n   ```\n\n   然后将模块的配置文件复制到/etc/fdfs/下面\n\n   ```shell\n   cp fastdfs-nginx模块目录/src/mod_fastdfs.conf /etc/fdfs/\n   \n   ```\n\n   编辑这个配置文件\n\n   ```shell\n   # 修改内容：比如连接超时时间、跟踪器路径等等、\n   connect_timeout=10   #  10 秒\n   tracker_server=url   #  tracker所在的ip地址加上端口号\n   url_have_group_name=true   #  改为true\n   store_path0=storage目录   #  这里填的是配置storage配置的目录路径\n   ```\n\n   复制FastDFS中的两个配置文件到 /etc/fdfs/中去\n\n   ![](https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zCtaaAU9U4AAGGeh2JHHs430.png)\n\n   ```shell\n   # cp FastDFS安装目录/conf/http.conf mime.types /etc/fdfs/\n   ```\n\n   创建一个软连接,在/fastdfs/storage 文件存储目录下创建软连接，将其连接到实际存放数据的目录\n\n   ```shell\n   ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00  \n   # 这里软连接中的fastdfs目录根据自己配置文件中配置的目录来的，不一定是上面这样的\n   # 为什么创建这个软连接诶，就是为了与下面的nginx 的匹配规则对应\n   # 也就是说如果URL中访问到了M00  目录就会去到storage/data/ 这个目录下去找需要的文件\n   ```\n\n   修改nginx配置文件\n\n   ```shell\n   server {\n               listen       8888;  #这里注意端口访问的时候要加上 这里端口号和配置storage中的http.server_port=8888 是一样的\n               server_name  localhost;\n               location ~/group[0-9]/M00 {\n                   ngx_fastdfs_module;\n               }\n   }\n   ```\n\n   重新启动nginx就OK了','FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和均衡负载的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。\n安装步骤：\n准备步骤：gcc  + fastdfs + libfastcom','2019-04-26 07:40:25','2019-04-26 07:40:25',0,18,1,'c8b07e17ee8242a1b9b5024e32d00ebf',1),(21,'vue内置指令','<h3 id=\"h3-u57FAu672Cu6307u4EE4\"><a name=\"基本指令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本指令</h3><p>vue中基本指令有如下几种：</p>\n<ul>\n<li><p>v-cloak</p>\n<p>这个指令不需要表达式，他会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none配合使用,这个指令使用来在网速较慢，Vue.js文件还没加载完时，在页面上会显示出来原始的{{message}}的字样，直到Vue创建实例、编译模板，DOM才会被替换，所以这个过程屏幕是有闪动的。</p>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot; v-cloak&gt;\n        {{message}}\n            &lt;/div&gt;\n    &lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        var app = new Vue({\n           el : &quot;#app&quot;,\n           data : {\n               message : &quot;这是一段文本&quot;\n           }\n        });\n    &lt;/script&gt;\n</code></pre>\n</li><li><p>v-once </p>\n<p>这个指令主要是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化从新渲染，将被视为静态内容</p>\n<pre><code class=\"lang-vue\">    &lt;div id=&quot;app&quot;&gt;\n        &lt;span v-once&gt;{{message}}&lt;/span&gt;\n        &lt;div v-once&gt;\n            &lt;span&gt;{{message}}&lt;/span&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        var app = new Vue({\n           el : &quot;#app&quot;,\n           data : {\n               message : &quot;这是一段文本&quot;\n           }\n        });\n    &lt;/script&gt;\n</code></pre>\n</li></ul>\n<h3 id=\"h3-u6761u4EF6u6E32u67D3u6307u4EE4\"><a name=\"条件渲染指令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>条件渲染指令</h3><ul>\n<li><p>v-if v-else v-else-if</p>\n<p>条件渲染的概念就不必多说了，就是在对应的条件下选择渲染还是不渲染。这几个指令的具体用法如下面Demo所示</p>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;p v-if=&quot;status === 1&quot;&gt;当status为1时显示该行&lt;/p&gt;\n    &lt;p v-else-if=&quot;status === 2&quot;&gt;当status为2时显示该行&lt;/p&gt;\n    &lt;p v-else&gt;否则显示该行&lt;/p&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    var app = new Vue({\n        el : &quot;#app&quot;,\n        data : {\n            status : 1\n        }\n    })\n&lt;/script&gt;\n</code></pre>\n</li><li><p>v-show</p>\n<p>v-show和v-if具有类似的功能，不过v-if才是真正的条件渲染，它会根据表达式适当地销毁或重建元素及绑定的事件或子组件。若表达式初始值为false，则一开始元素/组件并不会渲染。</p>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;p v-show=&quot;status === 1&quot;&gt;当status为1时显示该行&lt;/p&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    var app = new Vue({\n        el : &quot;#app&quot;,\n        data : {\n            status : 2\n        }\n    })\n&lt;/script&gt;\n&lt;!--渲染的结果如下图所示，发现只是在元素上加上了display属性来显示或者隐藏--&gt;\n</code></pre>\n<p><img src=\"https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zCvWiAIUl6AACH-JOuSZM833.png\" alt=\"\"></p>\n</li></ul>\n<h3 id=\"h3--v-for\"><a name=\"列表渲染指令 v-for\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>列表渲染指令 v-for</h3><p>网页一般都会用到列表渲染，如果需要用到渲染的地方，那么可以使用v-for指令来进行渲染。</p>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;ul&gt;\n        &lt;!--这里多出来一个index参数，如果不需要可以写成--&gt;\n        &lt;!-- &lt;li v-for=&quot;book in books&quot;&gt;{{book.name}}&lt;/li&gt; --&gt;\n        &lt;li v-for=&quot;(book,index) in books&quot;&gt;{{index}}----{{book.name}}&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    var app = new Vue({\n       el : &quot;#app&quot;,\n       data : {\n           books : [\n               {\n                   name : &#39;《Vue.js实战》&#39;\n               },\n               {\n                   name : &#39;《Javascript语言精粹》&#39;\n               },\n               {\n                   name : &#39;《Javascript高级程序设计》&#39;\n               }\n           ]\n       }\n    });\n&lt;/script&gt;\n</code></pre>\n<p>v-for 指令可以用于template上面</p>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;ul&gt;\n        &lt;template v-for=&quot;book in books&quot;&gt;\n            &lt;li&gt;书名：{{book.name}}&lt;/li&gt;\n            &lt;li&gt;作者：{{book.author}}&lt;/li&gt;\n        &lt;/template&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    var app = new Vue({\n       el : &quot;#app&quot;,\n       data : {\n           books : [\n               {\n                   name : &#39;《Vue.js实战》&#39;,\n                   author : &#39;梁杰&#39;\n               },\n               {\n                   name : &#39;《Javascript语言精粹》&#39;,\n                   author : &#39;Dounglas Crockford&#39;\n               },\n               {\n                   name : &#39;《Javascript高级程序设计》&#39;,\n                   author : &#39;Nicholas C.Zakas&#39;\n               }\n           ]\n       }\n    });\n&lt;/script&gt;\n&lt;!--遍历用户--&gt;\n&lt;div id=&quot;app&quot;&gt;\n    &lt;span v-for=&quot;value in user&quot;&gt;{{value}}&lt;/span&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    var app = new Vue({\n       el : &quot;#app&quot;,\n       data : {\n           user : {\n               name : &#39;Aresn&#39;,\n               gender : &quot;男&quot;,\n               age : 26\n           }\n       }\n    });\n&lt;/script&gt;\n</code></pre>','### 基本指令\n\nvue中基本指令有如下几种：\n\n- v-cloak\n\n  这个指令不需要表达式，他会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none配合使用,这个指令使用来在网速较慢，Vue.js文件还没加载完时，在页面上会显示出来原始的{{message}}的字样，直到Vue创建实例、编译模板，DOM才会被替换，所以这个过程屏幕是有闪动的。\n\n  ```vue\n  <div id=\"app\" v-cloak>\n          {{message}}\n              </div>\n      <script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n      <script>\n          var app = new Vue({\n             el : \"#app\",\n             data : {\n                 message : \"这是一段文本\"\n             }\n          });\n      </script>\n  ```\n\n- v-once \n\n  这个指令主要是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化从新渲染，将被视为静态内容\n\n  ```vue\n      <div id=\"app\">\n          <span v-once>{{message}}</span>\n          <div v-once>\n              <span>{{message}}</span>\n          </div>\n      </div>\n      <script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n      <script>\n          var app = new Vue({\n             el : \"#app\",\n             data : {\n                 message : \"这是一段文本\"\n             }\n          });\n      </script>\n  ```\n\n### 条件渲染指令\n\n- v-if v-else v-else-if\n\n  条件渲染的概念就不必多说了，就是在对应的条件下选择渲染还是不渲染。这几个指令的具体用法如下面Demo所示\n\n  ```vue\n  <div id=\"app\">\n      <p v-if=\"status === 1\">当status为1时显示该行</p>\n      <p v-else-if=\"status === 2\">当status为2时显示该行</p>\n      <p v-else>否则显示该行</p>\n  </div>\n  <script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n  <script>\n      var app = new Vue({\n          el : \"#app\",\n          data : {\n              status : 1\n          }\n      })\n  </script>\n  ```\n\n- v-show\n\n  v-show和v-if具有类似的功能，不过v-if才是真正的条件渲染，它会根据表达式适当地销毁或重建元素及绑定的事件或子组件。若表达式初始值为false，则一开始元素/组件并不会渲染。\n\n  ```vue\n  <div id=\"app\">\n      <p v-show=\"status === 1\">当status为1时显示该行</p>\n  </div>\n  <script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n  <script>\n      var app = new Vue({\n          el : \"#app\",\n          data : {\n              status : 2\n          }\n      })\n  </script>\n  <!--渲染的结果如下图所示，发现只是在元素上加上了display属性来显示或者隐藏-->\n  ```\n\n ![](https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zCvWiAIUl6AACH-JOuSZM833.png)\n\n### 列表渲染指令 v-for\n\n网页一般都会用到列表渲染，如果需要用到渲染的地方，那么可以使用v-for指令来进行渲染。\n\n```vue\n<div id=\"app\">\n    <ul>\n        <!--这里多出来一个index参数，如果不需要可以写成-->\n        <!-- <li v-for=\"book in books\">{{book.name}}</li> -->\n        <li v-for=\"(book,index) in books\">{{index}}----{{book.name}}</li>\n    </ul>\n</div>\n<script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n<script>\n    var app = new Vue({\n       el : \"#app\",\n       data : {\n           books : [\n               {\n                   name : \'《Vue.js实战》\'\n               },\n               {\n                   name : \'《Javascript语言精粹》\'\n               },\n               {\n                   name : \'《Javascript高级程序设计》\'\n               }\n           ]\n       }\n    });\n</script>\n```\n\nv-for 指令可以用于template上面\n\n```vue\n<div id=\"app\">\n    <ul>\n        <template v-for=\"book in books\">\n            <li>书名：{{book.name}}</li>\n            <li>作者：{{book.author}}</li>\n        </template>\n    </ul>\n</div>\n<script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n<script>\n    var app = new Vue({\n       el : \"#app\",\n       data : {\n           books : [\n               {\n                   name : \'《Vue.js实战》\',\n                   author : \'梁杰\'\n               },\n               {\n                   name : \'《Javascript语言精粹》\',\n                   author : \'Dounglas Crockford\'\n               },\n               {\n                   name : \'《Javascript高级程序设计》\',\n                   author : \'Nicholas C.Zakas\'\n               }\n           ]\n       }\n    });\n</script>\n<!--遍历用户-->\n<div id=\"app\">\n    <span v-for=\"value in user\">{{value}}</span>\n</div>\n<script src=\"https://unpkg.com/vue/dist/vue.min.js\"></script>\n<script>\n    var app = new Vue({\n       el : \"#app\",\n       data : {\n           user : {\n               name : \'Aresn\',\n               gender : \"男\",\n               age : 26\n           }\n       }\n    });\n</script>\n```','基本指令vue中基本指令有如下几种：\n\nv-cloak\n这个指令不需要表达式，他会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none配合使用,这个指令使用来在网速较慢，Vue.js文件还没加载完时，在页面上会显示出来原始的{{message}}的字样，直到Vue','2019-04-26 08:14:58','2019-04-26 08:14:58',0,9,5,'617eeb56aad648ff90bc892a30af2f6f',1);
/*!40000 ALTER TABLE `bk_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_book`
--

DROP TABLE IF EXISTS `bk_book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_book` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `desc` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `imgId` varchar(255) NOT NULL,
  `price` double NOT NULL DEFAULT '0',
  `author` varchar(64) NOT NULL,
  `publishDate` datetime NOT NULL,
  `mode` int(1) NOT NULL,
  PRIMARY KEY (`id`,`name`) USING BTREE,
  KEY `imgId` (`imgId`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_book`
--

LOCK TABLES `bk_book` WRITE;
/*!40000 ALTER TABLE `bk_book` DISABLE KEYS */;
INSERT INTO `bk_book` VALUES (1,'java编程思想','本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。','d2f07e316b944c49b22305c03fb0624e',108,'Bruce Eckel','2007-06-17 01:06:54',1),(2,'spring in action','《Spring in Action(中文版)(第2版)》分成三大部分并附有两个附录，每一部分分别对应Spring框架的一个领域：核心框架、业务和数据层、表示层。每一部分既是建立在前一部分的基础上，同时也可以独立存在。因此，读者不必从头开始，完全可以直接深入到某个主题。书中第一部分展示了Spring框架的两个核心特性：依赖注入和面向切面编程。第二部分以第一部分介绍的DI和AOP特性为基础，叙述了如何将这两个概念应用到应用程序的数据和业务层中。第三部分介绍了Spring构建 Web应用程序的各种方式。','6aceaaa52fb64c129034192b716096ad',59,'沃尔斯，布雷登巴赫','2018-10-17 01:06:57',1),(3,'JavaScript高级程序设计','本书从最早期Netscape浏览器中的JavaScript开始讲起，直到当前它对XML和Web服务的具体支持，内容主要涉及JavaScript的语言特点、JavaScript与浏览器的交互、更高级的JavaScript技巧，以及与在Web应用程序中部署JavaScript解决方案有关的问题，如错误处理、调试、安全性、优化/混淆化、XML和Web服务，最后介绍应用所有这些知识来创建动态用户界面。','300f861b911a4037906c101485ca6e48',99,'(美)(Nicholas C.Zakas)扎卡斯','2016-01-17 01:07:02',1),(4,'重构','重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。\r\n\r\n本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。','2c65c0414df04fb8869bf071cd137f45',69,'（美）福勒 ','2010-11-03 01:07:05',1),(5,'设计模式之禅','如果说“四人帮”的《设计模式》是设计模式领域的“圣经”，那么之后出版的各种关于设计模式的书都可称之为“圣经”的“注释版”或“圣经的故事”。本书是得道者对“圣经”的“禅悟”，它既不像“圣经”那样因为惜字如金、字字珠玑而深奥、晦涩和难懂，又比“圣经”的“注释版”更深刻和全面、更通俗和生动、更接近开发者遇到的实践场景，更具指导性。本书兼收并蓄、博采众长，也许是设计模式领域里的下一个里程碑之作。','1b783e983c9a4a3d93b117461a4d1a6b',69,'秦小波','2010-03-01 01:06:42',1);
/*!40000 ALTER TABLE `bk_book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_category`
--

DROP TABLE IF EXISTS `bk_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_category` (
  `id` int(11) NOT NULL DEFAULT '1',
  `desc` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `itemCount` int(11) NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `createDateTime` datetime NOT NULL,
  `mode` int(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_category`
--

LOCK TABLES `bk_category` WRITE;
/*!40000 ALTER TABLE `bk_category` DISABLE KEYS */;
INSERT INTO `bk_category` VALUES (1,'网站首页顶部导航栏',5,'2018-11-28 14:32:25','2018-11-28 14:32:29',1);
/*!40000 ALTER TABLE `bk_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_category_link`
--

DROP TABLE IF EXISTS `bk_category_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_category_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `lid` int(11) NOT NULL,
  `cid` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `lid` (`lid`) USING BTREE,
  KEY `cid` (`cid`) USING BTREE,
  CONSTRAINT `cid` FOREIGN KEY (`cid`) REFERENCES `bk_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `lid` FOREIGN KEY (`lid`) REFERENCES `bk_link` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_category_link`
--

LOCK TABLES `bk_category_link` WRITE;
/*!40000 ALTER TABLE `bk_category_link` DISABLE KEYS */;
INSERT INTO `bk_category_link` VALUES (1,20,1),(2,21,1),(4,23,1),(5,24,1);
/*!40000 ALTER TABLE `bk_category_link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_img`
--

DROP TABLE IF EXISTS `bk_img`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_img` (
  `id` varchar(255) NOT NULL,
  `src` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDateTime` datetime DEFAULT NULL,
  `updateDateTime` datetime DEFAULT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_img`
--

LOCK TABLES `bk_img` WRITE;
/*!40000 ALTER TABLE `bk_img` DISABLE KEYS */;
INSERT INTO `bk_img` VALUES ('06a5ceb32cfd4ef3bbca08dd13035b9e','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAh1qAZmvoAAA8TUQG7fo121.jpg','TIM截图20190306143455.jpg','2019-04-24 15:57:13','2019-04-24 15:57:13',1),('1718cbd0a41f4153a420600c14f6379b','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAbduAc6O4AAA0kbokx50700.png','SpringMVC异常处理.png','2019-04-24 14:08:27','2019-04-24 14:08:27',1),('1b783e983c9a4a3d93b117461a4d1a6b','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1ygWYWAWrROAAA8Cs9mNEQ695.jpg','sjmszc.jpg','2019-03-31 06:09:10','2019-03-31 06:09:10',1),('1ef20a29c76e4b6ebc82e65cd0dcedb3','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAZv6ABUTVAAAQiMjBJDk877.jpg','spring.jpg','2019-04-24 13:39:10','2019-04-24 13:39:10',1),('1f2c8fc02c7f4d85b71bc084dd8b20f2','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAbRyAFNbpAAA44wGGf3U466.jpg','表单验证.jpg','2019-04-24 14:05:16','2019-04-24 14:05:16',1),('262950296d89479688830cfb7d72ed2b','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1y_v9SANcSCAAAzERPlShk935.png','PageHelper.png','2019-04-24 01:45:56','2019-04-24 01:45:56',1),('2835dec0c12744e5a67c748ad4254a9d','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAa1OAHz13AAA_4_CmTJw399.jpg','java io流基本概念.jpg','2019-04-24 13:57:39','2019-04-24 13:57:39',1),('2c65c0414df04fb8869bf071cd137f45','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1ygVZSABxoeAAKFz_L1ovs843.jpg','cg.jpg','2019-03-31 05:52:22','2019-03-31 05:52:22',1),('300f861b911a4037906c101485ca6e48','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1ygWXCADt3MAAJAvxkPi4s062.png','javascriptgjcxsj.png','2019-03-31 06:08:49','2019-03-31 06:08:49',1),('30bc3a736fc4468f9056d8d189785dd2','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAbzWAW118AAA671FPvdw254.jpg','代码改善.jpg','2019-04-24 14:14:14','2019-04-24 14:14:14',1),('318578a30c294f4b9f45dbf74be23fc9','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAfSuAdbWUAABJTxKAtqE879.jpg','TIM截图20190306143359.jpg','2019-04-24 15:13:46','2019-04-24 15:13:46',1),('328e571775694d368546c4a1d00642ec','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1yPdXuAZpA4AABCciVDx7g495.jpg','rBKlY1yPdXuAZpA4AABCciVDx7g495.jpg','2019-03-18 18:39:56','2019-03-18 18:39:56',1),('3730dde8166449e88d4987f2023db622','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAb-SAQEUuAAA-El3QVnc166.jpg','java io流小结.jpg','2019-04-24 14:17:09','2019-04-24 14:17:09',1),('3f0da92ec0d64b5b8186b6a7621e5d6c','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAcTuAJTjlAAA1a4OuLAg481.jpg','excution表达式.jpg','2019-04-24 14:22:52','2019-04-24 14:22:52',1),('402188c6586f4951a11cb51640648db6','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1ygKnaAWYpoAAWT-tCWuK0413.jpg','editormd-image-file','2019-03-31 02:48:23','2019-03-31 02:48:23',1),('4bcff200b0cd47e4b2ebb456acf8d6e0','/myblog/images/album_index/IMG_20180823_113536.jpg','index_album_2','2018-11-29 15:02:12','2019-03-27 23:40:45',1),('55f63b227ef64983bfbdda7a1ad1c702','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAfleAOv1UAAA8TUQG7fo387.jpg','TIM截图20190306143455.jpg','2019-04-24 15:18:47','2019-04-24 15:18:47',1),('5e180e06e25e4433ae783325da9dbbb4','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1yTTJCAKvw5AABaTNAgat0168.jpg','editormd-image-file','2019-03-21 16:34:23','2019-03-21 16:34:23',1),('615129349d5b4301b86e2201ad40553c','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1yFycOAWBwPAAInnOxvOoo108.jpg','rBUAC1yFycOAWBwPAAInnOxvOoo108.jpg','2019-03-11 10:36:51','2019-03-11 10:36:51',1),('617eeb56aad648ff90bc892a30af2f6f','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zCvWiAIUl6AACH-JOuSZM833.png','v-if演示.png','2019-04-26 08:12:25','2019-04-26 08:12:25',1),('663de4696f8a41c8902830a7f7882d22','/myblog/images/album_index/IMG_20180823_114736.jpg','index_album_6','2018-11-29 15:05:19','2018-11-29 15:05:22',1),('6aceaaa52fb64c129034192b716096ad','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1ygWYyAVErWAAAkgTaZZwQ055.jpg','springinaction.jpg','2019-03-31 06:09:18','2019-03-31 06:09:18',1),('6c8035fe136945f8b335c357d4e0c5dc','/myblog/images/blog/java.jpg','java.jpg','2018-12-18 11:22:21','2018-12-18 11:22:21',1),('6dbfceae49e3420cb9d0390a23a4e8d3','/myblog/images/album_index/IMG_20180823_113545.jpg','index_album_3','2018-11-29 15:02:46','2019-03-27 23:40:45',1),('7cb943cdf99b4d4ab9705def3d123c4a','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAbIWAA_AnAAAo4kS15uI042.jpg','FIle类常用函数.jpg','2019-04-24 14:02:45','2019-04-24 14:02:45',1),('7fb4dbd9d986493fa9d04c9b353af2a8','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAfXaAVKRnAAA8TUQG7fo023.jpg','TIM截图20190306143455.jpg','2019-04-24 15:15:01','2019-04-24 15:15:01',1),('85ee95a44be345d685c0c4220b1ec6e5','/myblog/images/album_index/IMG_20180823_113722.jpg','index_album_4','2018-11-29 15:03:33','2018-11-29 15:03:35',1),('8d8bb38d44c945d8b7c643b8ebcf6049','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAZ7GAZEz3AAAynytLBrA657.jpg','SpringMVC三层模型.jpg','2019-04-24 13:42:10','2019-04-24 13:42:10',1),('8e338c1d143444a99f3ef0f033949603','/myblog/images/album/me.jpg','me.jpg','2018-12-01 00:19:59','2019-03-27 23:40:45',1),('938b5b9a9e554fd982c6109dcae446e8','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1yEpZqACq25AAAbhH43tzY093.jpg','rBKlY1yEpZqACq25AAAbhH43tzY093.jpg','2019-03-10 13:50:18','2019-03-10 13:50:18',1),('973ff24c034a4d029a73b4d95f8aeb26','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1x-Y8yAaz9yAAA223X8130178.jpg','rBKlY1x-Y8yAaz9yAAA223X8130178.jpg','2019-03-05 19:55:56','2019-03-05 19:55:56',1),('a36249d7d67847abaa168fbd4221a763','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAgayAJ3A1AAA8TUQG7fo702.jpg','TIM截图20190306143455.jpg','2019-04-24 15:32:59','2019-04-24 15:32:59',1),('a3f9476e3dcf4bb3bd48e4c6fe098e6d','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAgAuAGTokAAA8TUQG7fo821.jpg','TIM截图20190306143455.jpg','2019-04-24 15:26:02','2019-04-24 15:26:02',1),('a5cb36430cdf49e7866d8742bdb595b5','/myblog/images/album_index/IMG_20180823_114732.jpg','index_album_5','2018-11-29 15:04:41','2018-11-29 15:04:45',1),('a879f54812294c07b961dc9257451ffb','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAcNmAeofUAAA50CCS_yk173.jpg','AOP术语.jpg','2019-04-24 14:21:13','2019-04-24 14:21:13',1),('beab3bfd981e49a8879fea4f66b94f07','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAbkqACDFIAAATDTrd3fc157.png','redislogo.png','2019-04-24 14:10:18','2019-04-24 14:10:18',1),('c52d3e0ff3f049989d49b09308c29223','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAjfmAcnjKAAA8TUQG7fo848.jpg','TIM截图20190306143455.jpg','2019-04-24 16:25:30','2019-04-24 16:25:30',1),('c8b07e17ee8242a1b9b5024e32d00ebf','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zCtaaAU9U4AAGGeh2JHHs430.png','fastdfs复制配置文件.png','2019-04-26 07:39:18','2019-04-26 07:39:18',1),('c8dd963fd2b74bacad22bec8cace59aa','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAaY6AYlm1AAA9mpFpkLs826.jpg','java io流.jpg','2019-04-24 13:50:07','2019-04-24 13:50:07',1),('d0352705b2dc42f6a1af5bb86a5c9947','/myblog/iamges/blog/6.png','6.png','2018-12-13 14:13:13','2019-03-27 23:40:45',1),('d2f07e316b944c49b22305c03fb0624e','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1ygWWWAYzBrAACj4fbZYAI927.jpg','javabcsx.jpg','2019-03-31 06:08:39','2019-03-31 06:08:39',1),('d39b45c076b14cf0a97cf1d9f6fa6363','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1x-YGWAH3TFAAAWufqxBS8650.jpg','默认图片','2019-03-05 19:41:45','2019-03-05 19:41:45',1),('dd4467f7bdc14464bc0a5560c598cc58','https://www.ljtnono.cn/group1/M00/00/00/rBUAC1zAj9OADU-GAAA8TUQG7fo231.jpg','TIM截图20190306143455.jpg','2019-04-24 16:33:24','2019-04-24 16:33:24',1),('e35357207ed9496d9a63bc4bdaf8a1f6','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1y_u66ABzW1AAAXRIzyZLc769.png','SpringAop.png','2019-04-24 01:28:12','2019-04-24 01:28:12',1),('eca3e9a0d36f4c63b1eb5a03d0939db0','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zBC5OAbiRWAAGUJICt9mE398.jpg','线程状态转换图.jpg','2019-04-25 01:21:23','2019-04-25 01:21:23',1),('fe2fcb8cf79846a2ba90711c0cbd9f48','https://www.ljtnono.cn/group1/M00/00/00/rBKlY1zAfWKAO4JBAABJTxKAtqE349.jpg','TIM截图20190306143359.jpg','2019-04-24 15:14:42','2019-04-24 15:14:42',1);
/*!40000 ALTER TABLE `bk_img` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_link`
--

DROP TABLE IF EXISTS `bk_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `href` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `title` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type` int(11) NOT NULL,
  `classNames` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '',
  `createDateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `updateDateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_link`
--

LOCK TABLES `bk_link` WRITE;
/*!40000 ALTER TABLE `bk_link` DISABLE KEYS */;
INSERT INTO `bk_link` VALUES (1,'https://redis.io/','redis',2,'blog_friendlink','2019-04-19 23:50:42','2019-04-19 23:50:42',1),(2,'http://maven.apache.org/','maven',2,'blog_friendlink','2019-04-19 23:50:42','2019-04-19 23:50:42',1),(3,'http://tomcat.apache.org/','tomcat',2,'blog_friendlink','2019-04-19 23:50:42','2019-04-19 23:50:42',1),(4,'https://www.mysql.com/','mysql',2,'blog_friendlink','2019-04-19 23:50:43','2019-04-19 23:50:43',1),(5,'http://shiro.apache.org/','shiro',2,'blog_friendlink','2019-04-19 23:50:43','2019-04-19 23:50:43',1),(6,'http://www.mybatis.org/mybatis-3/','mybatis',2,'blog_friendlink','2019-04-19 23:50:43','2019-04-19 23:50:43',1),(7,'https://spring.io/','spring',2,'blog_friendlink','2019-04-19 23:50:43','2019-04-19 23:50:43',1),(8,'http://jquery.com/','jquery',2,'blog_friendlink','2019-04-19 23:50:42','2019-04-19 23:50:42',1),(9,'http://www.bootcss.com/','bootstrap',2,'blog_friendlink','2019-04-19 23:50:42','2019-04-19 23:50:42',1),(10,'http://wowslider.com/','WOWSlider',2,'blog_friendlink','2019-04-19 23:50:42','2019-04-19 23:50:42',1),(11,'http://nginx.org/en/','nginx',2,'blog_friendlink','2019-03-25 22:35:08','2019-03-25 22:35:08',1),(12,'https://www.liaosam.com/','料神SAM料网',2,'article_friendlink','2018-12-05 14:59:01','2018-12-05 14:59:01',1),(13,'https://www.wangzhijun.com.cn/','王志军博客',2,'article_friendlink','2018-12-05 14:59:03','2018-12-05 14:59:03',1),(14,'https://www.uctheme.com/','导购主题',2,'article_friendlink','2018-12-05 14:59:04','2018-12-05 14:59:04',1),(15,'https://www.xiaoleteam.com/','网络营销推广',2,'article_friendlink','2018-12-05 14:59:06','2018-12-05 14:59:06',1),(16,'https://yusi123.com/','思欲主题',2,'article_friendlink','2018-12-05 14:59:07','2018-12-05 14:59:07',1),(17,'http://www.wenzhihuai.com/','温志怀博客',2,'article_friendlink','2018-12-05 14:59:09','2018-12-05 14:59:09',1),(18,'https://www.yangqq.com/','杨青主题',2,'article_friendlink','2018-12-05 14:59:12','2018-12-05 14:59:12',1),(19,'http://huaban.com/','花瓣网',2,'article_friendlink','2018-12-05 14:59:15','2018-12-05 14:59:15',1),(20,'/myblog/blog','首页',1,'','2018-12-28 16:03:12','2018-12-28 16:03:12',1),(21,'/myblog/articles?page=1&type=all','技术文章',1,'','2019-01-07 12:12:46','2019-01-07 12:12:46',1),(23,'/myblog/support','支持作者',1,'','2019-02-05 15:23:50','2019-02-05 15:23:50',1),(24,'/myblog/aboutme','关于作者',1,'','2019-01-16 00:22:07','2019-01-16 00:22:07',1),(25,'/myblog/articles?page=1&type=java','java',1,'c-2e93d9 tag','2019-01-07 12:15:46','2019-01-07 12:15:46',1),(26,'/myblog/articles?page=1&type=html','html',1,'c-f05050 tag','2019-01-07 12:16:28','2019-01-07 12:16:28',1),(27,'/myblog/articles?page=1&type=css','css',1,'c-ff6600 tag','2019-01-07 12:16:36','2019-01-07 12:16:36',1),(28,'/myblog/articles?page=1&type=jquery','jquery',1,'c-ff6600 tag','2019-01-07 12:16:44','2019-01-07 12:16:44',1),(29,'/myblog/articles?page=1&type=js','js',1,'c-2e93d9 tag','2019-01-07 12:16:51','2019-01-07 12:16:51',1),(30,'/myblog/articles?page=1&type=boostrap','bootstrap',1,'c-f05050 tag','2019-01-07 12:16:59','2019-01-07 12:16:59',1),(31,'/myblog/articles?page=1&type=maven','maven',1,'c-2e93d9 tag','2019-03-27 23:41:43','2019-03-27 23:41:43',1),(32,'/myblog/articles?page=1&type=spring','spring',1,'c-2e93d9 tag','2019-03-27 23:41:43','2019-03-27 23:41:43',1),(33,'/myblog/articles?page=1&type=mybatis','mybatis',1,'c-ff6600 tag','2019-03-27 23:41:43','2019-03-27 23:41:43',1),(34,'/myblog/articles?page=1&type=springmvc','springmvc',1,'c-2e93d9 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1),(35,'/myblog/articles?page=1&type=springboot','springboot',1,'c-f05050 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1),(36,'/myblog/articles?page=1&type=android','android',1,'c-2e93d9 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1),(37,'/myblog/articles?page=1&type=ps','ps',1,'c-f05050 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1);
/*!40000 ALTER TABLE `bk_link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_permission`
--

DROP TABLE IF EXISTS `bk_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `res` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_permission`
--

LOCK TABLES `bk_permission` WRITE;
/*!40000 ALTER TABLE `bk_permission` DISABLE KEYS */;
/*!40000 ALTER TABLE `bk_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_role`
--

DROP TABLE IF EXISTS `bk_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_role` (
  `id` int(11) NOT NULL,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_role`
--

LOCK TABLES `bk_role` WRITE;
/*!40000 ALTER TABLE `bk_role` DISABLE KEYS */;
INSERT INTO `bk_role` VALUES (1,'admin',1);
/*!40000 ALTER TABLE `bk_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_skill`
--

DROP TABLE IF EXISTS `bk_skill`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_skill` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `grade` int(11) DEFAULT NULL,
  `mode` int(1) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_skill`
--

LOCK TABLES `bk_skill` WRITE;
/*!40000 ALTER TABLE `bk_skill` DISABLE KEYS */;
INSERT INTO `bk_skill` VALUES (1,'html/css',70,1),(2,'js',62,1),(3,'java',85,1),(4,'linux',45,1),(5,'ps',63,1),(6,'android',56,1);
/*!40000 ALTER TABLE `bk_skill` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_tag`
--

DROP TABLE IF EXISTS `bk_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `link` int(11) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDateTime` datetime NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `link_id` (`link`) USING BTREE,
  CONSTRAINT `link_id` FOREIGN KEY (`link`) REFERENCES `bk_link` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_tag`
--

LOCK TABLES `bk_tag` WRITE;
/*!40000 ALTER TABLE `bk_tag` DISABLE KEYS */;
INSERT INTO `bk_tag` VALUES (1,25,'java','2018-11-29 21:25:34','2019-01-11 21:25:34',1),(2,26,'html','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(3,27,'css','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(4,28,'jquery','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(5,29,'js','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(6,30,'bootstrap','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(7,31,'maven','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(8,32,'spring','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(9,33,'mybatis','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(10,34,'springmvc','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(11,35,'springboot','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(12,36,'android','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(13,37,'ps','2018-11-29 21:25:34','2018-11-29 21:25:34',1);
/*!40000 ALTER TABLE `bk_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_time_line`
--

DROP TABLE IF EXISTS `bk_time_line`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_time_line` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `date` datetime DEFAULT NULL,
  `mode` int(1) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_time_line`
--

LOCK TABLES `bk_time_line` WRITE;
/*!40000 ALTER TABLE `bk_time_line` DISABLE KEYS */;
INSERT INTO `bk_time_line` VALUES (1,'2019-01-19 22:40:00',1,'完成关于我页面的相关内容，页面虽然不是很好看，但是好歹是自己辛辛苦苦做出来的，还是蛮有成就感的，今后会更加努力！'),(2,'2019-01-18 15:41:41',1,'接入畅言评论系统感觉还不错哦'),(3,'2018-11-14 12:03:45',1,'更新side部分，解决tomcatbug问题，新增文章详情页面，使用了Editor来显示文章内容，修复了.tag类名污染问题BUG'),(4,'2018-11-11 15:22:36',1,'添加技术文章页面，引入font-awesome字体图标系统，减少了网页的图片，分离出来文章列表部分的样式形成单独的文件，将header和footer jsp中的html部分去掉只剩下内容部分'),(5,'2018-11-03 14:22:15',1,'分离出来了header和footer页面，修复hot5页面不能垂直居中的问题'),(6,'2018-11-01 11:22:56',1,'上一个项目完成，博客项目开始进行，搭建环境，引入shiro');
/*!40000 ALTER TABLE `bk_time_line` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_user`
--

DROP TABLE IF EXISTS `bk_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_user` (
  `id` int(11) NOT NULL,
  `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `desc` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `qq` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `tel` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `email` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `createDateTime` datetime NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`,`username`) USING BTREE,
  KEY `id` (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_user`
--

LOCK TABLES `bk_user` WRITE;
/*!40000 ALTER TABLE `bk_user` DISABLE KEYS */;
INSERT INTO `bk_user` VALUES (1,'BruseLing','51af133d21379bf3625171e1cc70cd34','超级管理员','935188400','15337106753','935188400@qq.com','2018-11-22 19:27:41','2018-11-22 19:27:45',1);
/*!40000 ALTER TABLE `bk_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_user_role`
--

DROP TABLE IF EXISTS `bk_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_user_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uid` int(11) NOT NULL,
  `rid` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `rid` (`rid`) USING BTREE,
  KEY `uid` (`uid`) USING BTREE,
  CONSTRAINT `rid` FOREIGN KEY (`rid`) REFERENCES `bk_role` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `uid` FOREIGN KEY (`uid`) REFERENCES `bk_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_user_role`
--

LOCK TABLES `bk_user_role` WRITE;
/*!40000 ALTER TABLE `bk_user_role` DISABLE KEYS */;
INSERT INTO `bk_user_role` VALUES (1,1,1);
/*!40000 ALTER TABLE `bk_user_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_webconfig`
--

DROP TABLE IF EXISTS `bk_webconfig`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_webconfig` (
  `id` int(11) NOT NULL,
  `blogName` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blogAuthor` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `record` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `from` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_webconfig`
--

LOCK TABLES `bk_webconfig` WRITE;
/*!40000 ALTER TABLE `bk_webconfig` DISABLE KEYS */;
INSERT INTO `bk_webconfig` VALUES (1,'JT Geek','BruseLing','粤ICP备17092242号-1','思欲主题',1);
/*!40000 ALTER TABLE `bk_webconfig` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-05-02 15:37:47
