-- MySQL dump 10.13  Distrib 8.0.11, for Win64 (x86_64)
--
-- Host: 118.89.247.210    Database: myblog
-- ------------------------------------------------------
-- Server version	8.0.15

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
 SET NAMES utf8mb4 ;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `bk_blog`
--

DROP TABLE IF EXISTS `bk_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_blog` (
  `id` int(11) NOT NULL,
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `contentHtml` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `contentMarkDown` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDateTime` datetime NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `nextBlog` int(11) DEFAULT '0',
  `prevBlog` int(11) DEFAULT '0',
  `commentCount` int(11) DEFAULT NULL,
  `viewCount` int(11) unsigned NOT NULL DEFAULT '0',
  `tagId` int(11) DEFAULT '0',
  `imageId` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`,`title`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_blog`
--

LOCK TABLES `bk_blog` WRITE;
/*!40000 ALTER TABLE `bk_blog` DISABLE KEYS */;
INSERT INTO `bk_blog` VALUES (1,'springmvc配置静态资源','<p>跟着传智的视频在做那个淘淘商城的项目，做到第二天，发现自己以前学习的SSM框架还有一些东西没有完全弄懂，很多东西只是会用，但是完全不知道为什么而用，通过这个项目练手，也是对SSM框架的一种补充。</p>\n<p>今天就来说一说如何在一个SSM框架中配置访问静态资源的问题。</p>\n<p>首先，必须要有一个SSM环境呗，这里我就以淘淘商城为例子。</p>\n<p>贴一下web.xml的配置：</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns=\"http://java.sun.com/xml/ns/javaee\"\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n    version=\"2.5\"&gt;\n    &lt;display-name&gt;taotao-manager-web&lt;/display-name&gt;\n    &lt;welcome-file-list&gt;\n        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\n        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\n    &lt;/welcome-file-list&gt;\n    &lt;!-- 配置dispatcherservlet --&gt;\n    &lt;!-- url拦截形式 --&gt;\n    &lt;!-- 加载springmvc --&gt;\n    &lt;!-- springmvc的前端控制器 --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;taotao-manager-web&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+\"-servlet.xml\" --&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;taotao-manager-web&lt;/servlet-name&gt;\n        &lt;!-- /*表示拦截所有，包括转发的JSP页面  这是错误的，不能用 --&gt;\n        &lt;!-- /表示拦截所有的静态资源，不包括转发的JSP --&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;encoding&lt;/param-name&gt;\n            &lt;param-value&gt;utf-8&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n\n&lt;/web-app&gt;\n</code></pre><p>可以看到在spring前端控制器DispatcherServlet中配置的是 / 拦截规则，这里配置 / 的意思是说，所有的请求都需要经过前端控制器，自然也会拦截所有的css、jsp、js等静态资源。注意千万不能配置成 /* 否则包括jsp在内的静态资源的请求都会被拦截。</p>\n<p>这个时候如果你在spring的配置文件中没有配置静态资源拦截的话那么就会出现诸如css、js文件加载不出来的问题，你需要在springmvc.xml文件中加上<mvc>这样一句。<p></p></mvc>\n<p>springmvc.xml:</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \"&gt;\n    &lt;context:component-scan base-package=\"com.taotao.controller\" /&gt;\n   &lt;!-- 这里配置使用servlet默认的静态资源处理方式--&gt;\n    &lt;mvc:default-servlet-handler/&gt;\n    &lt;mvc:annotation-driven /&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt;\n        &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n    &lt;/bean&gt;    \n    &lt;!-- 引用dubbo --&gt;\n    &lt;dubbo:application name=\"taotao-manager-web\" /&gt;\n    &lt;dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" /&gt;\n&lt;/beans&gt;\n</code></pre><p>在注释处使用了默认的servlet静态资源处理方式，这样就是说让tomcat自己处理，如果你是这样配置的话。那么会很麻烦，因为你所有的请求都会被springmvc捕捉，然后传递请求到controller，你需要写一个页面跳转控制器</p>\n<p>PageController.java:</p>\n<pre><code>package com.taotao.controller;\n/**\n * \n * @author Administrator\n *\n */\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PageController {\n\n    @RequestMapping(\"/\")\n    public String showIndex() {\n        return \"index\";\n    }\n\n    @RequestMapping(\"/{page}\")\n    public String showPage(@PathVariable String page) {\n\n        return page;\n    }\n}\n</code></pre><p>有了这个之后，你在访问静态jsp的时候可以使用  /page名 的方式来访问，css、img资源也会正常的加载。也就是说你请求jsp的话就是通过这个controller来进行跳转的。这里需要springmvc的视图解析器配置正确。</p>\n<p>但是不推荐这种，因为需要访问controller，耗费时间。推荐在springmvc中这样修改。</p>\n<p>springmvc.xml:</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \"&gt;\n\n    &lt;context:component-scan base-package=\"com.taotao.controller\" /&gt;\n    &lt;mvc:annotation-driven /&gt;\n    &lt;bean\n        class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt;\n        &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n    &lt;/bean&gt;    \n    &lt;!-- 配置静态资源映射 --&gt;\n    &lt;!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 --&gt;\n    &lt;!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 --&gt;\n        &lt;mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/&gt;\n        &lt;mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/&gt;\n\n    &lt;!-- 引用dubbo --&gt;\n    &lt;dubbo:application name=\"taotao-manager-web\" /&gt;\n    &lt;dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" /&gt;\n    &lt;dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" /&gt;\n&lt;/beans&gt;\n</code></pre><p>可以看到就是将<mvc>换成了以下的代码：<p></p></mvc>\n<pre><code>&lt;!-- 配置静态资源映射 --&gt;\n    &lt;!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 --&gt;\n    &lt;!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 --&gt;\n        &lt;mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/&gt;\n        &lt;mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/&gt;\n</code></pre><p>其中 location属性是你的静态资源放置的真实位置，也就是WEN-INF下面的js文件夹和css文件夹，然后将其映射到 /js/<strong> 和 /css/</strong> 路径，也就是说使用  /js/** 这样的路径不会被前端控制器处理，直接访问的是静态资源。</p>\n<p>关于SSM还有很多细节问题需要注意，希望读者能够在写代码的时候多多注意。</p>','跟着传智的视频在做那个淘淘商城的项目，做到第二天，发现自己以前学习的SSM框架还有一些东西没有完全弄懂，很多东西只是会用，但是完全不知道为什么而用，通过这个项目练手，也是对SSM框架的一种补充。\n\n今天就来说一说如何在一个SSM框架中配置访问静态资源的问题。\n\n首先，必须要有一个SSM环境呗，这里我就以淘淘商城为例子。\n\n贴一下web.xml的配置：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns=\"http://java.sun.com/xml/ns/javaee\"\n	xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n	version=\"2.5\">\n	<display-name>taotao-manager-web</display-name>\n	<welcome-file-list>\n		<welcome-file>index.html</welcome-file>\n		<welcome-file>index.htm</welcome-file>\n		<welcome-file>index.jsp</welcome-file>\n		<welcome-file>default.html</welcome-file>\n		<welcome-file>default.htm</welcome-file>\n		<welcome-file>default.jsp</welcome-file>\n	</welcome-file-list>\n	<!-- 配置dispatcherservlet -->\n	<!-- url拦截形式 -->\n	<!-- 加载springmvc -->\n	<!-- springmvc的前端控制器 -->\n	<servlet>\n		<servlet-name>taotao-manager-web</servlet-name>\n		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n		<!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+\"-servlet.xml\" -->\n		<init-param>\n			<param-name>contextConfigLocation</param-name>\n			<param-value>classpath:spring/springmvc.xml</param-value>\n		</init-param>\n		<load-on-startup>1</load-on-startup>\n	</servlet>\n	<servlet-mapping>\n		<servlet-name>taotao-manager-web</servlet-name>\n		<!-- /*表示拦截所有，包括转发的JSP页面  这是错误的，不能用 -->\n		<!-- /表示拦截所有的静态资源，不包括转发的JSP -->\n		<url-pattern>/</url-pattern>\n	</servlet-mapping>\n	<filter>\n		<filter-name>CharacterEncodingFilter</filter-name>\n		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n		<init-param>\n			<param-name>encoding</param-name>\n			<param-value>utf-8</param-value>\n		</init-param>\n	</filter>\n	<filter-mapping>\n		<filter-name>CharacterEncodingFilter</filter-name>\n		<url-pattern>/*</url-pattern>\n	</filter-mapping>\n\n</web-app>\n```\n可以看到在spring前端控制器DispatcherServlet中配置的是 / 拦截规则，这里配置 / 的意思是说，所有的请求都需要经过前端控制器，自然也会拦截所有的css、jsp、js等静态资源。注意千万不能配置成 /* 否则包括jsp在内的静态资源的请求都会被拦截。\n\n这个时候如果你在spring的配置文件中没有配置静态资源拦截的话那么就会出现诸如css、js文件加载不出来的问题，你需要在springmvc.xml文件中加上<mvc:default-servlet-handler/>这样一句。\n\nspringmvc.xml:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \">\n	<context:component-scan base-package=\"com.taotao.controller\" />\n   <!-- 这里配置使用servlet默认的静态资源处理方式-->\n	<mvc:default-servlet-handler/>\n	<mvc:annotation-driven />\n	<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n		<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n		<property name=\"suffix\" value=\".jsp\" />\n	</bean>	\n	<!-- 引用dubbo -->\n	<dubbo:application name=\"taotao-manager-web\" />\n	<dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" />\n	<dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" />\n	<dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" />\n</beans>\n```\n在注释处使用了默认的servlet静态资源处理方式，这样就是说让tomcat自己处理，如果你是这样配置的话。那么会很麻烦，因为你所有的请求都会被springmvc捕捉，然后传递请求到controller，你需要写一个页面跳转控制器\n\nPageController.java:\n```\npackage com.taotao.controller;\n/**\n * \n * @author Administrator\n *\n */\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class PageController {\n	\n	@RequestMapping(\"/\")\n	public String showIndex() {\n		return \"index\";\n	}\n	\n	@RequestMapping(\"/{page}\")\n	public String showPage(@PathVariable String page) {\n		\n		return page;\n	}\n}\n\n```\n有了这个之后，你在访问静态jsp的时候可以使用  /page名 的方式来访问，css、img资源也会正常的加载。也就是说你请求jsp的话就是通过这个controller来进行跳转的。这里需要springmvc的视图解析器配置正确。\n\n但是不推荐这种，因为需要访问controller，耗费时间。推荐在springmvc中这样修改。\n\nspringmvc.xml:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        \">\n\n	<context:component-scan base-package=\"com.taotao.controller\" />\n	<mvc:annotation-driven />\n	<bean\n		class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n		<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n		<property name=\"suffix\" value=\".jsp\" />\n	</bean>	\n	<!-- 配置静态资源映射 -->\n	<!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 -->\n	<!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 -->\n		<mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/>\n		<mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/>\n	\n	<!-- 引用dubbo -->\n	<dubbo:application name=\"taotao-manager-web\" />\n	<dubbo:registry protocol=\"zookeeper\" address=\"192.168.25.128:2181\" />\n	<dubbo:reference interface=\"com.taotao.service.TestService\" id=\"testService\" />\n	<dubbo:reference interface=\"com.taotao.service.ItemService\" id=\"itemService\" />\n</beans>\n```\n可以看到就是将<mvc:default-servlet-handler/>换成了以下的代码：\n```\n<!-- 配置静态资源映射 -->\n	<!-- 指定/WEB-INF/js  /WEB-INF/css/ 下的所有的静态资源包括子目录下的静态资源  都不被拦截 -->\n	<!-- mapping = /js/**   表示访问静态资源的路劲的形式  可以访问/js/下的所有子目录下的资源 -->\n		<mvc:resources location=\"/WEB-INF/js/\" mapping=\"/js/**\"/>\n		<mvc:resources location=\"/WEB-INF/css/\" mapping=\"/css/**\"/>\n```\n其中 location属性是你的静态资源放置的真实位置，也就是WEN-INF下面的js文件夹和css文件夹，然后将其映射到 /js/** 和 /css/** 路径，也就是说使用  /js/** 这样的路径不会被前端控制器处理，直接访问的是静态资源。\n\n关于SSM还有很多细节问题需要注意，希望读者能够在写代码的时候多多注意。\n\n\n\n\n\n','跟着传智的视频在做那个淘淘商城的项目，做到第二天，发现自己以前学习的SSM框架还有一些东西没有完全弄懂，很多东西只是会用，但是完全不知道为什么而用，通过这个项目练手，也是对SSM框架的一种补充。今天就来说一说如何在一个SSM框架中配置访问静态资源的问题。首先，必须要','2018-11-30 23:54:08','2018-11-30 23:54:12',2,0,5,126,10,'938b5b9a9e554fd982c6109dcae446e8',1),(2,'mybatis分页插件pageHelper使用详解','<p>一直以来都用的是自己封装的一个pageBean类来处理分页相关的业务，这个pageBean是从传智播客的视频上面学到的，最近看到别人写的都是用的mybatis的pageHelper,所以自己也心痒痒，将自己的一个竞赛管理系统的分页也换成了pageHelper的方式。话不多说，直接上配置。</p>\n<p>首先要使用mybatis的这个插件就必须在mybatis的配置文件中配置插件的相关设置。</p>\n<p>mybatis-config.xml :</p>\n<pre><code>&lt;configuration&gt;\n\n    &lt;typeAliases&gt;\n        &lt;package name=\"cn.ljtnono.jsgl.pojo\" /&gt;\n        &lt;package name=\"cn.ljtnono.jsgl.vo\" /&gt;\n    &lt;/typeAliases&gt;\n\n    &lt;plugins&gt;\n        &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt;\n            &lt;!--使用的方言，值有mysql oracle SqlServer等--&gt;\n            &lt;property name=\"dialect\" value=\"mysql\"/&gt;\n            &lt;!-- 该参数默认为false --&gt;\n            &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;\n            &lt;!-- 和startPage中的pageNum效果一样--&gt;\n            &lt;property name=\"offsetAsPageNum\" value=\"true\"/&gt;\n            &lt;!-- 该参数默认为false --&gt;\n            &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;\n            &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt;\n            &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;\n            &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）\n            &lt;property name=\"pageSizeZero\" value=\"true\"/&gt;--&gt;\n            &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;\n            &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;\n            &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;\n            &lt;property name=\"reasonable\" value=\"true\"/&gt;\n            &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;\n            &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;\n            &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;\n            &lt;!-- 不理解该含义的前提下，不要随便复制该配置\n            &lt;property name=\"params\" value=\"pageNum=start;pageSize=limit;\"/&gt;    --&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n\n    &lt;!-- 在这里环境标签默认填写的是id为mysql的环境，与spring整合后就废除了环境标签 --&gt;\n    &lt;!-- 配置从哪里读取mapper文件 --&gt;\n    &lt;mappers&gt;\n        &lt;package name=\"cn.ljtnono.jsgl.dao\" /&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre><p>这里解释下各种参数：<br>1、dialect  方言，相信大家不会陌生，就是配置数据库类型，常见的值有mysql、oracle、SqlServer等。这一项是必须配置的。<br>2、增加offsetAsPageNum属性，默认值为false，则使用默认值时不需要增加该配置，需要设为真时，需要配置该参数。当该参数设置为真时，使用RowBounds分页时，会将偏移参数当成页次使用，可以用页码和页面大小两个参数进行分页。\n<p>后面两个参数的作用在注释中解释的非常清楚了，这里不再赘述，关于参数还有好几个，大家可以查看<a href=\"https://github.com/pagehelper/Mybatis-PageHelper\">https://github.com/pagehelper/Mybatis-PageHelper</a> github官方文档。</p>\n<p>然后就是使用了，这里以查询一个竞赛列表信息为例子。</p>\n<pre><code>@Override\n    public PageInfo&lt;Contest&gt; getContestListByModality(int modality, int currentPage) {\n\n        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(1);\n        PageInfo&lt;Contest&gt; pageInfo = null;\n        map.put(\"modality\",modality);\n        try {\n            PageHelper.startPage(currentPage,CURRENTCOUNT);\n            List&lt;Contest&gt; list = contestDaoMapper.selectByModality(map);\n            pageInfo = new PageInfo&lt;&gt;(list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pageInfo;\n    }\n</code></pre><p>在PageHelper.startPage() 后面的第一个查询会默认使用分页查询，也就是说不必自己再写一个sql去查询总的条数。查询出来的结果使用pageInfo这个类进行接收。</p>\n<p>PageInfo这个类中封装了分页所需要的各种参数，十分方便。</p>\n<p>下面贴出PageInfo的源代码：</p>\n<pre><code>//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.github.pagehelper;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class PageInfo&lt;T&gt; implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private int pageNum;\n    private int pageSize;\n    private int size;\n    private int startRow;\n    private int endRow;\n    private long total;\n    private int pages;\n    private List&lt;T&gt; list;\n    private int firstPage;\n    private int prePage;\n    private int nextPage;\n    private int lastPage;\n    private boolean isFirstPage;\n    private boolean isLastPage;\n    private boolean hasPreviousPage;\n    private boolean hasNextPage;\n    private int navigatePages;\n    private int[] navigatepageNums;\n    ........\n   }\n</code></pre><p>参数解释：<br>pageNum ：当前页码数。<br>pageSize ： 每一页装的条数。<br>size ： 查询出来的总的页数。<br>startRow ：从哪一条开始查询的。<br>endRow ： 哪一条结束。<br>total ： 总的条数。<br>pages ： 总的页数。<br>list ： 记录集合。<br>firstPage ： 第一页。<br>prePage ： 上一页。<br>nextPage ： 下一页。<br>lastPage ： 最后一页。<br>isFirstPage ： 是否是第一页。<br>isLastPage ：是否是最后一页。<br>hasPreviousPage ： 是否有前一页。<br>hasNextPage ： 是否有后一页。<br>navigatePages ： 导航总的页数。<br>navigatepageNums ： 页数集合。即从第一页到最后一页的页码数。\n<p>这个类使用真的很方便，可以直接使用EL表达式来取值。</p>\n<p>在jsp中使用EL表达式取值：</p>\n<p>contest.jsp :</p>\n<pre><code>&lt;tbody&gt;\n     &lt;c:forEach items=\"${pageInfo.list}\" var=\"contest\"&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;\n                            ${contest.theam}\n                    &lt;/td&gt;\n                    &lt;td class=\"modality\"&gt;\n                        &lt;c:if test=\"${contest.modality == 0}\"&gt;\n                            个人\n                        &lt;/c:if&gt;\n                        &lt;c:if test=\"${contest.modality == 1}\"&gt;\n                            团队\n                        &lt;/c:if&gt;\n                        &lt;c:if test=\"${contest.modality == 2}\"&gt;\n                            个人/团队\n                        &lt;/c:if&gt;\n                    &lt;/td&gt;\n                    &lt;td&gt;${contest.way}&lt;/td&gt;\n                    &lt;td&gt;${contest.deadline}&lt;/td&gt;\n                    &lt;td&gt;${contest.startTime}&lt;/td&gt;\n                    &lt;td&gt;${contest.endTime}&lt;/td&gt;\n                    &lt;td&gt;\n                        &lt;input type=\"button\" value=\"操作\" class=\"signUpOne btn btn-xs\" data-contestId=\"${contest.id}\"&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/c:forEach&gt;\n            &lt;/tbody&gt;\n</code></pre><p>以上就是最简单的pageHelper使用教程了，如果需要深入了解使用方式，请参考github：<a href=\"https://github.com/pagehelper/Mybatis-PageHelper。\">https://github.com/pagehelper/Mybatis-PageHelper。</a></p>','一直以来都用的是自己封装的一个pageBean类来处理分页相关的业务，这个pageBean是从传智播客的视频上面学到的，最近看到别人写的都是用的mybatis的pageHelper,所以自己也心痒痒，将自己的一个竞赛管理系统的分页也换成了pageHelper的方式。话不多说，直接上配置。\n\n首先要使用mybatis的这个插件就必须在mybatis的配置文件中配置插件的相关设置。\n\nmybatis-config.xml :\n```\n<configuration>\n\n	<typeAliases>\n		<package name=\"cn.ljtnono.jsgl.pojo\" />\n		<package name=\"cn.ljtnono.jsgl.vo\" />\n	</typeAliases>\n\n	<plugins>\n		<plugin interceptor=\"com.github.pagehelper.PageHelper\">\n			<!--使用的方言，值有mysql oracle SqlServer等-->\n			<property name=\"dialect\" value=\"mysql\"/>\n			<!-- 该参数默认为false -->\n			<!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 -->\n			<!-- 和startPage中的pageNum效果一样-->\n			<property name=\"offsetAsPageNum\" value=\"true\"/>\n			<!-- 该参数默认为false -->\n			<!-- 设置为true时，使用RowBounds分页会进行count查询 -->\n			<property name=\"rowBoundsWithCount\" value=\"true\"/>\n			<!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 -->\n			<!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）\n            <property name=\"pageSizeZero\" value=\"true\"/>-->\n			<!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 -->\n			<!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 -->\n			<!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 -->\n			<property name=\"reasonable\" value=\"true\"/>\n			<!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 -->\n			<!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 -->\n			<!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 -->\n			<!-- 不理解该含义的前提下，不要随便复制该配置\n            <property name=\"params\" value=\"pageNum=start;pageSize=limit;\"/>    -->\n		</plugin>\n	</plugins>\n\n	<!-- 在这里环境标签默认填写的是id为mysql的环境，与spring整合后就废除了环境标签 -->\n	<!-- 配置从哪里读取mapper文件 -->\n	<mappers>\n		<package name=\"cn.ljtnono.jsgl.dao\" />\n	</mappers>\n</configuration>\n```\n这里解释下各种参数：\n1、dialect  方言，相信大家不会陌生，就是配置数据库类型，常见的值有mysql、oracle、SqlServer等。这一项是必须配置的。\n2、增加offsetAsPageNum属性，默认值为false，则使用默认值时不需要增加该配置，需要设为真时，需要配置该参数。当该参数设置为真时，使用RowBounds分页时，会将偏移参数当成页次使用，可以用页码和页面大小两个参数进行分页。\n\n后面两个参数的作用在注释中解释的非常清楚了，这里不再赘述，关于参数还有好几个，大家可以查看https://github.com/pagehelper/Mybatis-PageHelper github官方文档。\n\n然后就是使用了，这里以查询一个竞赛列表信息为例子。\n\n```\n@Override\n    public PageInfo<Contest> getContestListByModality(int modality, int currentPage) {\n\n        Map<String,Object> map = new HashMap<>(1);\n        PageInfo<Contest> pageInfo = null;\n        map.put(\"modality\",modality);\n        try {\n            PageHelper.startPage(currentPage,CURRENTCOUNT);\n            List<Contest> list = contestDaoMapper.selectByModality(map);\n            pageInfo = new PageInfo<>(list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pageInfo;\n    }\n```\n在PageHelper.startPage() 后面的第一个查询会默认使用分页查询，也就是说不必自己再写一个sql去查询总的条数。查询出来的结果使用pageInfo这个类进行接收。\n\nPageInfo这个类中封装了分页所需要的各种参数，十分方便。\n\n下面贴出PageInfo的源代码：\n```\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.github.pagehelper;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class PageInfo<T> implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private int pageNum;\n    private int pageSize;\n    private int size;\n    private int startRow;\n    private int endRow;\n    private long total;\n    private int pages;\n    private List<T> list;\n    private int firstPage;\n    private int prePage;\n    private int nextPage;\n    private int lastPage;\n    private boolean isFirstPage;\n    private boolean isLastPage;\n    private boolean hasPreviousPage;\n    private boolean hasNextPage;\n    private int navigatePages;\n    private int[] navigatepageNums;\n    ........\n   }\n\n```\n参数解释：\npageNum ：当前页码数。\npageSize ： 每一页装的条数。\nsize ： 查询出来的总的页数。\nstartRow ：从哪一条开始查询的。\nendRow ： 哪一条结束。\ntotal ： 总的条数。\npages ： 总的页数。\nlist ： 记录集合。\nfirstPage ： 第一页。\nprePage ： 上一页。\nnextPage ： 下一页。\nlastPage ： 最后一页。\nisFirstPage ： 是否是第一页。\nisLastPage ：是否是最后一页。\nhasPreviousPage ： 是否有前一页。\nhasNextPage ： 是否有后一页。\nnavigatePages ： 导航总的页数。\nnavigatepageNums ： 页数集合。即从第一页到最后一页的页码数。\n\n这个类使用真的很方便，可以直接使用EL表达式来取值。\n\n在jsp中使用EL表达式取值：\n\ncontest.jsp :\n```\n<tbody>\n     <c:forEach items=\"${pageInfo.list}\" var=\"contest\">\n                <tr>\n                    <td>\n                            ${contest.theam}\n                    </td>\n                    <td class=\"modality\">\n                        <c:if test=\"${contest.modality == 0}\">\n                            个人\n                        </c:if>\n                        <c:if test=\"${contest.modality == 1}\">\n                            团队\n                        </c:if>\n                        <c:if test=\"${contest.modality == 2}\">\n                            个人/团队\n                        </c:if>\n                    </td>\n                    <td>${contest.way}</td>\n                    <td>${contest.deadline}</td>\n                    <td>${contest.startTime}</td>\n                    <td>${contest.endTime}</td>\n                    <td>\n                        <input type=\"button\" value=\"操作\" class=\"signUpOne btn btn-xs\" data-contestId=\"${contest.id}\">\n                    </td>\n                </tr>\n            </c:forEach>\n            </tbody>\n```\n\n以上就是最简单的pageHelper使用教程了，如果需要深入了解使用方式，请参考github：https://github.com/pagehelper/Mybatis-PageHelper。','一直以来都用的是自己封装的一个pageBean类来处理分页相关的业务，这个pageBean是从传智播客的视频上面学到的，最近看到别人写的都是用的mybatis的pageHelper,所以自己也心痒痒，将自己的一个竞赛管理系统的分页也换成了pageHelper的方式。话不多说，直接上配置。首先要使用m','2018-11-30 23:56:25','2018-11-30 23:56:28',3,1,1,86,9,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(3,'spring aop 小结','<p>说到spring框架，大家都不会陌生，但是说到aop，可能有很多人只是听说过这个名词，但是对什么是aop以及怎么使用aop存在很多疑惑，正好最近在学spring的aop思想，现做如下总结：</p>\n<h2 id=\"h2--aop\"><a name=\"一、什么是aop\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、什么是aop</h2><p>大家可能都听说过oop，即面向对象的编程事项，与传统的面向过程的编程方法不同的是，oop思想讲究将服务（也就是函数方法）和数据（成员变量）封装成对象，由对象来调用方法，从而实现功能。因此，我们需要编写很多的类来实现我们需要的功能。但是，这种方式会导致类过多，而一些通用的方法虽然可以通过重构手法可以提取出来，但是还是有一些不足，那就是不能够自动化。我们希望能够在自动的增强某个函数的功能，不需要在每次调用的地方写任何代码，只需要写一次就OK。在这样的需求下，aop思想诞生了。aop—-自动增强函数方法的思想，面向切面的编程方法。</p>\n<p>下面一张图可以让你更加了解什么是aop思想：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-4b5298e806abb641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>也就是说如果有多个Service，aop就是研究怎么将安全，事务，其他这几个模块加入到service中去。下面我就用在java和spring环境下做实验。</p>\n<h2 id=\"h2--java-spring-aop\"><a name=\"二、java、spring环境下的aop\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、java、spring环境下的aop</h2><p>spring中自己对aop有一套实现，底层用的是jdk的动态代理和cglib代理，但是spring发现Aspectj对aop思想的实现更加方便我们开发，所以，spring运用拿来主义，将Aspectj中的aop实现整合到spring框架中了，所以本篇只讨论Aspectj中的aop实现，工作中一般也只用到Aspectj的aop实现。</p>\n<p>首先我们搭建一下spring的环境：maven   pom.xml如下：</p>\n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;AspectjDemo&lt;/groupId&gt;\n  &lt;artifactId&gt;cn.ljtnono&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;AspectDemo&lt;/name&gt;\n\n    &lt;dependencies&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n          &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n          &lt;version&gt;1.7.2&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;log4j&lt;/groupId&gt;\n          &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n          &lt;version&gt;1.2.12&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;junit&lt;/groupId&gt;\n          &lt;artifactId&gt;junit&lt;/artifactId&gt;\n          &lt;version&gt;4.12&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\n      &lt;/dependency&gt;\n\n      &lt;!-- cglib代理模式  类模式代理 --&gt;\n      &lt;dependency&gt;\n        &lt;groupId&gt;cglib&lt;/groupId&gt;\n        &lt;artifactId&gt;cglib&lt;/artifactId&gt;\n        &lt;version&gt;3.2.8&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;source&gt;1.8&lt;/source&gt;\n          &lt;target&gt;1.8&lt;/target&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre><p>项目结构图如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-6b89631f0bd6ee9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>这里先创建一个切面t类，这是一个普通的pojo类。（不知道什么是切面？<a href=\"https://www.jianshu.com/p/e2046e43cc3d\">点击这里</a>）</p>\n<pre><code>package cn.ljtnono.aop;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n//@Aspect\n@Component(\"Aspect1\")\npublic class Aspect1 {\n\n    //@Before(\"execution( * *..SomeService*.firstService(..))\")\n    public void myBefore() {\n        System.out.println(\"这是一个前置通知\");\n    }\n}\n</code></pre><p>创建一个方法，一个前置通知。编写要增强的类的接口以及实现类</p>\n<pre><code>package cn.ljtnono.service;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\n\npublic interface SomeService {\n\n\n    void firstService();\n\n    void secondService();\n\n    void thiredService();\n}\n</code></pre><pre><code>package cn.ljtnono.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service(value=\"SomeService\")\npublic class SomeServiceImpl  {\n\n\n    public void firstService() {\n        // TODO Auto-generated method stub\n        System.out.println(\"======执行了firstService方法\");\n    }\n\n\n    public void secondService() {\n        // TODO Auto-generated method stub\n        System.out.println(\"======执行了secondService方法\");\n\n    }\n\n\n    public void thiredService() {\n        // TODO Auto-generated method stub\n\n        System.out.println(\"======执行了thiredService方法\");\n    }\n\n\n\n}\n</code></pre><p>在spring配置文件中配置：</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://www.springframework.org/schema/mvc\n                        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://mybatis.org/schema/mybatis-spring\n                        http://mybatis.org/schema/mybatis-spring.xsd\n                        http://www.springframework.org/schema/cache\n                        http://www.springframework.org/schema/cache/spring-cache-3.1.xsd\n                        http://www.springframework.org/schema/aop\n                        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\"&gt;\n\n    &lt;!-- 开启注解配置 --&gt;\n    &lt;context:component-scan base-package=\"cn.ljtnono\" /&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:pointcut expression=\"execution( * *..SomeService*.firstService(..))\" id=\"myPointCut\"/&gt;\n        &lt;aop:aspect ref=\"Aspect1\"&gt;\n            &lt;aop:before method=\"myBefore\" pointcut-ref=\"myPointCut\"/&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n\n&lt;/beans&gt;\n</code></pre><p>aop:config中的配置：首先要配置一个切入点，然后配置切面的实现。这里应该容易理解。这其中需要aspect类和目标对象被容器识别，也就是必须交给spring管理这两个对象。其中execution表达式详解见我的另一篇博文。</p>\n<p>现在测试：</p>\n<pre><code>package cn.ljtnono.test;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport cn.ljtnono.service.SomeService;\nimport cn.ljtnono.service.SomeServiceImpl;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class Aspect1Test {\n\n\n\n\n    @Test\n    public void testBefore() {\n\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        SomeServiceImpl service = (SomeServiceImpl) ac.getBean(\"SomeService\");\n        service.firstService();\n    }\n}\n</code></pre><p><img src=\"https://upload-images.jianshu.io/upload_images/13105398-47c3a1fe9d8a5782.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>至此，一个简单的aop demo完成了，有不懂的可以查看以下资料：</p>\n<p>AOP execution表达式详解：<a href=\"https://www.jianshu.com/u/0eac251981be\">https://www.jianshu.com/u/0eac251981be</a></p>','说到spring框架，大家都不会陌生，但是说到aop，可能有很多人只是听说过这个名词，但是对什么是aop以及怎么使用aop存在很多疑惑，正好最近在学spring的aop思想，现做如下总结：\n\n##一、什么是aop\n大家可能都听说过oop，即面向对象的编程事项，与传统的面向过程的编程方法不同的是，oop思想讲究将服务（也就是函数方法）和数据（成员变量）封装成对象，由对象来调用方法，从而实现功能。因此，我们需要编写很多的类来实现我们需要的功能。但是，这种方式会导致类过多，而一些通用的方法虽然可以通过重构手法可以提取出来，但是还是有一些不足，那就是不能够自动化。我们希望能够在自动的增强某个函数的功能，不需要在每次调用的地方写任何代码，只需要写一次就OK。在这样的需求下，aop思想诞生了。aop---自动增强函数方法的思想，面向切面的编程方法。\n\n下面一张图可以让你更加了解什么是aop思想：\n![](https://upload-images.jianshu.io/upload_images/13105398-4b5298e806abb641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也就是说如果有多个Service，aop就是研究怎么将安全，事务，其他这几个模块加入到service中去。下面我就用在java和spring环境下做实验。\n\n##二、java、spring环境下的aop\nspring中自己对aop有一套实现，底层用的是jdk的动态代理和cglib代理，但是spring发现Aspectj对aop思想的实现更加方便我们开发，所以，spring运用拿来主义，将Aspectj中的aop实现整合到spring框架中了，所以本篇只讨论Aspectj中的aop实现，工作中一般也只用到Aspectj的aop实现。\n\n首先我们搭建一下spring的环境：maven   pom.xml如下：\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>AspectjDemo</groupId>\n  <artifactId>cn.ljtnono</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>AspectDemo</name>\n  \n    <dependencies>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-aop</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-aspects</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-beans</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-context</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-context-support</artifactId>\n  		<version>5.0.8.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-core</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-expression</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.slf4j</groupId>\n  		<artifactId>slf4j-log4j12</artifactId>\n  		<version>1.7.2</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>log4j</groupId>\n  		<artifactId>log4j</artifactId>\n  		<version>1.2.12</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>junit</groupId>\n  		<artifactId>junit</artifactId>\n  		<version>4.12</version>\n  	</dependency>\n  	<dependency>\n  		<groupId>org.springframework</groupId>\n  		<artifactId>spring-test</artifactId>\n  		<version>4.2.4.RELEASE</version>\n  	</dependency>\n  	\n  	<!-- cglib代理模式  类模式代理 -->\n  	<dependency>\n	    <groupId>cglib</groupId>\n	    <artifactId>cglib</artifactId>\n	    <version>3.2.8</version>\n	</dependency>\n    </dependencies>\n  \n  <build>\n    <plugins>\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n```\n项目结构图如下：\n![](https://upload-images.jianshu.io/upload_images/13105398-6b89631f0bd6ee9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里先创建一个切面t类，这是一个普通的pojo类。（不知道什么是切面？[点击这里](https://www.jianshu.com/p/e2046e43cc3d)）\n```\npackage cn.ljtnono.aop;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n//@Aspect\n@Component(\"Aspect1\")\npublic class Aspect1 {\n	\n	//@Before(\"execution( * *..SomeService*.firstService(..))\")\n	public void myBefore() {\n		System.out.println(\"这是一个前置通知\");\n	}\n}\n\n```\n创建一个方法，一个前置通知。编写要增强的类的接口以及实现类\n```\npackage cn.ljtnono.service;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\n \npublic interface SomeService {\n	\n	\n	void firstService();\n	\n	void secondService();\n	\n	void thiredService();\n}\n\n```\n```\npackage cn.ljtnono.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service(value=\"SomeService\")\npublic class SomeServiceImpl  {\n\n	\n	public void firstService() {\n		// TODO Auto-generated method stub\n		System.out.println(\"======执行了firstService方法\");\n	}\n\n	\n	public void secondService() {\n		// TODO Auto-generated method stub\n		System.out.println(\"======执行了secondService方法\");\n\n	}\n\n	\n	public void thiredService() {\n		// TODO Auto-generated method stub\n\n		System.out.println(\"======执行了thiredService方法\");\n	}\n	\n	\n\n}\n```\n在spring配置文件中配置：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	   xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"\n	   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	   xmlns:p=\"http://www.springframework.org/schema/p\"\n	   xmlns:context=\"http://www.springframework.org/schema/context\"\n	   xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	   xmlns:aop=\"http://www.springframework.org/schema/aop\"\n	   xmlns:tx=\"http://www.springframework.org/schema/tx\"\n	   xmlns:cache=\"http://www.springframework.org/schema/cache\"\n	   xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n			            http://www.springframework.org/schema/beans/spring-beans.xsd\n			            http://www.springframework.org/schema/context\n			            http://www.springframework.org/schema/context/spring-context.xsd\n			            http://www.springframework.org/schema/mvc\n			            http://www.springframework.org/schema/mvc/spring-mvc.xsd\n			            http://www.springframework.org/schema/tx\n			            http://www.springframework.org/schema/tx/spring-tx.xsd\n			            http://mybatis.org/schema/mybatis-spring\n			            http://mybatis.org/schema/mybatis-spring.xsd\n						http://www.springframework.org/schema/cache\n						http://www.springframework.org/schema/cache/spring-cache-3.1.xsd\n						http://www.springframework.org/schema/aop\n        				http://www.springframework.org/schema/aop/spring-aop-3.1.xsd\">\n	\n	<!-- 开启注解配置 -->\n	<context:component-scan base-package=\"cn.ljtnono\" />\n	\n	<aop:config>\n		<aop:pointcut expression=\"execution( * *..SomeService*.firstService(..))\" id=\"myPointCut\"/>\n		<aop:aspect ref=\"Aspect1\">\n			<aop:before method=\"myBefore\" pointcut-ref=\"myPointCut\"/>\n		</aop:aspect>\n	</aop:config>\n	\n</beans>\n```\naop:config中的配置：首先要配置一个切入点，然后配置切面的实现。这里应该容易理解。这其中需要aspect类和目标对象被容器识别，也就是必须交给spring管理这两个对象。其中execution表达式详解见我的另一篇博文。\n\n现在测试：\n```\npackage cn.ljtnono.test;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport cn.ljtnono.service.SomeService;\nimport cn.ljtnono.service.SomeServiceImpl;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class Aspect1Test {\n	\n	\n	\n	\n	@Test\n	public void testBefore() {\n		\n		ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n		SomeServiceImpl service = (SomeServiceImpl) ac.getBean(\"SomeService\");\n		service.firstService();\n	}\n}\n\n```\n![](https://upload-images.jianshu.io/upload_images/13105398-47c3a1fe9d8a5782.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，一个简单的aop demo完成了，有不懂的可以查看以下资料：\n\n\nAOP execution表达式详解：https://www.jianshu.com/u/0eac251981be\n\n\n\n','说到spring框架，大家都不会陌生，但是说到aop，可能有很多人只是听说过这个名词，但是对什么是aop以及怎么使用aop存在很多疑惑，正好最近在学spring的aop思想，现做如下总结：##一、什么是aop大家可能都听说过oop，即面向对象的编程事项，与传统的面向过程的编程方法不同的是，oop思想','2018-11-30 23:57:52','2018-11-30 23:57:54',4,2,1,124,8,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(4,'Aspectj aop 名词解释','<p>这里对aop一些术语进行解释：<br>   1.通知（Advice）<br>      就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。<br>  2.连接点（JoinPoint）<br>   这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。<br>  3.切入点（Pointcut）<br>   上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。<br>  4.切面（Aspect）<br>   切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。<br>  5.引入（introduction）<br>   允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗<br>  6.目标（target）<br>   引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。<br>  7.代理(proxy)<br>   怎么实现整套aop机制的，都是通过代理，这个一会给细说。<br>   8.织入(weaving)<br>   把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。<br>关键就是：切点定义了哪些连接点会得到通知\n<hr>\n<p>本文来自 yuanye348623610 的CSDN 博客 ，全文地址请点击：<a href=\"https://blog.csdn.net/yuanye348623610/article/details/8823429?utm_source=copy\">https://blog.csdn.net/yuanye348623610/article/details/8823429?utm_source=copy</a> </p>','这里对aop一些术语进行解释：\n   1.通知（Advice）   \n      就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。\n  2.连接点（JoinPoint）\n   这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。\n  3.切入点（Pointcut）\n   上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。\n  4.切面（Aspect）\n   切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。\n  5.引入（introduction）\n   允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗\n  6.目标（target）\n   引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。\n  7.代理(proxy)\n   怎么实现整套aop机制的，都是通过代理，这个一会给细说。\n   8.织入(weaving)\n   把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。\n关键就是：切点定义了哪些连接点会得到通知\n\n---------------------\n\n本文来自 yuanye348623610 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/yuanye348623610/article/details/8823429?utm_source=copy ','这里对aop一些术语进行解释：   1.通知（Advice）         就是你想要的功能，也就是上面说的安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。  2.连接点（JoinPoint）   这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后','2018-11-30 23:59:38','2018-11-30 23:59:41',5,3,1,44,8,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(5,'Aspectj execution表达式','<p>Aspectj切入点语法定义</p>\n<p>在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut”切入点”</p>\n<p>例如定义切入点表达式  execution (<em> com.sample.service.impl..</em>.*(..))</p>\n<p>execution()是最常用的切点函数，其语法如下所示：</p>\n<p> 整个表达式可以分为五个部分：</p>\n<p> 1、execution(): 表达式主体。</p>\n<p> 2、第一个<em>号：表示返回类型，</em>号表示所有的类型。</p>\n<p> 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。</p>\n<p> 4、第二个<em>号：表示类名，</em>号表示所有的类。</p>\n<p> 5、<em>(..):最后这个星号表示方法名，</em>号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。</p>\n<p>AspectJ的Execution表达式</p>\n<p>execution()</p>\n<p>execution()是最常用的切点函数，其语法如下所示：</p>\n<p>execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)<br>  除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。与其直接讲解该方法的使用规则，还不如通过一个个具体的例子进行理解。下面，我们给出各种使用execution()函数实例。\n<p>1)通过方法签名定义切点</p>\n<p> execution(public <em> </em>(..))l</p>\n<p>匹配所有目标类的public方法，但不匹配SmartSeller和protected void showGoods()方法。第一个<em>代表返回类型，第二个</em>代表方法名，而..代表任意入参的方法；</p>\n<p> execution(<em> </em>To(..))l</p>\n<p>匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个<em>代表返回类型，而</em>To代表任意以To为后缀的方法；</p>\n<p>2)通过类定义切点</p>\n<p> execution(<em> com.baobaotao.Waiter.</em>(..))l</p>\n<p>匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个<em>代表返回任意类型，com.baobaotao.Waiter.</em>代表Waiter接口中的所有方法；</p>\n<p> execution(<em> com.baobaotao.Waiter+.</em>(..))l</p>\n<p>匹 配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这 两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter 接口中定义的方法。</p>\n<p>3)通过类包定义切点</p>\n<p>在类名模式串中，“.<em>”表示包下的所有类，而“..</em>”表示包、子孙包下的所有类。</p>\n<p> execution(<em> com.baobaotao.</em>(..))l</p>\n<p>匹配com.baobaotao包下所有类的所有方法；</p>\n<p> execution(<em> com.baobaotao..</em>(..))l</p>\n<p>匹 配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及 com.baobaotao.dao.user包下的所有类的所有方法都匹配。“..”出现在类名中时，后面必须跟“*”，表示包、子孙包下的所有类；</p>\n<p> execution(<em> com..</em>.<em>Dao.find</em>(..))l</p>\n<p>匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。</p>\n<p>4)通过方法入参定义切点</p>\n<p>切点表达式中方法入参部分比较复杂，可以使用“<em>”和“ ..”通配符，其中“</em>”表示任意类型的参数，而“..”表示任意类型参数且参数个数不限。</p>\n<p> execution(* joke(String,int)))l</p>\n<p>匹 配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配 NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是java.lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)；</p>\n<p> execution(<em> joke(String,</em>)))l</p>\n<p>匹 配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(String s1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,double d2,String s3)则不匹配；</p>\n<p> execution(* joke(String,..)))l</p>\n<p>匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(String s1)、joke(String s1,String s2)和joke(String s1,double d2,String s3)都匹配。</p>\n<p> execution(* joke(Object+)))l</p>\n<p>匹 配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(String s1)和joke(Client c)。如果我们定义的切点是execution(* joke(Object))，则只匹配joke(Object object)而不匹配joke(String cc)或joke(Client c)。</p>\n<p>args()和<a href=\"https://github.com/args\" title=\"@args\" class=\"at-link\">@args</a>()</p>\n<p>args()函数的入参是类名，<a href=\"https://github.com/args\" title=\"@args\" class=\"at-link\">@args</a>()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。</p>\n<p>1)args()</p>\n<p>该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：</p>\n<p>args(com.baobaotao.Waiter)</p>\n<p>表 示运行时入参是Waiter类型的方法，它和execution(<em> </em>(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如 args(com.baobaotao.Waiter)既匹配于addWaiter(Waiter waiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(<em> </em>(com.baobaotao.Waiter))只匹配addWaiter(Waiter<br> waiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(<em> </em>(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。</p>\n<p>2)<a href=\"https://github.com/args\" title=\"@args\" class=\"at-link\">@args</a>()</p>\n<p>该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。这个切点函数的匹配规则不太容易理解，我们通过以下示意图对此进行详细讲解：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13105398-f02203f4cd9dae39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\">\n<p>转自：<a href=\"https://blog.csdn.net/lang_niu/article/details/51559994\">https://blog.csdn.net/lang_niu/article/details/51559994</a></p>','Aspectj切入点语法定义\n\n\n\n\n在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut\"切入点\"\n\n例如定义切入点表达式  execution (* com.sample.service.impl..*.*(..))\n\nexecution()是最常用的切点函数，其语法如下所示：\n\n 整个表达式可以分为五个部分：\n\n 1、execution(): 表达式主体。\n\n 2、第一个*号：表示返回类型，*号表示所有的类型。\n\n 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。\n\n 4、第二个*号：表示类名，*号表示所有的类。\n\n 5、*(..):最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。\n\n \n\n\n\nAspectJ的Execution表达式\n\nexecution()\n\nexecution()是最常用的切点函数，其语法如下所示：\n\n \n\nexecution(<修饰符模式>? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?)\n  除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。与其直接讲解该方法的使用规则，还不如通过一个个具体的例子进行理解。下面，我们给出各种使用execution()函数实例。\n\n \n\n1)通过方法签名定义切点\n\n execution(public * *(..))l\n\n匹配所有目标类的public方法，但不匹配SmartSeller和protected void showGoods()方法。第一个*代表返回类型，第二个*代表方法名，而..代表任意入参的方法；\n\n \n\n execution(* *To(..))l\n\n匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个*代表返回类型，而*To代表任意以To为后缀的方法；\n\n \n\n2)通过类定义切点\n\n execution(* com.baobaotao.Waiter.*(..))l\n\n匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个*代表返回任意类型，com.baobaotao.Waiter.*代表Waiter接口中的所有方法；\n\n \n\n execution(* com.baobaotao.Waiter+.*(..))l\n\n匹 配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这 两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter 接口中定义的方法。\n\n \n\n3)通过类包定义切点\n\n在类名模式串中，“.*”表示包下的所有类，而“..*”表示包、子孙包下的所有类。\n\n execution(* com.baobaotao.*(..))l\n\n匹配com.baobaotao包下所有类的所有方法；\n\n \n\n execution(* com.baobaotao..*(..))l\n\n匹 配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及 com.baobaotao.dao.user包下的所有类的所有方法都匹配。“..”出现在类名中时，后面必须跟“*”，表示包、子孙包下的所有类；\n\n \n\n execution(* com..*.*Dao.find*(..))l\n\n匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。\n\n \n\n4)通过方法入参定义切点\n\n切点表达式中方法入参部分比较复杂，可以使用“*”和“ ..”通配符，其中“*”表示任意类型的参数，而“..”表示任意类型参数且参数个数不限。\n\n \n\n execution(* joke(String,int)))l\n\n匹 配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配 NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是java.lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)；\n\n \n\n execution(* joke(String,*)))l\n\n匹 配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(String s1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,double d2,String s3)则不匹配；\n\n \n\n execution(* joke(String,..)))l\n\n匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(String s1)、joke(String s1,String s2)和joke(String s1,double d2,String s3)都匹配。\n\n \n\n execution(* joke(Object+)))l\n\n匹 配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(String s1)和joke(Client c)。如果我们定义的切点是execution(* joke(Object))，则只匹配joke(Object object)而不匹配joke(String cc)或joke(Client c)。\n\n \n\nargs()和@args()\n\nargs()函数的入参是类名，@args()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。\n\n \n\n1)args()\n\n该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：\n\nargs(com.baobaotao.Waiter)\n\n表 示运行时入参是Waiter类型的方法，它和execution(* *(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如 args(com.baobaotao.Waiter)既匹配于addWaiter(Waiter waiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(* *(com.baobaotao.Waiter))只匹配addWaiter(Waiter\n waiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(* *(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。\n\n \n\n2)@args()\n\n该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。这个切点函数的匹配规则不太容易理解，我们通过以下示意图对此进行详细讲解：\n\n\n![image.png](https://upload-images.jianshu.io/upload_images/13105398-f02203f4cd9dae39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n转自：https://blog.csdn.net/lang_niu/article/details/51559994','Aspectj切入点语法定义在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut\"切入点\"例如定义切入点表达式  execution(*com.sample.service.impl..*.*(..))execution()是最常用的切点函数，其语','2018-12-01 00:03:18','2018-12-01 00:03:20',6,4,0,29,8,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(6,'java IO流-基本概念','<p>一个好的编程语言应该具有良好的io系统。java能够火这么多年其io系统功不可没。</p>\n<p>流的概念：流式一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>\n<p>流的分类：<br>按数据方向分：输入流和输出流<br>输入流：InputStream/Reader<br>输出流：OutputStream/Writer<br>按数据类型分：字节流和字符流<br>字节流：InputStream/OutputStream<br>字符流：Reader/Writer\n<p>下图是常用的IO流：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-e349b4e03fef2cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>关于字节流和字符流的区别<br>1、字节流和字符流的时候，读到一个字节就返回一个字节。<br>字符流使用了字节流读到一个或多个字节（中文对应的字节是两个，UTF-8码表中是三个）时，先去查指定的编码表，将查到的字符返回。<br>2、字符流可以初六所有数据，如图片，MP3等，字符流只能处理文本。<br>3、能使用字符流就使用字符流，不能就使用字节流。','一个好的编程语言应该具有良好的io系统。java能够火这么多年其io系统功不可没。\n\n流的概念：流式一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。\n\n流的分类：\n按数据方向分：输入流和输出流\n输入流：InputStream/Reader\n输出流：OutputStream/Writer\n按数据类型分：字节流和字符流\n字节流：InputStream/OutputStream\n字符流：Reader/Writer\n\n下图是常用的IO流：\n![](https://upload-images.jianshu.io/upload_images/13105398-e349b4e03fef2cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n关于字节流和字符流的区别\n1、字节流和字符流的时候，读到一个字节就返回一个字节。\n字符流使用了字节流读到一个或多个字节（中文对应的字节是两个，UTF-8码表中是三个）时，先去查指定的编码表，将查到的字符返回。\n2、字符流可以初六所有数据，如图片，MP3等，字符流只能处理文本。\n3、能使用字符流就使用字符流，不能就使用字节流。','一个好的编程语言应该具有良好的io系统。java能够火这么多年其io系统功不可没。流的概念：流式一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据时，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其','2018-12-01 00:05:39','2018-12-01 00:05:41',7,5,0,21,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(7,'java IO流-常用流','<p>根据java类之间的关系，整理出java常用IO流之间的UML类图<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-14ee140748acb8c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>初学UML，如果有错的话请谅解，这里面只写了关键的方法。</p>\n<p><code>字节输入流：InputStream类为所有自己输入流的父类</code><br><code>主要方法有三个：</code></p>\n<p><code>int read()</code><br><code>从流里面读出一个字节。不推荐使用</code><br><code>int read(byte[] b)</code><br><code>将数据读入到字节数组中，并返回所读的字节数</code><br><code>inte read(byte[] b,int off,int len)</code><br><code>off 从哪里开始读</code><br><code>len读取多少</code><br><code>将输入流中最多len个数据字节读入字节数组</code></p>\n<p><code>其他方法：</code><br><code>void close()</code><br><code>关闭流资源</code><br><code>int available()</code><br><code>返回不受阻塞地从此输入流读取的字节数</code><br><code>long skip(long n)</code><br><code>跳过和放弃此输入流中的n个数据字节，该方法有可能失效</code><br><code>boolean markSupported()</code><br><code>测试此输入流是否支持mark和reset方法</code><br><code>void mark(int n)</code><br><code>在此输入流中标记当前的位置</code><br><code>void reset()</code><br><code>将此流重新定位到对此输入流最后调用mark方法时的位置。</code></p>\n<p><code>字节输出流：OutputStream是所有字节输出流的父类。</code><br><code>三个基本的write()方法：</code><br><code>void write(int n)</code><br><code>将指定的字节写入此输出流。</code><br><code>void write(byte[] b)</code><br><code>将b.length个字节从指定的字节数组写入此输出流</code><br><code>void write(byte[] b,int off,int len)</code><br><code>将指定字节数组中从偏移量off开始的len个字节写入此输出流</code></p>\n<p><code>其他方法：</code><br><code>void close()</code><br><code>关闭此输出流并释放与此流有关的所有系统资源</code><br><code>void flush()</code><br><code>刷新此输出流并强制写出所有缓冲的输出字节</code></p>\n<p>文件输入输出流：FileInputStream和FileOutputStream,要构造一个FileInputStream，所关联的文件必须存在并且可读。</p>\n<pre><code>FileInputStream fis = new FileInputStream(\"demo.java\");\n</code></pre><p>要构造一个FileOutputStream,而输出文件已经存在，则它将被覆盖</p>\n<pre><code>FileOutputStream fos = new FileInputStream(\"results.dat\");\n</code></pre><p>想要以追加的方式写，则需要一个额外的参数，如：</p>\n<pre><code>FileOutputStream outfile = new FileOutputStream(\"results.dat\",true);\n</code></pre><p>字符流：Reader和Writer所有字符流的父类型。<br>java技术使用Unicode来表示字符串和字符，而且提供16位版本的流，以便用类似的方法处理字符。如果构造了一个连接到流的Reader和Writer，转换规则会在使用缺省平台所定义的字节编码和Unicode之间切换。<br>桥梁流：InputStreamReader和OutputStreamWriter(字节流转换成字符流的转换器)<br>这两个类不是用于直接输入输出的，他是将字节流转换成字符流的桥转换器，并可以指定编解码方式。<br>逐行读写流：BufferedReader/BufferedWriter<br>以上两个都是过滤流，需要用其他的节点流来作为参数的构造对象。<br>BufferedReader的方法：readLine():String，当他的返回值是null时，就表示读取完毕了。要注意，在写入时要注意写换行符，否则会出现阻塞。<br>BufferedWriter的方法：newLine(),这个方法会写出一个换行符。<br>管道流:线程交互的时候使用<br>PipedInputStream/PipedOutputStream<br>传送输出流可以连接到传送输入流，以创建通信管道。传送输出流是管道的发送端。通常，数据由某个线程写入PipedOutputStream对象，并由其他线程从连接的PipedInputStream读取。','根据java类之间的关系，整理出java常用IO流之间的UML类图\n![](https://upload-images.jianshu.io/upload_images/13105398-14ee140748acb8c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n初学UML，如果有错的话请谅解，这里面只写了关键的方法。\n\n`字节输入流：InputStream类为所有自己输入流的父类`\n`主要方法有三个：`\n\n`int read()`\n`从流里面读出一个字节。不推荐使用`\n`int read(byte[] b)`\n`将数据读入到字节数组中，并返回所读的字节数`\n`inte read(byte[] b,int off,int len)`\n`off 从哪里开始读`\n`len读取多少`\n`将输入流中最多len个数据字节读入字节数组`\n\n`其他方法：`\n`void close()`\n`关闭流资源`\n`int available()`\n`返回不受阻塞地从此输入流读取的字节数`\n`long skip(long n)`\n`跳过和放弃此输入流中的n个数据字节，该方法有可能失效`\n`boolean markSupported()`\n`测试此输入流是否支持mark和reset方法`\n`void mark(int n)`\n`在此输入流中标记当前的位置`\n`void reset()`\n`将此流重新定位到对此输入流最后调用mark方法时的位置。`\n\n`字节输出流：OutputStream是所有字节输出流的父类。`\n`三个基本的write()方法：`\n`void write(int n)`\n`将指定的字节写入此输出流。`\n`void write(byte[] b)`\n`将b.length个字节从指定的字节数组写入此输出流`\n`void write(byte[] b,int off,int len)`\n`将指定字节数组中从偏移量off开始的len个字节写入此输出流`\n\n`其他方法：`\n`void close()`\n`关闭此输出流并释放与此流有关的所有系统资源`\n`void flush()`\n`刷新此输出流并强制写出所有缓冲的输出字节`\n\n文件输入输出流：FileInputStream和FileOutputStream,要构造一个FileInputStream，所关联的文件必须存在并且可读。\n```\nFileInputStream fis = new FileInputStream(\"demo.java\");\n```\n要构造一个FileOutputStream,而输出文件已经存在，则它将被覆盖\n```\nFileOutputStream fos = new FileInputStream(\"results.dat\");\n```\n想要以追加的方式写，则需要一个额外的参数，如：\n```\nFileOutputStream outfile = new FileOutputStream(\"results.dat\",true);\n```\n\n字符流：Reader和Writer所有字符流的父类型。\njava技术使用Unicode来表示字符串和字符，而且提供16位版本的流，以便用类似的方法处理字符。如果构造了一个连接到流的Reader和Writer，转换规则会在使用缺省平台所定义的字节编码和Unicode之间切换。\n桥梁流：InputStreamReader和OutputStreamWriter(字节流转换成字符流的转换器)\n这两个类不是用于直接输入输出的，他是将字节流转换成字符流的桥转换器，并可以指定编解码方式。\n逐行读写流：BufferedReader/BufferedWriter\n以上两个都是过滤流，需要用其他的节点流来作为参数的构造对象。\nBufferedReader的方法：readLine():String，当他的返回值是null时，就表示读取完毕了。要注意，在写入时要注意写换行符，否则会出现阻塞。\nBufferedWriter的方法：newLine(),这个方法会写出一个换行符。\n管道流:线程交互的时候使用\nPipedInputStream/PipedOutputStream\n传送输出流可以连接到传送输入流，以创建通信管道。传送输出流是管道的发送端。通常，数据由某个线程写入PipedOutputStream对象，并由其他线程从连接的PipedInputStream读取。\n','根据java类之间的关系，整理出java常用IO流之间的UML类图![](https://upload-images.jianshu.io/upload_images/13105398-14ee140748acb8c8.png?imageMogr2/auto-orient/strip%7Cimage','2018-12-01 00:06:39','2018-12-01 00:06:40',8,6,2,65,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(8,'java IO-File类的基本使用','<p>【创建一个新的文件】</p>\n<pre><code>package cn.ljtnono.io;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * File 类的基本使用方式\n * @author Administrator\n *\n */\npublic class UseFile {\n\n\n\n    /**\n     * 创建一个新的File\n     */\n    public static void createNewFile(String filePath) throws IllegalArgumentException{\n        if (filePath == null || filePath.isEmpty()) {\n            throw new IllegalArgumentException(\"请指定正确的文件路径！\");\n        }\n        File file = new File(filePath);\n        if (file.exists()) {\n            System.out.println(\"当前File已经存在\");\n        } else {\n            try {\n                file.createNewFile();\n                System.out.println(\"文件创建成功！\");\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                System.out.println(\"create File failed!\");\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        createNewFile(\"Demo.txt\");\n        System.out.println(File.separator);\n        System.out.println(File.pathSeparator);\n    }\n\n    //怎么判断一个文件的路径是合法的\n}\n</code></pre><p>运行结果：在eclipse项目的根目录创建了一个Demo.txt的文件。</p>\n<p>【删除一个文件】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"Demo.txt\";\n        File file = new File(fileName);\n        if (file.exists()) {\n            file.delete();\n        } else {\n            System.out.println(\"文件不存在！\");\n        }\n    }\n</code></pre><p>运行结果：删除了创建的Demo.txt文件</p>\n<p>【创建一个文件夹】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"Demo\";\n        File file = new File(fileName);\n        file.mkdir();\n    }\n</code></pre><p>运行结果：在eclipse项目的根目录下创建一个名为Demo的文件夹</p>\n<p>【列出指定目录的全部文件（包括隐藏文件）】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"src\";\n        File file = new File(fileName);\n        String[] list = file.list();\n        for (String f : list) {\n            System.out.println(f);\n        }\n    }\n</code></pre><p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-b97d6a0ece71426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>由于没有做是文件还是文件夹的判断，所以显示的是main和test文件夹。\n<p>【判断文件是否是目录】</p>\n<pre><code>public static void main(String[] args) {\n        String fileName = \"src\";\n        File file = new File(fileName);\n        if (file.isDirectory()) {\n            System.out.println(\"文件是目录！\");\n        } else {\n            System.out.println(\"文件不是目录！\");\n        }\n    }\n</code></pre><p>运行结果：文件是目录</p>\n<p>【搜索指定目录的全部内容】</p>\n<pre><code>//搜索指定目录的全部内容\n    public static void main(String[] args) {\n        String fileName = \"src\";\n        File file = new File(fileName);\n        print(file);\n    }\n\n    public static void print(File f) {\n        if (f != null) {\n            if (f.isDirectory()) {\n                File[] fileArray = f.listFiles();\n                if (fileArray != null) {\n                    for (int i = 0; i &lt; fileArray.length;i++) {\n                        print(fileArray[i]);\n                    }\n                }\n            }\n            else {\n                System.out.println(f);\n            }\n        }\n    }\n</code></pre><p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/13105398-1de2559d7fe7c991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">\n<p>【使用RandomAccessFile写入文件】</p>\n<pre><code>    public static void main(String[] args) throws IOException {\n        String fileName = \"hello.txt\";\n        File f = new File(fileName);\n        RandomAccessFile demo = new RandomAccessFile(f,\"rw\");\n        demo.writeBytes(\"asdsad\");\n        demo.writeInt(12);\n        demo.writeBoolean(true);\n        demo.writeChar(\'A\');\n        demo.writeFloat(1.21f);\n        demo.writeDouble(12.123);\n        demo.close();\n    }\n</code></pre><p>运行结果：在eclipse根目录下的hello.txt文件中写入了各种数据，但是打开看的话发现是乱码。</p>\n<p>【文件的复制】</p>\n<pre><code>public static void main(String[] args) throws IOException {\n        //1.创建两个File\n        String sourcePath = \"bmp.bmp\";\n        String targetPath = \"bb.bmp\";\n        File source = new File(sourcePath);\n        File target = new File(targetPath);\n        if (!source.exists()) {\n            System.out.println(\"原文件不存在！\");\n        } else {\n            // 2. 创建输入流\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));\n            byte[] buff = new byte[bis.available()];\n            //3.创建输出流\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(target));\n\n            while (bis.read(buff, 0, buff.length) != -1) {\n                bos.write(buff, 0, buff.length);\n            }\n            bis.close();\n            bos.close();\n        }\n    }\n</code></pre><p>运行结果：复制了bmp.bmp文件</p>','【创建一个新的文件】\n```\npackage cn.ljtnono.io;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * File 类的基本使用方式\n * @author Administrator\n *\n */\npublic class UseFile {\n\n	\n	\n	/**\n	 * 创建一个新的File\n	 */\n	public static void createNewFile(String filePath) throws IllegalArgumentException{\n		if (filePath == null || filePath.isEmpty()) {\n			throw new IllegalArgumentException(\"请指定正确的文件路径！\");\n		}\n		File file = new File(filePath);\n		if (file.exists()) {\n			System.out.println(\"当前File已经存在\");\n		} else {\n			try {\n				file.createNewFile();\n				System.out.println(\"文件创建成功！\");\n			} catch (IOException e) {\n				// TODO Auto-generated catch block\n				System.out.println(\"create File failed!\");\n				e.printStackTrace();\n			}\n		}\n	}\n	\n	public static void main(String[] args) {\n		createNewFile(\"Demo.txt\");\n		System.out.println(File.separator);\n		System.out.println(File.pathSeparator);\n	}\n	\n	//怎么判断一个文件的路径是合法的\n}\n```\n运行结果：在eclipse项目的根目录创建了一个Demo.txt的文件。\n\n【删除一个文件】\n```\npublic static void main(String[] args) {\n		String fileName = \"Demo.txt\";\n		File file = new File(fileName);\n		if (file.exists()) {\n			file.delete();\n		} else {\n			System.out.println(\"文件不存在！\");\n		}\n	}\n```\n运行结果：删除了创建的Demo.txt文件\n\n【创建一个文件夹】\n```\npublic static void main(String[] args) {\n		String fileName = \"Demo\";\n		File file = new File(fileName);\n		file.mkdir();\n	}\n```\n运行结果：在eclipse项目的根目录下创建一个名为Demo的文件夹\n\n【列出指定目录的全部文件（包括隐藏文件）】\n```\npublic static void main(String[] args) {\n		String fileName = \"src\";\n		File file = new File(fileName);\n		String[] list = file.list();\n		for (String f : list) {\n			System.out.println(f);\n		}\n	}\n```\n运行结果：\n![](https://upload-images.jianshu.io/upload_images/13105398-b97d6a0ece71426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n由于没有做是文件还是文件夹的判断，所以显示的是main和test文件夹。\n\n【判断文件是否是目录】\n```\npublic static void main(String[] args) {\n		String fileName = \"src\";\n		File file = new File(fileName);\n		if (file.isDirectory()) {\n			System.out.println(\"文件是目录！\");\n		} else {\n			System.out.println(\"文件不是目录！\");\n		}\n	}\n```\n运行结果：文件是目录\n\n【搜索指定目录的全部内容】\n```\n//搜索指定目录的全部内容\n	public static void main(String[] args) {\n		String fileName = \"src\";\n		File file = new File(fileName);\n		print(file);\n	}\n	\n	public static void print(File f) {\n		if (f != null) {\n			if (f.isDirectory()) {\n				File[] fileArray = f.listFiles();\n				if (fileArray != null) {\n					for (int i = 0; i < fileArray.length;i++) {\n						print(fileArray[i]);\n					}\n				}\n			}\n			else {\n				System.out.println(f);\n			}\n		}\n	}\n```\n运行结果：\n![](https://upload-images.jianshu.io/upload_images/13105398-1de2559d7fe7c991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n【使用RandomAccessFile写入文件】\n```\n	public static void main(String[] args) throws IOException {\n		String fileName = \"hello.txt\";\n		File f = new File(fileName);\n		RandomAccessFile demo = new RandomAccessFile(f,\"rw\");\n		demo.writeBytes(\"asdsad\");\n		demo.writeInt(12);\n		demo.writeBoolean(true);\n		demo.writeChar(\'A\');\n		demo.writeFloat(1.21f);\n		demo.writeDouble(12.123);\n		demo.close();\n	}\n```\n运行结果：在eclipse根目录下的hello.txt文件中写入了各种数据，但是打开看的话发现是乱码。\n\n【文件的复制】\n```\npublic static void main(String[] args) throws IOException {\n		//1.创建两个File\n		String sourcePath = \"bmp.bmp\";\n		String targetPath = \"bb.bmp\";\n		File source = new File(sourcePath);\n		File target = new File(targetPath);\n		if (!source.exists()) {\n			System.out.println(\"原文件不存在！\");\n		} else {\n			// 2. 创建输入流\n			BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));\n			byte[] buff = new byte[bis.available()];\n			//3.创建输出流\n			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(target));\n			\n			while (bis.read(buff, 0, buff.length) != -1) {\n				bos.write(buff, 0, buff.length);\n			}\n			bis.close();\n			bos.close();\n		}\n	}\n```\n运行结果：复制了bmp.bmp文件\n','【创建一个新的文件】packagecn.ljtnono.io;importjava.io.File;importjava.io.IOException;/***File类的基本使用方式*@authorAdministrator**/publicclassUseFile{/***创建一个新的File*','2018-12-01 00:06:39','2018-12-01 00:06:40',9,7,1,26,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(9,'java IO流小结','<p>1、字节与字符的区别：一个字节占8个bit，范围是-128—127，一个字符占一个字节。汉字占两个字节。英文字符占一个字节。<br>2、字节输入流的抽象基类：InputStream常用的方法是read，这个方法重载了三个函数，分别对应一个一个字节的读取，字节数组的读取，控制长度字节数组的读取方式。其中read()无参方法是抽象的，即读取一个字节。<br>3、字节输出流的抽象基类：OutputStream常用的方法是write，这个方法也重载了三个函数，分别对应的是一个一个字节的写入，字节数组的写入，控制长度字节数组的写入方式。其中write(int b)方法是抽象的，即写一个字节。 这里是b的低8位被写入。 b的24个高位被忽略。','1、字节与字符的区别：一个字节占8个bit，范围是-128--127，一个字符占一个字节。汉字占两个字节。英文字符占一个字节。\n2、字节输入流的抽象基类：InputStream常用的方法是read，这个方法重载了三个函数，分别对应一个一个字节的读取，字节数组的读取，控制长度字节数组的读取方式。其中read()无参方法是抽象的，即读取一个字节。\n3、字节输出流的抽象基类：OutputStream常用的方法是write，这个方法也重载了三个函数，分别对应的是一个一个字节的写入，字节数组的写入，控制长度字节数组的写入方式。其中write(int b)方法是抽象的，即写一个字节。 这里是b的低8位被写入。 b的24个高位被忽略。\n','1、字节与字符的区别：一个字节占8个bit，范围是-128—127，一个字符占一个字节。汉字占两个字节。英文字符占一个字节。2、字节输入流的抽象基类：InputStream常用的方法是read，这个方法重载了三个函数，分别对应一个一个字节的读取，字节数组的读取，控制长度字节数组的读取方式。其中rea','2018-12-01 00:06:39','2018-12-01 00:06:40',10,8,0,20,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(10,'Effictive Java','<h2 id=\"h2--\"><a name=\"第二章 创建和销毁对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第二章 创建和销毁对象</h2><p><img src=\"images/blog/java.jpg\" alt=\"\"></p>\n<p><strong>第2条：遇到多个构造器参数时要考虑用构建器</strong></p>\n<p>如果一个类有很多参数，例如考虑一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等，这样的类该怎么去定义呢？</p>\n<p><strong>常见的定义方式</strong></p>\n<pre><code class=\"lang-java\">public class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n\n    public NutritionFacts(param1,param2....) {\n\n    }\n\n}\n</code></pre>\n<p>这种方式通过构造器的方式直接将字段的实际值传入，然后根据这些值创建一个对象，这样做通常需要定义多个重载的构造器，然而，一旦参数非常多的情况下（多余5个）那么使用这个构造器会很繁琐，程序员一般不会记得这么多的构造函数。所以，为了减少繁琐的构造函数，可以采用JavaBean的方式进行，一般情况下就是采用的JavaBean的方式。</p>\n<p><strong>使用JavaBean的方式进行定义</strong></p>\n<pre><code class=\"lang-java\">public class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n   //各种set get 函数\n\n}\n</code></pre>\n<p>使用JavaBean的模式时候将每个字段的set函数单独分离出来，然后程序员调用的时候大概会如下面这样</p>\n<pre><code class=\"lang-java\">NutritionFacts ntf = new NutritionFacts();\nntf.setXXX(val);\nntf.setXXX(val);\nntf.setXXX(val);\n</code></pre>\n<p>可以看到，这样做解决了构造函数参数过长的问题，但是却存在了一个新的问题，那就是每次setXXX的时候导致此对象的状态不一致，如果是在多线程的条件下可能会出现严重的问题，（不知所云的，但是书上这么说的，不知道为什么？）</p>\n<p>为了解决这个问题，推荐使用建造者模式。</p>\n<p><strong>使用建造者模式</strong></p>\n<pre><code class=\"lang-java\">public class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n\n    public static class Builder {\n        //Required paramters\n        private final int servingSize;\n        private final int servings;\n        //Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int carbohydrate = 0;\n        private int sodium = 0;\n\n        public Builder calories(int val) {\n            calories = val; \n            return this;\n        }\n        public Builder fat(int val) {\n            fat = val;\n        }\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n        }\n        public Builder NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n\n    }\n}\n</code></pre>\n<p>建造者模式是在需要创建对象的类里面定义一个内部类，然后通过这个内部类来实现set函数的功能，不同的是set函数返回void，而建造者类的函数返回本身，这样就实现了链式编程的原理。</p>\n','## 第二章 创建和销毁对象\n![](images/blog/java.jpg)\n\n**第2条：遇到多个构造器参数时要考虑用构建器**\n\n如果一个类有很多参数，例如考虑一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等，这样的类该怎么去定义呢？\n\n\n\n**常见的定义方式**\n\n```java\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n    \n    public NutritionFacts(param1,param2....) {\n        \n    }\n    \n}\n```\n\n这种方式通过构造器的方式直接将字段的实际值传入，然后根据这些值创建一个对象，这样做通常需要定义多个重载的构造器，然而，一旦参数非常多的情况下（多余5个）那么使用这个构造器会很繁琐，程序员一般不会记得这么多的构造函数。所以，为了减少繁琐的构造函数，可以采用JavaBean的方式进行，一般情况下就是采用的JavaBean的方式。\n\n**使用JavaBean的方式进行定义**\n\n```java\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n   //各种set get 函数\n    \n}\n```\n\n使用JavaBean的模式时候将每个字段的set函数单独分离出来，然后程序员调用的时候大概会如下面这样\n\n```java\nNutritionFacts ntf = new NutritionFacts();\nntf.setXXX(val);\nntf.setXXX(val);\nntf.setXXX(val);\n```\n\n可以看到，这样做解决了构造函数参数过长的问题，但是却存在了一个新的问题，那就是每次setXXX的时候导致此对象的状态不一致，如果是在多线程的条件下可能会出现严重的问题，（不知所云的，但是书上这么说的，不知道为什么？）\n\n\n\n为了解决这个问题，推荐使用建造者模式。\n\n**使用建造者模式**\n\n```java\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private fianl int carbohydrate;\n    \n    public static class Builder {\n        //Required paramters\n        private final int servingSize;\n        private final int servings;\n        //Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int carbohydrate = 0;\n        private int sodium = 0;\n        \n        public Builder calories(int val) {\n            calories = val; \n            return this;\n        }\n        public Builder fat(int val) {\n            fat = val;\n        }\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n        }\n        public Builder NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n    \n    private NutritionFacts(Builder builder) {\n        \n    }\n}\n```\n\n建造者模式是在需要创建对象的类里面定义一个内部类，然后通过这个内部类来实现set函数的功能，不同的是set函数返回void，而建造者类的函数返回本身，这样就实现了链式编程的原理。','第二章 创建和销毁对象\n第2条：遇到多个构造器参数时要考虑用构建器\n如果一个类有很多参数，例如考虑一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的：每份的含量、每罐的含量以及每份的卡路里，还有超过20个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等，这样的类该怎么去定义呢','2018-12-18 11:22:28','2018-12-18 11:22:28',11,9,8,82,1,'973ff24c034a4d029a73b4d95f8aeb26',1),(11,'springmvc注解开发','<h1 id=\"h1-spring-\"><a name=\"Spring注解开发\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring注解开发</h1><p>使用<a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a> 、 <a href=\"https://github.com/service\" title=\"&#64;service\" class=\"at-link\">@service</a> 、<a href=\"https://github.com/Repository\" title=\"&#64;Repository\" class=\"at-link\">@Repository</a> 这样的注解进行开发已经是很平常的事情了，这里不再详述了</p>\n<h2 id=\"h2--configuration-\"><a name=\"使用@Configuration注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用<a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>注解</h2><p><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>注解是一个spring注解，这个注解用于告诉spring框架这是一个配置类，这里配置的Bean要交给Spring去管理。来看看这个注解的具体内容</p>\n<pre><code class=\"lang-java\">@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Configuration {\n    String value() default &quot;&quot;;\n}\n</code></pre>\n<h2 id=\"h2--componentscan-\"><a name=\"@ComponentScan 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a> 注解</h2><p>这个注解和xml文件中的context:component-scan 这个属性是一模一样的。包括属性。这里有一个例子</p>\n<pre><code class=\"lang-java\">package cn.ljtnono.myblog.config;\n\nimport cn.ljtnono.myblog.utils.SpringUtil;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\n\n/**\n *  配置了各种bean\n *  @author ljt\n *  @date 2018/12/17\n *  @version 1.0\n */\n@Configuration\n@ComponentScan(value = {&quot;cn.ljtnono.myblog&quot;,&quot;cn.ljtnono.myblog.aspect&quot;},excludeFilters = {\n        @ComponentScan.Filter(Controller.class),\n        @ComponentScan.Filter(Aspect.class)\n})\npublic class MainConfig {\n\n    /**\n     * 配置一个SpringUtil 用来在任何环境下能够获取ioc容器中的Bean\n     * @return SpringUtil\n     */\n    @Bean\n    @Lazy //懒加载\n    public ApplicationContextAware setApplicationContextAware() {\n        return new SpringUtil();\n    }\n\n    /**\n     * 设置文件上传下载组件\n     * 这里name必须设置为multipartResolver\n     * @return CommonsMultipartResolver组件\n     */\n    @Bean(name = &quot;multipartResolver&quot;)\n    @Lazy\n    public CommonsMultipartResolver setCommonsMultipartResolver() {\n        CommonsMultipartResolver resolver = new CommonsMultipartResolver();\n        resolver.setMaxUploadSizePerFile(500000000);\n        resolver.setDefaultEncoding(&quot;UTF-8&quot;);\n        resolver.setResolveLazily(true);\n        return resolver;\n    }\n\n\n}\n</code></pre>\n<p>这里我是配置了一个文件上传的处理Bean和一个用于获取Bean的SpringUtil，这里都很好理解，主要是上面的</p>\n<p><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>注解的内容，我这里配置的value值是两个基础包，然后配置了不要扫描Controller层和切片层</p>\n<p>因为被Springmvc的配置文件已经扫描了。具体的内容就不详述。</p>\n<p><strong><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>注解</strong></p>\n<p>这个注解可以实现在一个配置类中引入另外一个配置类的相关配置</p>\n<pre><code class=\"lang-java\">@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n    Class&lt;?&gt;[] value();\n}\n</code></pre>\n<p>只需要传入class数组就OK</p>\n','# Spring注解开发\n\n使用@Controller 、 @service 、@Repository 这样的注解进行开发已经是很平常的事情了，这里不再详述了\n\n\n\n## 使用@Configuration注解\n\n@Configuration注解是一个spring注解，这个注解用于告诉spring框架这是一个配置类，这里配置的Bean要交给Spring去管理。来看看这个注解的具体内容\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Configuration {\n    String value() default \"\";\n}\n```\n\n\n\n## @ComponentScan 注解\n\n这个注解和xml文件中的context:component-scan 这个属性是一模一样的。包括属性。这里有一个例子\n\n```java\npackage cn.ljtnono.myblog.config;\n\nimport cn.ljtnono.myblog.utils.SpringUtil;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\n\n/**\n *  配置了各种bean\n *  @author ljt\n *  @date 2018/12/17\n *  @version 1.0\n */\n@Configuration\n@ComponentScan(value = {\"cn.ljtnono.myblog\",\"cn.ljtnono.myblog.aspect\"},excludeFilters = {\n        @ComponentScan.Filter(Controller.class),\n        @ComponentScan.Filter(Aspect.class)\n})\npublic class MainConfig {\n\n    /**\n     * 配置一个SpringUtil 用来在任何环境下能够获取ioc容器中的Bean\n     * @return SpringUtil\n     */\n    @Bean\n    @Lazy //懒加载\n    public ApplicationContextAware setApplicationContextAware() {\n        return new SpringUtil();\n    }\n\n    /**\n     * 设置文件上传下载组件\n     * 这里name必须设置为multipartResolver\n     * @return CommonsMultipartResolver组件\n     */\n    @Bean(name = \"multipartResolver\")\n    @Lazy\n    public CommonsMultipartResolver setCommonsMultipartResolver() {\n        CommonsMultipartResolver resolver = new CommonsMultipartResolver();\n        resolver.setMaxUploadSizePerFile(500000000);\n        resolver.setDefaultEncoding(\"UTF-8\");\n        resolver.setResolveLazily(true);\n        return resolver;\n    }\n\n\n}\n\n```\n\n这里我是配置了一个文件上传的处理Bean和一个用于获取Bean的SpringUtil，这里都很好理解，主要是上面的\n\n@ComponentScan注解的内容，我这里配置的value值是两个基础包，然后配置了不要扫描Controller层和切片层\n\n因为被Springmvc的配置文件已经扫描了。具体的内容就不详述。\n\n\n\n**@Import注解**\n\n这个注解可以实现在一个配置类中引入另外一个配置类的相关配置\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n    Class<?>[] value();\n}\n\n```\n\n只需要传入class数组就OK\n\n\n\n','Spring注解开发使用@Controller 、 @service 、@Repository 这样的注解进行开发已经是很平常的事情了，这里不再详述了\n使用@Configuration注解@Configuration注解是一个spring注解，这个注解用于告诉spring框架这是一个配置类，这里配置','2019-01-06 23:10:52','2019-01-06 23:10:52',12,10,0,35,10,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(12,'Spring源码阅读','<h3 id=\"h3-spring-factorybean-\"><a name=\"spring中FactoryBean的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>spring中FactoryBean的使用</h3><p>在spring中一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案，Spring提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户通过实现该接口定制实例化bean的逻辑</p>\n<pre><code class=\"lang-java\">package org.springframework.beans.factory;\n\npublic interface FactoryBean&lt;T&gt; {\n\n    //返回需要生产的bean\n    T getObject() throws Exception;\n    //bean的class属性\n    Class&lt;?&gt; getObjectType();\n    //是否是单例\n    boolean isSingleton();\n}\n</code></pre>\n<p>用户只需要实现这个接口，然后将接口的实例类配置到容器中，那么通过getBean得到的就是工厂生产的bean，在getBean使用&amp;前缀就是得到这个FactoryBean本身。这里写个例子看下</p>\n<pre><code class=\"lang-java\">package cn.ljtnono.pojo;\n\npublic class User {\n    private String username;\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n//然后再写一个UserFactory实现FactoryBean接口\npackage cn.ljtnono.pojo;\n\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class UserFactory implements FactoryBean&lt;User&gt; {\n\n    @Override\n    public User getObject() throws Exception {\n        User user = new User();\n        user.setUsername(&quot;zs&quot;);\n        user.setPassword(&quot;lisi&quot;);\n        return user;\n    }\n\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return User.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n//测试\n    @Test\n    public void test1() {\n        //1.获取当前IOC容器\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);\n        BeanFactory beanFactory = ((ClassPathXmlApplicationContext) context).getBeanFactory();\n        //Object user =  beanFactory.getBean(&quot;userFactory&quot;); cn.ljtnono.pojo.User@69930714\n        //Object user =  beanFactory.getBean(&quot;&amp;userFactory&quot;); cn.ljtnono.pojo.UserFactory@69930714\n        System.out.println(user);\n    }\n</code></pre>\n<p>可以看到，如果加上&amp;获取的是UserFactory类型，不加上获取的是User类型。</p>\n','### spring中FactoryBean的使用\n\n在spring中一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案，Spring提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户通过实现该接口定制实例化bean的逻辑\n\n```java\npackage org.springframework.beans.factory;\n\npublic interface FactoryBean<T> {\n\n	//返回需要生产的bean\n	T getObject() throws Exception;\n	//bean的class属性\n	Class<?> getObjectType();\n	//是否是单例\n	boolean isSingleton();\n}\n\n```\n\n用户只需要实现这个接口，然后将接口的实例类配置到容器中，那么通过getBean得到的就是工厂生产的bean，在getBean使用&前缀就是得到这个FactoryBean本身。这里写个例子看下\n\n```java\npackage cn.ljtnono.pojo;\n\npublic class User {\n    private String username;\n    private String password;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n\n\n//然后再写一个UserFactory实现FactoryBean接口\npackage cn.ljtnono.pojo;\n\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class UserFactory implements FactoryBean<User> {\n\n    @Override\n    public User getObject() throws Exception {\n        User user = new User();\n        user.setUsername(\"zs\");\n        user.setPassword(\"lisi\");\n        return user;\n    }\n\n\n    @Override\n    public Class<?> getObjectType() {\n        return User.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n//测试\n    @Test\n    public void test1() {\n        //1.获取当前IOC容器\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n        BeanFactory beanFactory = ((ClassPathXmlApplicationContext) context).getBeanFactory();\n        //Object user =  beanFactory.getBean(\"userFactory\"); cn.ljtnono.pojo.User@69930714\n        //Object user =  beanFactory.getBean(\"&userFactory\"); cn.ljtnono.pojo.UserFactory@69930714\n        System.out.println(user);\n    }\n```\n\n可以看到，如果加上&获取的是UserFactory类型，不加上获取的是User类型。','spring中FactoryBean的使用在spring中一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息，配置方式的灵活性是受限的，这时采用','2019-01-08 00:15:20','2019-01-08 00:15:20',13,11,1,63,8,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(13,'JS表单验证','<h2 id=\"h2-u5173u4E8Eu8868u5355u7684u63D0u4EA4u9A8Cu8BC1\"><a name=\"关于表单的提交验证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于表单的提交验证</h2><p>表单的提交验证是通过调用表单的onsubmit方法来实现提交的，这里我们可以使用JS监听表单的onsubmit方法来实现对表单元素的验证</p>\n<p>例如：</p>\n<pre><code class=\"lang-html\">&lt;form action=&quot;${basePath}back/login&quot; method=&quot;post&quot; id=&quot;loginform&quot;&gt;\n                &lt;div class=&quot;layui-form&quot;&gt;\n                    &lt;div class=&quot;layui-form-item&quot;&gt;\n                        &lt;input type=&quot;text&quot; name=&quot;user&quot; class=&quot;layui-input user&quot; placeholder=&quot;用户名&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;layui-form-item&quot;&gt;\n                        &lt;input type=&quot;password&quot; name=&quot;psw&quot; class=&quot;layui-input psw&quot; placeholder=&quot;密码&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;layui-form-item&quot; style=&quot;margin-top: 60px;&quot;&gt;\n                        &lt;div class=&quot;layui-input-block&quot;&gt;\n                            &lt;input class=&quot;layui-btn submit&quot; type=&quot;submit&quot; value=&quot;登陆&quot;/&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/form&gt;\n</code></pre>\n<p>这里使用JQuery来实现对表单的验证</p>\n<pre><code class=\"lang-javascript\">//输入过滤\n    $(&quot;#loginform&quot;).submit(function () {\n        const $user = $(&quot;.user&quot;);\n        const $psw = $(&quot;.psw&quot;);\n        if (testUser($user)) {\n            //发送请求\n            if (testPsw($psw)) {\n                return true;\n            } else {\n                layui.use(&quot;layer&quot;, function () {\n                    layer.msg(&quot;密码不能为空！&quot;);\n                });\n                return false;\n            }\n        } else {\n            layui.use(&quot;layer&quot;, function () {\n                layer.msg(&quot;请检查用户名的正确性！用户名不能包含中文，是数字和字母的6-10位组合&quot;);\n            });\n            return false;\n        }\n    });\n</code></pre>\n<p>说明：监听onsibmit方法的时候</p>\n<p>返回 false 不进行提交表单</p>\n<p>返回 true 提交表单</p>\n<p>默认返回 true</p>\n','## 关于表单的提交验证\n\n表单的提交验证是通过调用表单的onsubmit方法来实现提交的，这里我们可以使用JS监听表单的onsubmit方法来实现对表单元素的验证\n\n例如：\n\n```html\n<form action=\"${basePath}back/login\" method=\"post\" id=\"loginform\">\n                <div class=\"layui-form\">\n                    <div class=\"layui-form-item\">\n                        <input type=\"text\" name=\"user\" class=\"layui-input user\" placeholder=\"用户名\">\n                    </div>\n                    <div class=\"layui-form-item\">\n                        <input type=\"password\" name=\"psw\" class=\"layui-input psw\" placeholder=\"密码\">\n                    </div>\n                    <div class=\"layui-form-item\" style=\"margin-top: 60px;\">\n                        <div class=\"layui-input-block\">\n                            <input class=\"layui-btn submit\" type=\"submit\" value=\"登陆\"/>\n                        </div>\n                    </div>\n                </div>\n            </form>\n```\n\n这里使用JQuery来实现对表单的验证\n\n```javascript\n//输入过滤\n    $(\"#loginform\").submit(function () {\n        const $user = $(\".user\");\n        const $psw = $(\".psw\");\n        if (testUser($user)) {\n            //发送请求\n            if (testPsw($psw)) {\n                return true;\n            } else {\n                layui.use(\"layer\", function () {\n                    layer.msg(\"密码不能为空！\");\n                });\n                return false;\n            }\n        } else {\n            layui.use(\"layer\", function () {\n                layer.msg(\"请检查用户名的正确性！用户名不能包含中文，是数字和字母的6-10位组合\");\n            });\n            return false;\n        }\n    });\n```\n\n说明：监听onsibmit方法的时候\n\n返回 false 不进行提交表单\n\n返回 true 提交表单\n\n默认返回 true','关于表单的提交验证表单的提交验证是通过调用表单的onsubmit方法来实现提交的，这里我们可以使用JS监听表单的onsubmit方法来实现对表单元素的验证\n例如：\n&lt;form action=&quot;${basePath}back/login&quot; method=&quot;post&','2019-01-08 00:36:31','2019-01-08 00:36:31',14,12,0,9,5,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(14,'java代码改善','<h2 id=\"h2--equals-hashcode-\"><a name=\"关于覆盖equals和hashCode方法的一些建议和想法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于覆盖equals和hashCode方法的一些建议和想法</h2><p>1、 当类是私有的或者包级私有（不加任何修饰符）,如果你确定它的equals方法永远也不会被调用。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用。</p>\n<pre><code class=\"lang-java\">@Override\npublic boolean equals(Object 0) {\n    throw new AssertionError(); // Method is never called;\n}\n</code></pre>\n<h2 id=\"h2-u4EE3u7801u8D28u91CFu6539u5584\"><a name=\"代码质量改善\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码质量改善</h2><p>1、工具类如果没有必要，那么请将其构造函数私有化，防止不必要的创建其对象实体</p>\n<p>2、在for循环中尽量不要重复创建对象的引用，例如</p>\n<pre><code class=\"lang-java\">for (int i = 0 ; i &lt; 10; i++) {\n    Object o = new Object();\n}\n\n//应该改成\nObject o = null;\nfor (int i = 0; i &lt; 10; i++) {\n    o = new Object();\n}\n</code></pre>\n<h2 id=\"h2-comparable-comparator-\"><a name=\"Comparable 和 Comparator接口的学习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Comparable 和 Comparator接口的学习</h2><p>Comparable接口只有一个方法</p>\n<pre><code class=\"lang-java\">public interface Comparable&lt;T&gt; {\n\n    public int comparaTo(T o);\n\n}\n</code></pre>\n<p>Comparable可以认为是一个<strong>内比较器</strong>，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为<strong>自然比较方法</strong>。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：</p>\n<p>1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数</p>\n<p>2、比较者等于被比较者，那么返回0</p>\n<p>3、比较者小于被比较者，那么返回负整数</p>\n<p><strong>Comparator</strong></p>\n<p>Comparator可以认为是是一个<strong>外比较器</strong>，个人认为有两种情况可以使用实现Comparator接口的方式：</p>\n<p>1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较</p>\n<p>2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式</p>\n<p>Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：</p>\n<p>1、o1大于o2，返回正整数</p>\n<p>2、o1等于o2，返回0</p>\n<p>3、o1小于o3，返回负整数</p>\n<p><strong>总结：Comparable接口是一个内比较器，主要用于同一类型的数据对自己进行比较，Comparator接口主要用于实现外比较，就是实现不同对象之间的比较。</strong></p>\n<h2 id=\"h2-u547Du540Du89C4u8303\"><a name=\"命名规范\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命名规范</h2><h3 id=\"h3--strong-strong-\"><a name=\"<strong>驼峰法则：</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>驼峰法则：</strong></h3><p>将所有字母都小写(包括缩写)，然后将单词的第一个字母大写。</p>\n<p>每个单词的第一个字母都大写，来得到<strong>大驼峰</strong>式命名。</p>\n<p>除了第一个单词，每个单词的第一个字母都大写，来得到<strong>(小)驼峰</strong>式命名。</p>\n<p>为避免歧义，文中小驼峰法统称为驼峰法，大驼峰/帕斯卡法统称为大驼峰法则。</p>\n<h2 id=\"h2-1-package\"><a name=\"1. Package\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Package</h2><p>项目包命名规则：&lt;域名反转&gt;.&lt;团队名&gt;.&lt;项目名&gt;。相关项目可使用&lt;域名反转&gt;.&lt;团队名&gt;.&lt;父项目名&gt;.&lt;子项目名&gt;的命名法则。</p>\n<p>命名必须全部使用英文小写字母，禁止使用“下划线”等字符。（除常量外，Java命名习惯中均不推荐使用下划线等字符）</p>\n<p>示例：</p>\n<pre><code>com.cnblogs.niceboat.soyteam.anticorruptionsystem\n</code></pre><h2 id=\"h2-2-class-object-interface\"><a name=\"2. Class/Object、Interface\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Class/Object、Interface</h2><p>类和接口使用大驼峰命名法</p>\n<p>抽象类使用“Abstract”做为类命名的开头</p>\n<p>Exception类命名使用“Exception”做为类命名的结尾</p>\n<p>Test类使用“Test”做为类命名的结尾</p>\n<p>在面向接口编程中，接口的实现类的命名规则为：&lt;接口名&gt;+”Impl”。禁止使用匈牙利命名法。</p>\n<p>示例（正确）：</p>\n<table>\n<thead>\n<tr>\n<th><strong>接口</strong></th>\n<th><strong>实现类</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HandsomeProvider</td>\n<td>HandsomeProviderImpl</td>\n</tr>\n</tbody>\n</table>\n<p>匈牙利命名法（不推荐）：</p>\n<table>\n<thead>\n<tr>\n<th><strong>接口</strong></th>\n<th><strong>实现类</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IHandsomeProvider</td>\n<td>HandsomeProvider</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-3-method-function\"><a name=\"3. Method/Function\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Method/Function</h2><p>方法的命名使用驼峰法，一般使用动词或动词+名词组合。</p>\n<p>设置/获取某个值的方法，命名为setV/getV</p>\n<p>返回长度的方法，命名为length</p>\n<p>判断布尔值的方法，命名为isV</p>\n<p>将对象转换为某个特定类型的方法应该命名为toT</p>\n<p>示例：</p>\n<table>\n<thead>\n<tr>\n<th>getSecretStage()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>length()</td>\n</tr>\n<tr>\n<td>isEmpty()</td>\n</tr>\n<tr>\n<td>toSpecialFormat()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-4-variable\"><a name=\"4. Variable\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Variable</h2><p>变量的命名使用驼峰法</p>\n<p>示例：</p>\n<pre><code>OpenId\n</code></pre><p>常量命名使用大写字母并用下划线分割</p>\n<p>示例：</p>\n<pre><code>MAX_SUITABLE_SIZE\n</code></pre><h2 id=\"h2--equals-hashcode-\"><a name=\"关于重载equals和hashCode方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于重载equals和hashCode方法</h2><pre><code>/**\n * 通用equals重载方法的写法\n * @param o 需要比较的对象\n * @return true 相等  false 不相等\n */\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    //如果类型不一样那么直接返回false 这里可以自定义相关的比较功能\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    Img img = (Img) o;\n    return Objects.equals(id, img.id) &amp;&amp;\n            Objects.equals(title, img.title) &amp;&amp;\n            Objects.equals(type, img.type) &amp;&amp;\n            Objects.equals(src, img.src) &amp;&amp;\n            Objects.equals(updateDateTime, img.updateDateTime) &amp;&amp;\n            Objects.equals(createDateTime, img.createDateTime);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(id, title, type, src, updateDateTime, createDateTime);\n}\n</code></pre>','## 关于覆盖equals和hashCode方法的一些建议和想法\n\n1、 当类是私有的或者包级私有（不加任何修饰符）,如果你确定它的equals方法永远也不会被调用。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用。\n\n```java\n@Override\npublic boolean equals(Object 0) {\n    throw new AssertionError(); // Method is never called;\n}\n```\n\n\n\n## 代码质量改善\n\n1、工具类如果没有必要，那么请将其构造函数私有化，防止不必要的创建其对象实体\n\n2、在for循环中尽量不要重复创建对象的引用，例如\n\n```java\nfor (int i = 0 ; i < 10; i++) {\n    Object o = new Object();\n}\n\n//应该改成\nObject o = null;\nfor (int i = 0; i < 10; i++) {\n    o = new Object();\n}\n\n```\n\n\n\n\n\n## Comparable 和 Comparator接口的学习\n\nComparable接口只有一个方法\n\n```java\npublic interface Comparable<T> {\n  \n    public int comparaTo(T o);\n    \n}\n```\n\nComparable可以认为是一个**内比较器**，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为**自然比较方法**。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：\n\n1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数\n\n2、比较者等于被比较者，那么返回0\n\n3、比较者小于被比较者，那么返回负整数\n\n\n\n**Comparator**\n\nComparator可以认为是是一个**外比较器**，个人认为有两种情况可以使用实现Comparator接口的方式：\n\n1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较\n\n2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式\n\nComparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：\n\n1、o1大于o2，返回正整数\n\n2、o1等于o2，返回0\n\n3、o1小于o3，返回负整数\n\n**总结：Comparable接口是一个内比较器，主要用于同一类型的数据对自己进行比较，Comparator接口主要用于实现外比较，就是实现不同对象之间的比较。**\n\n## 命名规范\n\n### **驼峰法则：**\n\n将所有字母都小写(包括缩写)，然后将单词的第一个字母大写。\n\n每个单词的第一个字母都大写，来得到**大驼峰**式命名。\n\n除了第一个单词，每个单词的第一个字母都大写，来得到**(小)驼峰**式命名。\n\n \n\n为避免歧义，文中小驼峰法统称为驼峰法，大驼峰/帕斯卡法统称为大驼峰法则。\n\n## 1. Package\n\n项目包命名规则：<域名反转>.<团队名>.<项目名>。相关项目可使用<域名反转>.<团队名>.<父项目名>.<子项目名>的命名法则。\n\n命名必须全部使用英文小写字母，禁止使用“下划线”等字符。（除常量外，Java命名习惯中均不推荐使用下划线等字符）\n\n示例：\n\n```\ncom.cnblogs.niceboat.soyteam.anticorruptionsystem\n```\n\n \n\n## 2. Class/Object、Interface\n\n类和接口使用大驼峰命名法\n\n抽象类使用“Abstract”做为类命名的开头\n\nException类命名使用“Exception”做为类命名的结尾\n\nTest类使用“Test”做为类命名的结尾\n\n在面向接口编程中，接口的实现类的命名规则为：<接口名>+\"Impl\"。禁止使用匈牙利命名法。\n\n示例（正确）：\n\n| **接口**         | **实现类**           |\n| ---------------- | -------------------- |\n| HandsomeProvider | HandsomeProviderImpl |\n\n匈牙利命名法（不推荐）：\n\n| **接口**          | **实现类**       |\n| ----------------- | ---------------- |\n| IHandsomeProvider | HandsomeProvider |\n\n## 3. Method/Function\n\n方法的命名使用驼峰法，一般使用动词或动词+名词组合。\n\n设置/获取某个值的方法，命名为setV/getV\n\n返回长度的方法，命名为length\n\n判断布尔值的方法，命名为isV\n\n将对象转换为某个特定类型的方法应该命名为toT\n\n示例：\n\n| getSecretStage()  |\n| ----------------- |\n| length()          |\n| isEmpty()         |\n| toSpecialFormat() |\n\n## 4. Variable\n\n变量的命名使用驼峰法\n\n示例：\n\n```\nOpenId\n```\n\n常量命名使用大写字母并用下划线分割\n\n示例：\n\n```\nMAX_SUITABLE_SIZE\n```\n\n\n\n## 关于重载equals和hashCode方法\n\n```\n/**\n * 通用equals重载方法的写法\n * @param o 需要比较的对象\n * @return true 相等  false 不相等\n */\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    //如果类型不一样那么直接返回false 这里可以自定义相关的比较功能\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    Img img = (Img) o;\n    return Objects.equals(id, img.id) &&\n            Objects.equals(title, img.title) &&\n            Objects.equals(type, img.type) &&\n            Objects.equals(src, img.src) &&\n            Objects.equals(updateDateTime, img.updateDateTime) &&\n            Objects.equals(createDateTime, img.createDateTime);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(id, title, type, src, updateDateTime, createDateTime);\n}\n```\n\n','关于覆盖equals和hashCode方法的一些建议和想法1、 当类是私有的或者包级私有（不加任何修饰符）,如果你确定它的equals方法永远也不会被调用。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用。\n@Override\npublic boolean equals(Objec','2019-01-08 00:38:47','2019-01-08 00:38:47',15,13,0,3,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(15,'Springmvc异常处理','<h2 id=\"h2-springmvc-\"><a name=\"springmvc中异常的处理方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc中异常的处理方式</h2><p>springmvc中主要提供了两种处理异常的方式</p>\n<ul>\n<li>使用SimpleMappingExceptionResolver</li><li>使用<a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a>注解实现局部异常处理或使用<a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a>注解实现统一异常处理</li></ul>\n<p>1、SimpleMappingExceptionResolver方式</p>\n<p>这种方式其实很简单，主要是在xml文件中进行一些简单的配置就OK了</p>\n<p>例如：</p>\n<pre><code class=\"lang-xml\">&lt;!--配置异常处理bean--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot; &gt;\n        &lt;!--表示所有没有指定的异常全部由defaultError.jsp进行处理--&gt;\n        &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot; /&gt;\n        &lt;!--配置在页面中访问的异常对象的名字\n            也就是说，在所有的页面中都可以通过EL表达式的来访问ex这个变量，进而获取异常信息进行处理\n        --&gt;\n        &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot; /&gt;\n        &lt;property name=&quot;exceptionMappings&quot; &gt;\n            &lt;props&gt;\n                &lt;prop key=&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;/defaultError&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>实际上就是配置一个bean，这个bean是SimpleMappingExceptionResolver的实例</p>\n<p>这里主要就是配置三个属性</p>\n<ul>\n<li>defaultErroeView就是默认异常跳转的页面，这里需要注意的是不能直接写成xxx.jsp或者xxx.html，而是需要根据你当前的springmvc的视图解析的环境进行设置。</li><li>exceptionAttribute 这个属性是配置返回视图时携带的参数的名称，这里设置为ex，到了JSP环境中就可以使用El表达式获取相关错误信息。例如${ex.message}</li><li>exceptionMappings 这个属性主要是设置某个具体的异常跳转的页面，这是一个数组，里面的子标签props的key属性配置的是处理的异常的全限定类名，然后值也是根据当前的springmvc的配置进行跳转的请求URL。</li></ul>\n<p>2、使用<a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a>注解进行异常处理</p>\n<p>这个注解可以声明在一个方法上</p>\n<pre><code class=\"lang-java\">@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface ExceptionHandler {\n\n    /**\n     * Exceptions handled by the annotated method. If empty, will default to any\n     * exceptions listed in the method argument list.\n     */\n    Class&lt;? extends Throwable&gt;[] value() default {};\n\n}\n</code></pre>\n<p>接收具体的类作为一个参数，然后如果抛出了这个异常那么就使用这个方法进行处理，但是据李刚的疯狂讲义上面说这个注解需要这个函数声明在controller中，例如</p>\n<pre><code class=\"lang-java\">@Controller\npublic class BlogController {\n    ...\n        some method and field\n    ...\n    @ExceptionHandler(Exception.class)\n    public ModelAndView deal(Exception e) {\n         ...\n           do something     \n        ...\n        return new ModelAndView();\n    }\n}\n</code></pre>\n<p>然后这个controller中如果抛出异常的话，那么会使用这个方法来处理异常。</p>\n<p>这种方式有一个缺点，那就是当controller多了之后，每个controller都需要写一个这样的方法作异常处理，那么么会很不方便，解决办法有两个：</p>\n<ul>\n<li><p>声明一个父类的controller，然后让所有的controller去继承这个controller（不推荐）</p>\n</li><li><p>使用<a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\"><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></a> 这是一个通知，打上这个注解的类会被spring给识别，然后可以在这个类中定义方法来处理异常，例如：</p>\n<pre><code class=\"lang-java\"><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a>\npublic class SpringExceptionHandler{\n\n    /**\n     * 统一异常处理方式\n     * <a href=\"https://github.com/param\" title=\"&#64;param\" class=\"at-link\">@param</a> e 出现的异常类\n     * <a href=\"https://github.com/return\" title=\"&#64;return\" class=\"at-link\">@return</a> 跳转的视图\n     */\n    <a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a>(Exception.class)\n    public ModelAndView globalExceptionHandler(Exception e) {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject(&quot;ex&quot;,e);\n        mv.setViewName(&quot;error&quot;);\n        return mv;\n    }\n\n}\n</code></pre>\n</li></ul>\n<p>springmvc的异常处理方式大概就说完了，还有就是这些类的源码需要去花时间阅读，搞清楚其中到底是怎么实现的。</p>\n','## springmvc中异常的处理方式\n\nspringmvc中主要提供了两种处理异常的方式\n\n- 使用SimpleMappingExceptionResolver\n- 使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\n\n\n\n1、SimpleMappingExceptionResolver方式\n\n这种方式其实很简单，主要是在xml文件中进行一些简单的配置就OK了\n\n例如：\n\n```xml\n<!--配置异常处理bean-->\n	<bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\" >\n		<!--表示所有没有指定的异常全部由defaultError.jsp进行处理-->\n		<property name=\"defaultErrorView\" value=\"error\" />\n		<!--配置在页面中访问的异常对象的名字\n			也就是说，在所有的页面中都可以通过EL表达式的来访问ex这个变量，进而获取异常信息进行处理\n		-->\n		<property name=\"exceptionAttribute\" value=\"ex\" />\n		<property name=\"exceptionMappings\" >\n			<props>\n				<prop key=\"org.apache.shiro.authz.UnauthorizedException\">/defaultError</prop>\n			</props>\n		</property>\n	</bean>\n```\n\n实际上就是配置一个bean，这个bean是SimpleMappingExceptionResolver的实例\n\n这里主要就是配置三个属性\n\n- defaultErroeView就是默认异常跳转的页面，这里需要注意的是不能直接写成xxx.jsp或者xxx.html，而是需要根据你当前的springmvc的视图解析的环境进行设置。\n- exceptionAttribute 这个属性是配置返回视图时携带的参数的名称，这里设置为ex，到了JSP环境中就可以使用El表达式获取相关错误信息。例如${ex.message}\n- exceptionMappings 这个属性主要是设置某个具体的异常跳转的页面，这是一个数组，里面的子标签props的key属性配置的是处理的异常的全限定类名，然后值也是根据当前的springmvc的配置进行跳转的请求URL。\n\n\n\n\n\n2、使用@ExceptionHandler注解进行异常处理\n\n这个注解可以声明在一个方法上\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface ExceptionHandler {\n\n	/**\n	 * Exceptions handled by the annotated method. If empty, will default to any\n	 * exceptions listed in the method argument list.\n	 */\n	Class<? extends Throwable>[] value() default {};\n\n}\n```\n\n接收具体的类作为一个参数，然后如果抛出了这个异常那么就使用这个方法进行处理，但是据李刚的疯狂讲义上面说这个注解需要这个函数声明在controller中，例如\n\n\n\n```java\n@Controller\npublic class BlogController {\n    ...\n        some method and field\n    ...\n    @ExceptionHandler(Exception.class)\n    public ModelAndView deal(Exception e) {\n 		...\n       	do something     \n        ...\n        return new ModelAndView();\n    }\n}\n```\n\n然后这个controller中如果抛出异常的话，那么会使用这个方法来处理异常。\n\n这种方式有一个缺点，那就是当controller多了之后，每个controller都需要写一个这样的方法作异常处理，那么么会很不方便，解决办法有两个：\n\n- 声明一个父类的controller，然后让所有的controller去继承这个controller（不推荐）\n\n- 使用@ControllerAdvice 这是一个通知，打上这个注解的类会被spring给识别，然后可以在这个类中定义方法来处理异常，例如：\n\n  ```java\n  @ControllerAdvice\n  public class SpringExceptionHandler{\n  \n      /**\n       * 统一异常处理方式\n       * @param e 出现的异常类\n       * @return 跳转的视图\n       */\n      @ExceptionHandler(Exception.class)\n      public ModelAndView globalExceptionHandler(Exception e) {\n          ModelAndView mv = new ModelAndView();\n          mv.addObject(\"ex\",e);\n          mv.setViewName(\"error\");\n          return mv;\n      }\n  \n  }\n  \n  ```\n\nspringmvc的异常处理方式大概就说完了，还有就是这些类的源码需要去花时间阅读，搞清楚其中到底是怎么实现的。','springmvc中异常的处理方式springmvc中主要提供了两种处理异常的方式\n\n使用SimpleMappingExceptionResolver使用@ExceptionHandler注解实现局部异常处理或使用@ControllerAdvice注解实现统一异常处理\n1、SimpleMapping','2019-01-08 00:41:45','2019-01-08 00:41:45',16,14,0,10,10,'d39b45c076b14cf0a97cf1d9f6fa6363',1),(16,'Redis 安装','<h2 id=\"h2-redis-\"><a name=\"redis学习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis学习</h2><p>1、redis的安装</p>\n<ul>\n<li>首先在官方网站中下载gz包然后上传到linux中</li><li>解压</li><li>安装gcc环境，如果已经安装那么直接下一步</li><li>进入bin目录并且执行make编译（不同于nginx，因为redis自带有makefile文件)</li><li>编译完成后执行 make install PREFIX=安装路径 命令</li><li>将bin文件夹中的redis.conf文件移动到安装路径中的bin目录下，方便执行后台运行</li><li>将redis.conf文件中的daemonize属性改为yes，开启后台执行</li><li>将redis.conf文件中的<strong>stop-writes-on-bgsave-error yes</strong> 改为<strong>stop-writes-on-bgsave-error no</strong></li></ul>\n<p>2、创建日志文件夹以及redis持久化文件夹并且赋予读写权限</p>\n<p>3、相关的命令</p>\n<ul>\n<li>启动redis：./redis-server xxx.conf</li><li>关闭redis：./redis-cli shutdown</li><li>连接redis：./redis-cli</li><li>连接上之后退出：quit</li></ul>\n<h2 id=\"h2-redis-\"><a name=\"redis关闭服务出现错误的问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis关闭服务出现错误的问题</h2><p><strong>1、(error) ERR Errors trying to SHUTDOWN. Check logs.</strong></p>\n<blockquote>\n<p>./redis-cli shutdown</p>\n<p>错误提示：(error) ERR Errors trying to SHUTDOWN. Check logs.</p>\n</blockquote>\n<p>解决办法：</p>\n<p>修改redis.conf文件中的</p>\n<p>dir这一行   ，改为一个自己创建的目录，这个目录用于存储数据，也就是做持久化的目录</p>\n<p>例如：</p>\n<blockquote>\n<p>dir /usr/local/redis/bin/redis_dbfiles</p>\n</blockquote>\n<p><strong>2、日志文件报错</strong></p>\n<p>23072:M 08 Jan 2019 22&#58;09&#58;31.857 <em> Ready to accept connections<br>23072:M 08 Jan 2019 22&#58;11&#58;05.727 # User requested shutdown…<br>23072:M 08 Jan 2019 22&#58;11&#58;05.729 </em> Saving the final RDB snapshot before exiting.<br>23072:M 08 Jan 2019 22&#58;11&#58;05.729 # <strong>Failed opening the RDB file dump.rdb (in server root dir /usr/local/redis/bin/redis_dbfiles) for saving: Permission denied</strong></p>\n<p>这里是没有权限的问题，给日志的文件及文件夹授予读写权限即可</p>\n<blockquote>\n<p>sudo chmod 777 xxx文件或文件夹</p>\n</blockquote>\n','## redis学习\n\n1、redis的安装\n\n- 首先在官方网站中下载gz包然后上传到linux中\n- 解压\n- 安装gcc环境，如果已经安装那么直接下一步\n- 进入bin目录并且执行make编译（不同于nginx，因为redis自带有makefile文件)\n- 编译完成后执行 make install PREFIX=安装路径 命令\n- 将bin文件夹中的redis.conf文件移动到安装路径中的bin目录下，方便执行后台运行\n- 将redis.conf文件中的daemonize属性改为yes，开启后台执行\n- 将redis.conf文件中的**stop-writes-on-bgsave-error yes** 改为**stop-writes-on-bgsave-error no**\n\n2、创建日志文件夹以及redis持久化文件夹并且赋予读写权限\n\n3、相关的命令\n\n- 启动redis：./redis-server xxx.conf\n- 关闭redis：./redis-cli shutdown\n- 连接redis：./redis-cli\n- 连接上之后退出：quit\n\n\n## redis关闭服务出现错误的问题\n\n**1、(error) ERR Errors trying to SHUTDOWN. Check logs.**\n\n> ./redis-cli shutdown\n>\n> 错误提示：(error) ERR Errors trying to SHUTDOWN. Check logs.\n\n解决办法：\n\n修改redis.conf文件中的\n\ndir这一行   ，改为一个自己创建的目录，这个目录用于存储数据，也就是做持久化的目录\n\n例如：\n\n> dir /usr/local/redis/bin/redis_dbfiles\n\n**2、日志文件报错**\n\n23072:M 08 Jan 2019 22:09:31.857 * Ready to accept connections\n23072:M 08 Jan 2019 22:11:05.727 # User requested shutdown...\n23072:M 08 Jan 2019 22:11:05.729 * Saving the final RDB snapshot before exiting.\n23072:M 08 Jan 2019 22:11:05.729 # **Failed opening the RDB file dump.rdb (in server root dir /usr/local/redis/bin/redis_dbfiles) for saving: Permission denied**\n\n这里是没有权限的问题，给日志的文件及文件夹授予读写权限即可\n\n> sudo chmod 777 xxx文件或文件夹\n\n','redis学习1、redis的安装\n\n首先在官方网站中下载gz包然后上传到linux中解压安装gcc环境，如果已经安装那么直接下一步进入bin目录并且执行make编译（不同于nginx，因为redis自带有makefile文件)编译完成后执行 make install PREFIX=安装路径 命令将','2019-01-17 18:34:19','2019-01-17 18:34:19',0,15,0,34,1,'d39b45c076b14cf0a97cf1d9f6fa6363',1);
/*!40000 ALTER TABLE `bk_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_book`
--

DROP TABLE IF EXISTS `bk_book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_book` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `desc` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `imgId` varchar(255) NOT NULL,
  `price` double NOT NULL DEFAULT '0',
  `author` varchar(64) NOT NULL,
  `publishDate` datetime NOT NULL,
  `mode` int(1) NOT NULL,
  PRIMARY KEY (`id`,`name`) USING BTREE,
  KEY `imgId` (`imgId`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_book`
--

LOCK TABLES `bk_book` WRITE;
/*!40000 ALTER TABLE `bk_book` DISABLE KEYS */;
INSERT INTO `bk_book` VALUES (1,'java编程思想','本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。','d2f07e316b944c49b22305c03fb0624e',108,'Bruce Eckel','2007-06-17 01:06:54',1),(2,'spring in action','《Spring in Action(中文版)(第2版)》分成三大部分并附有两个附录，每一部分分别对应Spring框架的一个领域：核心框架、业务和数据层、表示层。每一部分既是建立在前一部分的基础上，同时也可以独立存在。因此，读者不必从头开始，完全可以直接深入到某个主题。书中第一部分展示了Spring框架的两个核心特性：依赖注入和面向切面编程。第二部分以第一部分介绍的DI和AOP特性为基础，叙述了如何将这两个概念应用到应用程序的数据和业务层中。第三部分介绍了Spring构建 Web应用程序的各种方式。','6aceaaa52fb64c129034192b716096ad',59,'沃尔斯，布雷登巴赫','2018-10-17 01:06:57',1),(3,'JavaScript高级程序设计','本书从最早期Netscape浏览器中的JavaScript开始讲起，直到当前它对XML和Web服务的具体支持，内容主要涉及JavaScript的语言特点、JavaScript与浏览器的交互、更高级的JavaScript技巧，以及与在Web应用程序中部署JavaScript解决方案有关的问题，如错误处理、调试、安全性、优化/混淆化、XML和Web服务，最后介绍应用所有这些知识来创建动态用户界面。','300f861b911a4037906c101485ca6e48',99,'(美)(Nicholas C.Zakas)扎卡斯','2016-01-17 01:07:02',1),(4,'重构','重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。\r\n\r\n本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。','2c65c0414df04fb8869bf071cd137f45',69,'（美）福勒 ','2010-11-03 01:07:05',1),(5,'设计模式之禅','如果说“四人帮”的《设计模式》是设计模式领域的“圣经”，那么之后出版的各种关于设计模式的书都可称之为“圣经”的“注释版”或“圣经的故事”。本书是得道者对“圣经”的“禅悟”，它既不像“圣经”那样因为惜字如金、字字珠玑而深奥、晦涩和难懂，又比“圣经”的“注释版”更深刻和全面、更通俗和生动、更接近开发者遇到的实践场景，更具指导性。本书兼收并蓄、博采众长，也许是设计模式领域里的下一个里程碑之作。','1b783e983c9a4a3d93b117461a4d1a6b',69,'秦小波','2010-03-01 01:06:42',1);
/*!40000 ALTER TABLE `bk_book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_category`
--

DROP TABLE IF EXISTS `bk_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_category` (
  `id` int(11) NOT NULL DEFAULT '1',
  `desc` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `itemCount` int(11) NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `createDateTime` datetime NOT NULL,
  `mode` int(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_category`
--

LOCK TABLES `bk_category` WRITE;
/*!40000 ALTER TABLE `bk_category` DISABLE KEYS */;
INSERT INTO `bk_category` VALUES (1,'网站首页顶部导航栏',5,'2018-11-28 14:32:25','2018-11-28 14:32:29',1);
/*!40000 ALTER TABLE `bk_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_category_link`
--

DROP TABLE IF EXISTS `bk_category_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_category_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `lid` int(11) NOT NULL,
  `cid` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `lid` (`lid`) USING BTREE,
  KEY `cid` (`cid`) USING BTREE,
  CONSTRAINT `cid` FOREIGN KEY (`cid`) REFERENCES `bk_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `lid` FOREIGN KEY (`lid`) REFERENCES `bk_link` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_category_link`
--

LOCK TABLES `bk_category_link` WRITE;
/*!40000 ALTER TABLE `bk_category_link` DISABLE KEYS */;
INSERT INTO `bk_category_link` VALUES (1,20,1),(2,21,1),(3,22,1),(4,23,1),(5,24,1);
/*!40000 ALTER TABLE `bk_category_link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_img`
--

DROP TABLE IF EXISTS `bk_img`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_img` (
  `id` varchar(255) NOT NULL,
  `src` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDateTime` datetime DEFAULT NULL,
  `updateDateTime` datetime DEFAULT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_img`
--

LOCK TABLES `bk_img` WRITE;
/*!40000 ALTER TABLE `bk_img` DISABLE KEYS */;
INSERT INTO `bk_img` VALUES ('1b783e983c9a4a3d93b117461a4d1a6b','http://www.ljtnono.cn:8888/group1/M00/00/00/rBUAC1ygWYWAWrROAAA8Cs9mNEQ695.jpg','sjmszc.jpg','2019-03-31 06:09:10','2019-03-31 06:09:10',1),('2c65c0414df04fb8869bf071cd137f45','http://www.ljtnono.cn:8888/group1/M00/00/00/rBKlY1ygVZSABxoeAAKFz_L1ovs843.jpg','cg.jpg','2019-03-31 05:52:22','2019-03-31 05:52:22',1),('300f861b911a4037906c101485ca6e48','http://www.ljtnono.cn:8888/group1/M00/00/00/rBUAC1ygWXCADt3MAAJAvxkPi4s062.png','javascriptgjcxsj.png','2019-03-31 06:08:49','2019-03-31 06:08:49',1),('328e571775694d368546c4a1d00642ec','http://www.ljtnono.cn:8888/group1/M00/00/00/rBKlY1yPdXuAZpA4AABCciVDx7g495.jpg','rBKlY1yPdXuAZpA4AABCciVDx7g495.jpg','2019-03-18 18:39:56','2019-03-18 18:39:56',1),('402188c6586f4951a11cb51640648db6','http://www.ljtnono.cn:8888/group1/M00/00/00/rBKlY1ygKnaAWYpoAAWT-tCWuK0413.jpg','editormd-image-file','2019-03-31 02:48:23','2019-03-31 02:48:23',1),('4bcff200b0cd47e4b2ebb456acf8d6e0','/myblog/images/album_index/IMG_20180823_113536.jpg','index_album_2','2018-11-29 15:02:12','2019-03-27 23:40:45',1),('5e180e06e25e4433ae783325da9dbbb4','http://www.ljtnono.cn:8888/group1/M00/00/00/rBUAC1yTTJCAKvw5AABaTNAgat0168.jpg','editormd-image-file','2019-03-21 16:34:23','2019-03-21 16:34:23',1),('615129349d5b4301b86e2201ad40553c','http://www.ljtnono.cn:8888/group1/M00/00/00/rBUAC1yFycOAWBwPAAInnOxvOoo108.jpg','rBUAC1yFycOAWBwPAAInnOxvOoo108.jpg','2019-03-11 10:36:51','2019-03-11 10:36:51',1),('663de4696f8a41c8902830a7f7882d22','/myblog/images/album_index/IMG_20180823_114736.jpg','index_album_6','2018-11-29 15:05:19','2018-11-29 15:05:22',1),('6aceaaa52fb64c129034192b716096ad','http://www.ljtnono.cn:8888/group1/M00/00/00/rBUAC1ygWYyAVErWAAAkgTaZZwQ055.jpg','springinaction.jpg','2019-03-31 06:09:18','2019-03-31 06:09:18',1),('6c8035fe136945f8b335c357d4e0c5dc','/myblog/images/blog/java.jpg','java.jpg','2018-12-18 11:22:21','2018-12-18 11:22:21',1),('6dbfceae49e3420cb9d0390a23a4e8d3','/myblog/images/album_index/IMG_20180823_113545.jpg','index_album_3','2018-11-29 15:02:46','2019-03-27 23:40:45',1),('85ee95a44be345d685c0c4220b1ec6e5','/myblog/images/album_index/IMG_20180823_113722.jpg','index_album_4','2018-11-29 15:03:33','2018-11-29 15:03:35',1),('8e338c1d143444a99f3ef0f033949603','/myblog/images/album/me.jpg','me.jpg','2018-12-01 00:19:59','2019-03-27 23:40:45',1),('938b5b9a9e554fd982c6109dcae446e8','http://www.ljtnono.cn:8888/group1/M00/00/00/rBKlY1yEpZqACq25AAAbhH43tzY093.jpg','rBKlY1yEpZqACq25AAAbhH43tzY093.jpg','2019-03-10 13:50:18','2019-03-10 13:50:18',1),('973ff24c034a4d029a73b4d95f8aeb26','http://www.ljtnono.cn:8888/group1/M00/00/00/rBKlY1x-Y8yAaz9yAAA223X8130178.jpg','rBKlY1x-Y8yAaz9yAAA223X8130178.jpg','2019-03-05 19:55:56','2019-03-05 19:55:56',1),('a5cb36430cdf49e7866d8742bdb595b5','/myblog/images/album_index/IMG_20180823_114732.jpg','index_album_5','2018-11-29 15:04:41','2018-11-29 15:04:45',1),('d0352705b2dc42f6a1af5bb86a5c9947','/myblog/iamges/blog/6.png','6.png','2018-12-13 14:13:13','2019-03-27 23:40:45',1),('d2f07e316b944c49b22305c03fb0624e','http://www.ljtnono.cn:8888/group1/M00/00/00/rBUAC1ygWWWAYzBrAACj4fbZYAI927.jpg','javabcsx.jpg','2019-03-31 06:08:39','2019-03-31 06:08:39',1),('d39b45c076b14cf0a97cf1d9f6fa6363','http://www.ljtnono.cn:8888/group1/M00/00/00/rBKlY1x-YGWAH3TFAAAWufqxBS8650.jpg','默认图片','2019-03-05 19:41:45','2019-03-05 19:41:45',1);
/*!40000 ALTER TABLE `bk_img` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_link`
--

DROP TABLE IF EXISTS `bk_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `href` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `title` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type` int(11) NOT NULL,
  `classNames` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '',
  `createDateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `updateDateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_link`
--

LOCK TABLES `bk_link` WRITE;
/*!40000 ALTER TABLE `bk_link` DISABLE KEYS */;
INSERT INTO `bk_link` VALUES (1,'https://redis.io/','redis',2,'blog_friendlink','2019-03-31 11:24:07','2019-03-31 11:24:07',1),(2,'http://maven.apache.org/','maven',2,'blog_friendlink','2019-03-27 23:41:31','2019-03-27 23:41:31',1),(3,'http://tomcat.apache.org/','tomcat',2,'blog_friendlink','2019-03-27 23:41:31','2019-03-27 23:41:31',1),(4,'https://www.mysql.com/','mysql',2,'blog_friendlink','2019-03-27 23:41:31','2019-03-27 23:41:31',1),(5,'http://shiro.apache.org/','shiro',2,'blog_friendlink','2019-03-27 23:41:31','2019-03-27 23:41:31',1),(6,'http://www.mybatis.org/mybatis-3/','mybatis',2,'blog_friendlink','2019-03-27 23:41:32','2019-03-27 23:41:32',1),(7,'https://spring.io/','spring',2,'blog_friendlink','2019-03-27 23:41:32','2019-03-27 23:41:32',1),(8,'http://jquery.com/','jquery',2,'blog_friendlink','2019-03-27 23:41:30','2019-03-27 23:41:30',1),(9,'http://www.bootcss.com/','bootstrap',2,'blog_friendlink','2019-03-27 23:41:30','2019-03-27 23:41:30',1),(10,'http://wowslider.com/','WOWSlider',2,'blog_friendlink','2019-03-27 23:41:31','2019-03-27 23:41:31',1),(11,'http://nginx.org/en/','nginx',2,'blog_friendlink','2019-03-25 22:35:08','2019-03-25 22:35:08',1),(12,'https://www.liaosam.com/','料神SAM料网',2,'article_friendlink','2018-12-05 14:59:01','2018-12-05 14:59:01',1),(13,'https://www.wangzhijun.com.cn/','王志军博客',2,'article_friendlink','2018-12-05 14:59:03','2018-12-05 14:59:03',1),(14,'https://www.uctheme.com/','导购主题',2,'article_friendlink','2018-12-05 14:59:04','2018-12-05 14:59:04',1),(15,'https://www.xiaoleteam.com/','网络营销推广',2,'article_friendlink','2018-12-05 14:59:06','2018-12-05 14:59:06',1),(16,'https://yusi123.com/','思欲主题',2,'article_friendlink','2018-12-05 14:59:07','2018-12-05 14:59:07',1),(17,'http://www.wenzhihuai.com/','温志怀博客',2,'article_friendlink','2018-12-05 14:59:09','2018-12-05 14:59:09',1),(18,'https://www.yangqq.com/','杨青主题',2,'article_friendlink','2018-12-05 14:59:12','2018-12-05 14:59:12',1),(19,'http://huaban.com/','花瓣网',2,'article_friendlink','2018-12-05 14:59:15','2018-12-05 14:59:15',1),(20,'/myblog/blog','首页',1,'','2018-12-28 16:03:12','2018-12-28 16:03:12',1),(21,'/myblog/articles?page=1&type=all','技术文章',1,'','2019-01-07 12:12:46','2019-01-07 12:12:46',1),(22,'/myblog/album','相册',1,'','2019-02-01 15:46:55','2019-02-01 15:46:55',1),(23,'/myblog/support','支持作者',1,'','2019-02-05 15:23:50','2019-02-05 15:23:50',1),(24,'/myblog/aboutme','关于作者',1,'','2019-01-16 00:22:07','2019-01-16 00:22:07',1),(25,'/myblog/articles?page=1&type=java','java',1,'c-2e93d9 tag','2019-01-07 12:15:46','2019-01-07 12:15:46',1),(26,'/myblog/articles?page=1&type=html','html',1,'c-f05050 tag','2019-01-07 12:16:28','2019-01-07 12:16:28',1),(27,'/myblog/articles?page=1&type=css','css',1,'c-ff6600 tag','2019-01-07 12:16:36','2019-01-07 12:16:36',1),(28,'/myblog/articles?page=1&type=jquery','jquery',1,'c-ff6600 tag','2019-01-07 12:16:44','2019-01-07 12:16:44',1),(29,'/myblog/articles?page=1&type=js','js',1,'c-2e93d9 tag','2019-01-07 12:16:51','2019-01-07 12:16:51',1),(30,'/myblog/articles?page=1&type=boostrap','bootstrap',1,'c-f05050 tag','2019-01-07 12:16:59','2019-01-07 12:16:59',1),(31,'/myblog/articles?page=1&type=maven','maven',1,'c-2e93d9 tag','2019-03-27 23:41:43','2019-03-27 23:41:43',1),(32,'/myblog/articles?page=1&type=spring','spring',1,'c-2e93d9 tag','2019-03-27 23:41:43','2019-03-27 23:41:43',1),(33,'/myblog/articles?page=1&type=mybatis','mybatis',1,'c-ff6600 tag','2019-03-27 23:41:43','2019-03-27 23:41:43',1),(34,'/myblog/articles?page=1&type=springmvc','springmvc',1,'c-2e93d9 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1),(35,'/myblog/articles?page=1&type=springboot','springboot',1,'c-f05050 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1),(36,'/myblog/articles?page=1&type=android','android',1,'c-2e93d9 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1),(37,'/myblog/articles?page=1&type=ps','ps',1,'c-f05050 tag','2019-03-27 23:41:44','2019-03-27 23:41:44',1);
/*!40000 ALTER TABLE `bk_link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_permission`
--

DROP TABLE IF EXISTS `bk_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `res` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_permission`
--

LOCK TABLES `bk_permission` WRITE;
/*!40000 ALTER TABLE `bk_permission` DISABLE KEYS */;
/*!40000 ALTER TABLE `bk_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_role`
--

DROP TABLE IF EXISTS `bk_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_role` (
  `id` int(11) NOT NULL,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_role`
--

LOCK TABLES `bk_role` WRITE;
/*!40000 ALTER TABLE `bk_role` DISABLE KEYS */;
INSERT INTO `bk_role` VALUES (1,'admin',1);
/*!40000 ALTER TABLE `bk_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_skill`
--

DROP TABLE IF EXISTS `bk_skill`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_skill` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `grade` int(11) DEFAULT NULL,
  `mode` int(1) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_skill`
--

LOCK TABLES `bk_skill` WRITE;
/*!40000 ALTER TABLE `bk_skill` DISABLE KEYS */;
INSERT INTO `bk_skill` VALUES (1,'html/css',70,1),(2,'js',62,1),(3,'java',85,1),(4,'linux',45,1),(5,'ps',63,1),(6,'android',56,1);
/*!40000 ALTER TABLE `bk_skill` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_tag`
--

DROP TABLE IF EXISTS `bk_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `link` int(11) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `createDateTime` datetime NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `link_id` (`link`) USING BTREE,
  CONSTRAINT `link_id` FOREIGN KEY (`link`) REFERENCES `bk_link` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_tag`
--

LOCK TABLES `bk_tag` WRITE;
/*!40000 ALTER TABLE `bk_tag` DISABLE KEYS */;
INSERT INTO `bk_tag` VALUES (1,25,'java','2018-11-29 21:25:34','2019-01-11 21:25:34',1),(2,26,'html','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(3,27,'css','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(4,28,'jquery','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(5,29,'js','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(6,30,'bootstrap','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(7,31,'maven','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(8,32,'spring','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(9,33,'mybatis','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(10,34,'springmvc','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(11,35,'springboot','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(12,36,'android','2018-11-29 21:25:34','2018-11-29 21:25:34',1),(13,37,'ps','2018-11-29 21:25:34','2018-11-29 21:25:34',1);
/*!40000 ALTER TABLE `bk_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_time_line`
--

DROP TABLE IF EXISTS `bk_time_line`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_time_line` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `date` datetime DEFAULT NULL,
  `mode` int(1) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_time_line`
--

LOCK TABLES `bk_time_line` WRITE;
/*!40000 ALTER TABLE `bk_time_line` DISABLE KEYS */;
INSERT INTO `bk_time_line` VALUES (1,'2019-01-19 22:40:00',1,'完成关于我页面的相关内容，页面虽然不是很好看，但是好歹是自己辛辛苦苦做出来的，还是蛮有成就感的，今后会更加努力！'),(2,'2019-01-18 15:41:41',1,'接入畅言评论系统感觉还不错哦'),(3,'2018-11-14 12:03:45',1,'更新side部分，解决tomcatbug问题，新增文章详情页面，使用了Editor来显示文章内容，修复了.tag类名污染问题BUG'),(4,'2018-11-11 15:22:36',1,'添加技术文章页面，引入font-awesome字体图标系统，减少了网页的图片，分离出来文章列表部分的样式形成单独的文件，将header和footer jsp中的html部分去掉只剩下内容部分'),(5,'2018-11-03 14:22:15',1,'分离出来了header和footer页面，修复hot5页面不能垂直居中的问题'),(6,'2018-11-01 11:22:56',1,'上一个项目完成，博客项目开始进行，搭建环境，引入shiro');
/*!40000 ALTER TABLE `bk_time_line` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_user`
--

DROP TABLE IF EXISTS `bk_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_user` (
  `id` int(11) NOT NULL,
  `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `desc` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `qq` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `tel` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `email` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `createDateTime` datetime NOT NULL,
  `updateDateTime` datetime NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`,`username`) USING BTREE,
  KEY `id` (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_user`
--

LOCK TABLES `bk_user` WRITE;
/*!40000 ALTER TABLE `bk_user` DISABLE KEYS */;
INSERT INTO `bk_user` VALUES (1,'BruseLing','51af133d21379bf3625171e1cc70cd34','超级管理员','935188400','15337106753','935188400@qq.com','2018-11-22 19:27:41','2018-11-22 19:27:45',1);
/*!40000 ALTER TABLE `bk_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_user_role`
--

DROP TABLE IF EXISTS `bk_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_user_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uid` int(11) NOT NULL,
  `rid` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `rid` (`rid`) USING BTREE,
  KEY `uid` (`uid`) USING BTREE,
  CONSTRAINT `rid` FOREIGN KEY (`rid`) REFERENCES `bk_role` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `uid` FOREIGN KEY (`uid`) REFERENCES `bk_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_user_role`
--

LOCK TABLES `bk_user_role` WRITE;
/*!40000 ALTER TABLE `bk_user_role` DISABLE KEYS */;
INSERT INTO `bk_user_role` VALUES (1,1,1);
/*!40000 ALTER TABLE `bk_user_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bk_webconfig`
--

DROP TABLE IF EXISTS `bk_webconfig`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `bk_webconfig` (
  `id` int(11) NOT NULL,
  `blogName` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blogAuthor` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `record` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `from` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `mode` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bk_webconfig`
--

LOCK TABLES `bk_webconfig` WRITE;
/*!40000 ALTER TABLE `bk_webconfig` DISABLE KEYS */;
INSERT INTO `bk_webconfig` VALUES (1,'JT Geek','BruseLing','粤ICP备17092242号-1','思欲主题',1);
/*!40000 ALTER TABLE `bk_webconfig` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-03-31 16:17:31
